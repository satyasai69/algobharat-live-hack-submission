"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable no-nested-ternary */
/* eslint-disable no-plusplus */
/* eslint-disable max-classes-per-file */
/* eslint-disable no-unused-vars */
const node_fetch_1 = __importDefault(require("node-fetch"));
const vlq = __importStar(require("vlq"));
const tsdoc = __importStar(require("@microsoft/tsdoc"));
const ts = __importStar(require("ts-morph"));
// eslint-disable-next-line camelcase
const js_sha512_1 = require("js-sha512");
const path_1 = __importDefault(require("path"));
const langspec_json_1 = __importDefault(require("../static/langspec.json"));
const version_1 = require("../version");
const optimize_1 = require("./optimize");
const MULTI_OUTPUT_TYPES = ['split uint128', 'divmodw output', 'vrf return values', 'ecdsa pubkey'];
const ON_COMPLETES = [
    'NoOp',
    'OptIn',
    'CloseOut',
    'ClearState',
    'UpdateApplication',
    'DeleteApplication',
];
async function getSourceMap(vlqMappings) {
    const pcList = vlqMappings.split(';').map((m) => {
        const decoded = vlq.decode(m);
        if (decoded.length > 2)
            return decoded[2];
        return undefined;
    });
    let lastLine = 0;
    const mappings = {
        pcToLine: {},
        lineToPc: {},
    };
    // eslint-disable-next-line no-restricted-syntax
    for (const [pc, lineDelta] of pcList.entries()) {
        // If the delta is not undefined, the lastLine should be updated with
        // lastLine + the delta
        if (lineDelta !== undefined) {
            lastLine += lineDelta;
        }
        if (!(lastLine in mappings.lineToPc))
            mappings.lineToPc[lastLine] = [];
        mappings.lineToPc[lastLine].push(pc);
        mappings.pcToLine[pc] = lastLine;
    }
    return mappings;
}
function typeInfoToABIString(typeInfo, convertRefs = false) {
    if (typeInfo.kind === 'base') {
        if (convertRefs && ['appreference', 'assetreference'].includes(typeInfo.type)) {
            return 'uint64';
        }
        if (convertRefs && typeInfo.type === 'accountreference') {
            return 'address';
        }
        return typeInfo.type
            .replace('bytes', 'byte[]')
            .replace('assetid', 'uint64')
            .replace('appid', 'uint64')
            .replace(/^accountreference$/, 'account')
            .replace(/^appreference$/, 'application')
            .replace(/^assetreference$/, 'asset');
    }
    if (typeInfo.kind === 'tuple') {
        return `(${typeInfo.elements.map((e) => typeInfoToABIString(e, convertRefs)).join(',')})`;
    }
    if (typeInfo.kind === 'dynamicArray') {
        return `${typeInfoToABIString(typeInfo.base, convertRefs)}[]`;
    }
    if (typeInfo.kind === 'staticArray') {
        return `${typeInfoToABIString(typeInfo.base, convertRefs)}[${typeInfo.length}]`;
    }
    if (typeInfo.kind === 'object') {
        return `(${Object.values(typeInfo.properties)
            .map((p) => typeInfoToABIString(p, convertRefs))
            .join(',')})`;
    }
    if (typeInfo.kind === 'method') {
        return 'appl';
    }
    throw Error();
}
function equalTypes(a, b, ignoreUnsafe = false) {
    if (b.kind === 'base' && b.type === 'byteslike') {
        return (
        // eslint-disable-next-line no-use-before-define
        isBytes(a) ||
            // eslint-disable-next-line no-use-before-define
            (a.kind === 'staticArray' && isBytes(a.base)) ||
            // eslint-disable-next-line no-use-before-define
            (a.kind === 'dynamicArray' && isBytes(a.base)) ||
            (a.kind === 'base' && a.type === 'address'));
    }
    if (b.kind === 'base' && b.type === 'intlike') {
        return (
        // eslint-disable-next-line no-use-before-define
        isNumeric(a));
    }
    if (ignoreUnsafe) {
        return typeInfoToABIString(a).replace('unsafe ', '') === typeInfoToABIString(b).replace('unsafe ', '');
    }
    return typeInfoToABIString(a) === typeInfoToABIString(b);
}
// TODO: Merge this functionality directly into TypeInfo
// eslint-disable-next-line no-use-before-define
class TupleElement extends Array {
    constructor(type, headOffset) {
        super();
        this.staticLength = 0;
        if (typeof type === 'number')
            return;
        this.id = TupleElement.idCounter;
        this.type = type;
        this.headOffset = headOffset;
        TupleElement.idCounter += 1;
        if (type.kind === 'staticArray') {
            this.arrayType = 'static';
            this.staticLength = type.length;
        }
        else if (type.kind === 'dynamicArray') {
            this.arrayType = 'dynamic';
        }
        else if (type.kind === 'tuple' || type.kind === 'object') {
            this.arrayType = 'tuple';
        }
    }
    add(...elements) {
        elements.forEach((e) => {
            e.parent = this;
        });
        return this.push(...elements);
    }
}
TupleElement.idCounter = 0;
function getStorageName(node) {
    const thisNode = node.getFirstDescendantByKind(ts.SyntaxKind.ThisKeyword);
    const propNode = thisNode?.getParentIfKind(ts.SyntaxKind.PropertyAccessExpression);
    return propNode?.getName();
}
function getDocNodeAsString(node) {
    if (node instanceof tsdoc.DocPlainText) {
        return node.text;
    }
    if (node instanceof tsdoc.DocSoftBreak) {
        return '\n';
    }
    if (node instanceof tsdoc.DocParagraph) {
        return `${node.getChildNodes().map(getDocNodeAsString).join('')}\n`;
    }
    // Handle other types of nodes if needed
    return '';
}
function renderDocNode(docNode) {
    let result = '';
    if (docNode) {
        // eslint-disable-next-line no-restricted-syntax
        for (const childNode of docNode.getChildNodes()) {
            result += getDocNodeAsString(childNode);
        }
    }
    return result.trim();
}
function stringToExpression(str) {
    if (str.startsWith('{')) {
        const srcFile = ts.ts.createSourceFile('', `type Foo = ${str}`, ts.ScriptTarget.ES2022, true);
        const typeAlias = srcFile.statements[0];
        return typeAlias.type;
    }
    const srcFile = ts.ts.createSourceFile('', str, ts.ScriptTarget.ES2019, true);
    return srcFile.statements[0].expression;
}
function capitalizeFirstChar(str) {
    return `${str.charAt(0).toUpperCase() + str.slice(1)}`;
}
// Represents the stack types available in the AVM
const StackType = {
    void: { kind: 'base', type: 'void' },
    uint64: { kind: 'base', type: 'uint64' },
    bytes: { kind: 'base', type: 'bytes' },
    any: { kind: 'base', type: 'any' },
};
// Represents the type_enum for a transaction
// eslint-disable-next-line no-shadow
var TransactionType;
(function (TransactionType) {
    TransactionType["PaymentTx"] = "pay";
    TransactionType["KeyRegistrationTx"] = "keyreg";
    TransactionType["AssetConfigTx"] = "acfg";
    TransactionType["AssetTransferTx"] = "axfer";
    TransactionType["AssetFreezeTx"] = "afrz";
    TransactionType["ApplicationCallTx"] = "appl";
    TransactionType["StateProofTx"] = "stpf";
})(TransactionType || (TransactionType = {}));
const ForeignType = {
    Asset: { kind: 'base', type: 'assetid' },
    Address: { kind: 'base', type: 'address' },
    Application: { kind: 'base', type: 'appid' },
};
const TXN_TYPES = ['txn', 'pay', 'keyreg', 'acfg', 'axfer', 'afrz', 'appl'];
const TXN_METHODS = [
    'Payment',
    'AppCall',
    'MethodCall',
    'AssetTransfer',
    'AssetCreation',
    'AssetFreeze',
    'AssetConfig',
    'OnlineKeyRegistration',
    'OfflineKeyRegistration',
].flatMap((m) => [`send${m}`, `add${m}`]);
const CONTRACT_CLASS = 'Contract';
const LSIG_CLASS = 'LogicSig';
const PARAM_TYPES = {
    // Global
    CurrentApplicationID: 'appid',
    // Txn
    XferAsset: 'assetid',
    ApplicationID: 'appid',
    ConfigAsset: 'assetid',
    FreezeAsset: 'assetid',
    CreatedAssetID: 'assetid',
    CreatedApplicationID: 'appid',
    ApplicationArgs: `ImmediateArray: bytes`,
    Applications: `ImmediateArray: appid`,
    Assets: `ImmediateArray: assetid`,
    Accounts: `ImmediateArray: address`,
};
// These should probably be types rather than strings?
function isNumeric(t) {
    return t.kind === 'base' && ['uint64', 'assetid', 'appid'].includes(t.type);
}
function isBytes(t) {
    return t.kind === 'base' && ['bytes', 'byte[]', 'string', 'byte'].includes(t.type);
}
function isRefType(t) {
    return t.kind === 'base' && ['accountreference', 'assetreference', 'appreference'].includes(t.type);
}
function getObjectTypes(givenType) {
    if (givenType.kind !== 'object')
        throw Error();
    return givenType.properties;
}
function isArrayType(type) {
    return type.kind !== 'base';
}
function typeComparison(inputType, expectedType, ignoreUnsafe = false) {
    if (equalTypes(expectedType, StackType.any))
        return;
    if (equalTypes(inputType, expectedType, ignoreUnsafe))
        return;
    if (inputType.kind === 'base' && expectedType.kind === 'base') {
        if (expectedType.type === 'txn' && TXN_TYPES.includes(inputType.type))
            return;
        const sameTypes = [
            ['address', 'account'],
            ['bytes', 'string', 'byte[]', 'byte'],
        ];
        let typeEquality = false;
        sameTypes.forEach((t) => {
            if (t.includes(inputType.type) && t.includes(expectedType.type)) {
                typeEquality = true;
            }
        });
        if (typeEquality)
            return;
    }
    throw Error(`Type mismatch: got ${typeInfoToABIString(inputType)} expected ${typeInfoToABIString(expectedType)}`);
}
function isSmallNumber(type) {
    const abiType = typeInfoToABIString(type);
    if (!(abiType.match(/uint\d+$/) || abiType.match(/ufixed\d+x\d+$/)))
        return false;
    const width = Number(abiType.match(/\d+/)[0]);
    if (abiType.startsWith('ufixed64'))
        return true;
    return width < 64;
}
const compilerScratch = {
    fullArray: '255 // full array',
    elementStart: '254 // element start',
    elementLength: '253 // element length',
    newElement: '252 // new element',
    elementHeadOffset: '251 // element head offset',
    lengthDifference: '250 // length difference',
    subtractHeadDifference: '249 // subtract head difference',
    verifyTxnIndex: '248 // verifyTxn index',
    spliceStart: '247 // splice start',
    spliceByteLength: '246 // splice byte length',
    assignmentValue: '245 // assignment value',
};
/** @internal */
class Compiler {
    /** Verifies ABI types are properly decoded for runtime usage */
    checkDecoding(node, type) {
        if (type.kind === 'base' && type.type === 'bool') {
            this.pushLines(node, 'int 0', 'getbit');
        }
        else if (this.isDynamicArrayOfStaticType(type) || isBytes(type)) {
            this.pushVoid(node, 'extract 2 0');
        }
        else if (isNumeric(type) || isSmallNumber(type)) {
            this.pushVoid(node, 'btoi');
        }
    }
    processNewValue(node, numericType) {
        if (node.getType().isNumberLiteral() && numericType) {
            this.processNumericLiteralWithType(node, numericType);
        }
        else if (node.isKind(ts.SyntaxKind.BinaryExpression)) {
            this.processBinaryExpression(node, true);
        }
        else {
            this.processNode(node);
        }
        if (this.usingValue(node.getParentOrThrow())) {
            this.pushLines(node.getParentOrThrow(), 'dup', `store ${compilerScratch.assignmentValue}`);
        }
    }
    /** Handle any action related to boxes or local/global state */
    handleStorageAction({ node, action, storageKeyFrame, storageAccountFrame, newValue, }) {
        const name = getStorageName(node);
        const thisNode = node.getFirstDescendantByKindOrThrow(ts.SyntaxKind.ThisKeyword);
        const storagePropNode = thisNode.getParentIfKindOrThrow(ts.SyntaxKind.PropertyAccessExpression);
        const storagePropCallNode = storagePropNode.getParentIfKind(ts.SyntaxKind.CallExpression);
        const fullPropNode = (storagePropCallNode || storagePropNode).getParentIfKindOrThrow(ts.SyntaxKind.PropertyAccessExpression);
        const fullCallNode = fullPropNode.getParentIfKind(ts.SyntaxKind.CallExpression);
        const args = [];
        let keyNode;
        // If the node is a call expression, such as `this.myBox.replace(x, y)` get the arguments
        // then use the property access expression as the node throughout the rest of the method
        if (fullCallNode !== undefined) {
            fullCallNode.getArguments().forEach((a) => args.push(a));
        }
        // eslint-disable-next-line no-param-reassign
        node = fullPropNode;
        const expr = node.getExpression();
        // The node representing the key for the storage object
        if (expr.isKind(ts.SyntaxKind.CallExpression)) {
            keyNode = expr.getArguments()[expr.getArguments().length === 2 ? 1 : 0];
        }
        const { type, valueType, keyType, key, dynamicSize, prefix } = this.storageProps[name];
        const storageType = type;
        // If accesing an account's local state that is saved in the frame
        if (storageAccountFrame && storageType === 'local') {
            this.pushVoid(node.getExpression(), `frame_dig ${this.localVariables[storageAccountFrame].index} // ${storageAccountFrame}`);
            // Accessing a local state for an account given as an argument
        }
        else if (storageType === 'local') {
            if (!expr.isKind(ts.SyntaxKind.CallExpression))
                throw Error();
            this.processNode(expr.getArguments()[0]);
        }
        // Since global/local state doesn't have a native "exists" opcode like boxes
        // we need to use get...ex opcode on the current app ID
        if (action === 'exists' && (storageType === 'global' || storageType === 'local')) {
            this.pushVoid(node.getExpression(), 'txna Applications 0');
        }
        // If a key is defined in the property (LocalStateKey, GlobalStateKey, BoxKey)
        if (key) {
            const hex = Buffer.from(key).toString('hex');
            this.pushVoid(node.getExpression(), `byte 0x${hex} // "${key}"`);
            // If the key is saved in frame
        }
        else if (storageKeyFrame) {
            this.pushVoid(node.getExpression(), `frame_dig ${this.localVariables[storageKeyFrame].index} // ${storageKeyFrame}`);
            // If the key is provided as an argument
        }
        else {
            if (prefix) {
                const hex = Buffer.from(prefix).toString('hex');
                this.pushVoid(keyNode, `byte 0x${hex} // "${prefix}"`);
            }
            const prevTypeHint = this.typeHint;
            this.typeHint = keyType;
            this.processNode(keyNode);
            this.typeHint = prevTypeHint;
            if (!equalTypes(keyType, StackType.bytes)) {
                this.checkEncoding(keyNode, this.lastType);
            }
            if (prefix)
                this.pushVoid(keyNode, 'concat');
        }
        switch (action) {
            case 'get':
                if (storageType === 'global') {
                    this.push(node.getExpression(), 'app_global_get', valueType);
                }
                else if (storageType === 'local') {
                    this.push(node.getExpression(), 'app_local_get', valueType);
                }
                else if (storageType === 'box') {
                    this.assertMaybeValue(node.getExpression(), 'box_get', valueType, `box value does not exist: ${node
                        .getText()
                        .split('\n')
                        .map((l) => l.trim())
                        .join(' ')}`);
                }
                if ((storageType === 'box' || !isNumeric(valueType)) && !equalTypes(valueType, StackType.bytes)) {
                    this.checkDecoding(node, valueType);
                }
                break;
            case 'set': {
                if (storageType === 'box' && dynamicSize) {
                    this.pushLines(node.getExpression(), 'dup', 'box_del', 'pop');
                }
                if (newValue) {
                    const prevTypeHint = this.typeHint;
                    this.typeHint = valueType;
                    this.processNewValue(newValue);
                    this.typeHint = prevTypeHint;
                    // if valueType is not bytes
                    // or if storage type is box
                    if ((storageType === 'box' || !isNumeric(valueType)) && !equalTypes(valueType, StackType.bytes)) {
                        this.checkEncoding(newValue, this.lastType);
                    }
                    typeComparison(this.lastType, valueType);
                }
                else {
                    const isUnsafe = this.lastType.kind === 'base' && this.lastType.type.startsWith('unsafe ');
                    if (isUnsafe) {
                        this.checkEncoding(node, this.lastType);
                    }
                    const command = storageType === 'box' ? 'swap' : storageType === 'local' ? 'uncover 2' : 'swap';
                    this.pushVoid(node.getExpression(), command);
                    if ((storageType === 'box' || !isNumeric(valueType)) && !equalTypes(valueType, StackType.bytes)) {
                        this.checkEncoding(node, valueType);
                    }
                }
                const operation = storageType === 'global' ? 'app_global_put' : storageType === 'local' ? 'app_local_put' : 'box_put';
                this.push(node.getExpression(), operation, valueType);
                break;
            }
            case 'exists': {
                const existsAction = storageType === 'global' ? 'app_global_get_ex' : storageType === 'local' ? 'app_local_get_ex' : 'box_len';
                this.hasMaybeValue(node.getExpression(), existsAction);
                break;
            }
            case 'delete': {
                const deleteAction = storageType === 'global' ? 'app_global_del' : storageType === 'local' ? 'app_local_del' : 'box_del';
                this.pushVoid(node.getExpression(), deleteAction);
                break;
            }
            case 'resize':
                if (!equalTypes(valueType, StackType.bytes))
                    throw Error(`resize only supported on bytes, not ${keyType}`);
                this.processNode(args[0]);
                this.pushVoid(node.getExpression(), 'box_resize');
                break;
            case 'splice':
                if (!equalTypes(valueType, StackType.bytes))
                    throw Error(`splice only supported on bytes, not ${keyType}`);
                this.processNode(args[0]);
                this.processNode(args[1]);
                this.processNode(args[2]);
                this.pushVoid(node.getExpression(), 'box_splice');
                break;
            case 'create':
                if (args[0]) {
                    this.processNode(args[0]);
                }
                else if (this.isDynamicType(valueType)) {
                    throw Error(`Size must be given to create call when the box value is dynamic (${typeInfoToABIString(valueType)})`);
                }
                else
                    this.pushVoid(node, `int ${this.getTypeLength(valueType)}`);
                this.pushLines(node.getExpression(), 'box_create', 'pop');
                break;
            case 'extract':
                if (args[0] && args[1]) {
                    this.processNode(args[0]);
                    this.processNode(args[1]);
                }
                else {
                    this.pushVoid(node.getExpression(), 'cover 2');
                }
                this.push(node.getExpression(), 'box_extract', valueType);
                break;
            case 'replace':
                if (args[0] && args[1]) {
                    this.processNode(args[0]);
                    this.processNode(args[1]);
                }
                else {
                    this.pushVoid(node.getExpression(), 'cover 2');
                }
                this.pushVoid(node.getExpression(), 'box_replace');
                break;
            case 'size':
                this.assertMaybeValue(node.getExpression(), 'box_len', StackType.uint64, `box value does not exist: ${node
                    .getText()
                    .split('\n')
                    .map((l) => l.trim())
                    .join(' ')}`);
                break;
            default:
                throw new Error();
        }
    }
    getTypeInfo(type) {
        if (type.getText() === 'SplitUint128')
            return { kind: 'base', type: 'split uint128' };
        if (type.getText() === 'DivmodwOutput')
            return { kind: 'base', type: 'divmodw output' };
        if (type.getText() === 'VRFReturnValues')
            return { kind: 'base', type: 'vrf return values' };
        if (type.getText() === 'ECDSAPubKey')
            return { kind: 'base', type: 'ecdsa pubkey' };
        if (type.isNumberLiteral())
            return { kind: 'base', type: 'uint64' };
        if (type.isStringLiteral())
            return { kind: 'base', type: 'string' };
        if (type.isVoid())
            return { kind: 'base', type: 'void' };
        if (type.getText() === 'Account') {
            throw Error('`Account` no longer supported. Use `Address` instead. May require client-side changes. See this PR for more details: https://github.com/algorandfoundation/TEALScript/pull/296. Use `AccountReference` if you need to explicitly use the reference type.');
        }
        if (type.getText() === 'Application') {
            throw Error('`Application` type no longer supported. Use `AppID` instead. May require client-side changes. See this PR for more details: https://github.com/algorandfoundation/TEALScript/pull/296. Use `AppReference` if you need to explicitly use the reference type.');
        }
        if (type.getText() === 'Asset') {
            throw Error('Asset` type no longer supported. Use `AssetID` instead. May require client-side changes. See this PR for more details: https://github.com/algorandfoundation/TEALScript/pull/296. Use `AssetReference` if you need to explicitly use the reference type.');
        }
        if (type.getText().startsWith('InnerTxn<')) {
            const typeInfo = this.getTypeInfo(type.getAliasTypeArguments()[0]);
            if (typeInfo.kind !== 'base')
                throw Error('InnerTxn type must be a txn type');
            return { kind: 'base', type: `generic ${typeInfo.type}` };
        }
        if (type.getText() === 'Txn')
            return { kind: 'base', type: 'txn' };
        if (type.getText() === 'Required<PaymentParams>')
            return { kind: 'base', type: 'pay' };
        if (type.getText() === 'Required<AssetTransferParams>')
            return { kind: 'base', type: 'axfer' };
        if (type.getText() === 'AppCallTxn')
            return { kind: 'base', type: 'appl' };
        if (type.getText() === 'Required<KeyRegParams>')
            return { kind: 'base', type: 'keyreg' };
        if (type.getText() === 'Required<AssetConfigParams>')
            return { kind: 'base', type: 'acfg' };
        if (type.getText() === 'Required<AssetFreezeParams>')
            return { kind: 'base', type: 'afrz' };
        const aliasedTypeNode = this.getAliasedTypeNode(type);
        const typeString = (aliasedTypeNode?.getText() ?? type.getText())
            .toLowerCase()
            .replace(/</g, '')
            .replace(/>/g, '')
            .replace('typeof ', '')
            .replace(/, */g, 'x');
        if (typeString === 'byte')
            return { kind: 'base', type: 'byte' };
        const txnTypes = {
            thistxnparams: 'txn',
            paymentparams: 'pay',
            appparams: 'appl',
            assettransferparams: 'axfer',
            assetconfigparams: 'acfg',
            assetcreateparams: 'acfg',
            assetfreezeparams: 'afrz',
            onlinekeyregparams: 'keyreg',
            methodcallparams: 'appl',
        };
        if (txnTypes[typeString])
            return { kind: 'base', type: txnTypes[typeString] };
        if (typeString.startsWith('methodcall')) {
            const typeArgs = type.getAliasTypeArguments();
            let args = [];
            const returns = StackType.void;
            let name;
            if (typeArgs[0].isTuple()) {
                args = typeArgs[0].getTupleElements().map((e) => this.getTypeInfo(e));
            }
            else {
                const sig = typeArgs[0].getCallSignatures()[0];
                name = sig.getDeclaration().getName();
                args = sig.getParameters().map((param) => this.getTypeInfo(param.getDeclarations()[0].getType()));
            }
            return {
                kind: 'method',
                args,
                returns,
            };
        }
        if (typeString === 'itxnparams')
            return { kind: 'base', type: 'itxn' };
        if (typeString === 'bytes32')
            return { kind: 'staticArray', length: 32, base: { kind: 'base', type: 'byte' } };
        if (typeString === 'bytes64')
            return { kind: 'staticArray', length: 64, base: { kind: 'base', type: 'byte' } };
        if (type.isBoolean() || type.isBooleanLiteral())
            return { kind: 'base', type: 'bool' };
        if (type.isTuple()) {
            const typeInfo = {
                kind: 'tuple',
                elements: [],
            };
            type.getTupleElements().forEach((e) => {
                typeInfo.elements.push(this.getTypeInfo(e));
            });
            return typeInfo;
        }
        if (type.isArray()) {
            return {
                kind: 'dynamicArray',
                base: this.getTypeInfo(type.getArrayElementType()),
            };
        }
        if (['address', 'appid', 'assetid', 'assetreference', 'appreference', 'accountreference'].includes(typeString)) {
            return {
                kind: 'base',
                type: typeString,
            };
        }
        if (type.isObject()) {
            const typeInfo = { kind: 'object', properties: {} };
            type.getProperties().forEach((p) => {
                p.getDeclarations().forEach((d) => {
                    if (!d.isKind(ts.SyntaxKind.PropertySignature))
                        throw Error(`${type.getText()} ${d.getKindName()}`);
                    typeInfo.properties[p.getName()] = this.getTypeInfo(d.getType());
                });
            });
            return typeInfo;
        }
        if (aliasedTypeNode?.isKind(ts.SyntaxKind.TypeReference) && aliasedTypeNode?.getText().startsWith('StaticArray')) {
            const typeArgs = aliasedTypeNode.getTypeArguments();
            const length = Number(typeArgs[1].getType().getText());
            if (Number.isNaN(length))
                throw Error(`StaticArray length is not a literal number: ${typeArgs[1].getText()}`);
            return {
                kind: 'staticArray',
                length,
                base: this.getTypeInfo(typeArgs[0].getType()),
            };
        }
        if (type.getText().startsWith('StaticArray')) {
            const typeArgs = type.getAliasTypeArguments();
            const length = Number(typeArgs[1].getText());
            if (Number.isNaN(length))
                throw Error(`StaticArray length must be a literal number`);
            return {
                kind: 'staticArray',
                length,
                base: this.getTypeInfo(typeArgs[0]),
            };
        }
        if (type.getUnionTypes()[0]?.isNumber() ||
            type.getUnionTypes()[0]?.isString() ||
            type.isString() ||
            type.isNumber()) {
            return { kind: 'base', type: typeString.replace('number', 'uint64') };
        }
        if (type.isNumberLiteral()) {
            return { kind: 'base', type: `uint64` };
        }
        if (type.isStringLiteral()) {
            return { kind: 'base', type: `string` };
        }
        if (type.isAny()) {
            return { kind: 'base', type: 'any' };
        }
        if (typeString.match(/uint\d+$/) || typeString.match(/ufixed\d+x\d+$/)) {
            return { kind: 'base', type: typeString };
        }
        if (typeString === 'brandstringx"bytes"') {
            return { kind: 'base', type: 'bytes' };
        }
        if (typeString.match(/staticbytes\d+$/)) {
            return {
                kind: 'staticArray',
                base: { kind: 'base', type: 'byte' },
                length: Number(typeString.replace('staticbytes', '')),
            };
        }
        if (type.isUnion()) {
            const firstType = this.getTypeInfo(type.getUnionTypes()[0]);
            type.getUnionTypes().forEach((t) => {
                if (!equalTypes(this.getTypeInfo(t), firstType)) {
                    throw Error(`Union types must all be the same type`);
                }
            });
            return firstType;
        }
        throw Error(`Cannot resolve type ${type.getText()} (${typeString})`);
    }
    getAliasedTypeNode(type) {
        const isUserTypeAlias = (d) => {
            const sourcePath = path_1.default.normalize(d?.getSourceFile().getFilePath() ?? '');
            return (d?.isKind(ts.SyntaxKind.TypeAliasDeclaration) &&
                !sourcePath.startsWith(this.typesDir) &&
                !sourcePath.startsWith(this.libDir));
        };
        let currentTypeNode;
        const firstDeclaration = type.getAliasSymbol()?.getDeclarations().at(-1);
        if (isUserTypeAlias(firstDeclaration)) {
            currentTypeNode = firstDeclaration?.getTypeNode();
        }
        // eslint-disable-next-line no-constant-condition
        while (true) {
            if (currentTypeNode === undefined)
                break;
            const declaration = currentTypeNode.getSymbol()?.getDeclarations().at(-1);
            if (isUserTypeAlias(declaration)) {
                currentTypeNode = declaration.getTypeNode();
            }
            else
                break;
        }
        return currentTypeNode;
    }
    multiplyWideRatioFactors(node, factors) {
        if (factors.length === 1) {
            this.pushVoid(node, 'int 0');
            this.processNode(factors[0]);
        }
        else {
            this.processNode(factors[0]);
            this.processNode(factors[1]);
            this.pushVoid(node, 'mulw');
        }
        factors.slice(2).forEach((f) => {
            this.processNode(f);
            /*
            https://github.com/algorand/pyteal/blob/d117f99c07a64cddf6de21b72232df12b53fdbbb/pyteal/ast/widemath.py#LL12C8-L12C8
      
            stack is [..., A, B, C], where C is current factor
            need to pop all A,B,C from stack and push X,Y, where X and Y are:
                  X * 2**64 + Y = (A * 2**64 + B) * C
            <=>   X * 2**64 + Y = A * C * 2**64 + B * C
            <=>   X = A * C + highword(B * C)
                  Y = lowword(B * C)
      
            TealOp(expr, Op.uncover, 2),  # stack: [..., B, C, A]
            TealOp(expr, Op.dig, 1),  # stack: [..., B, C, A, C]
            TealOp(expr, Op.mul),  # stack: [..., B, C, A*C]
            TealOp(expr, Op.cover, 2),  # stack: [..., A*C, B, C]
            TealOp(
                expr, Op.mulw
            ),  # stack: [..., A*C, highword(B*C), lowword(B*C)]
            TealOp(
                expr, Op.cover, 2
            ),  # stack: [..., lowword(B*C), A*C, highword(B*C)]
            TealOp(
                expr, Op.add
            ),  # stack: [..., lowword(B*C), A*C+highword(B*C)]
            TealOp(
                expr, Op.swap
            ),  # stack: [..., A*C+highword(B*C), lowword(B*C)]
            */
            this.pushLines(node, 'uncover 2', 'dig 1', '*', 'cover 2', 'mulw', 'cover 2', '+', 'swap');
        });
    }
    arc4Description() {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const methods = [];
        const getEventJSON = (e) => {
            const args = e.args.map((a) => ({
                name: a.name,
                type: typeInfoToABIString(a.type, true),
                desc: a.desc ? a.desc : undefined,
            }));
            return { name: e.name, args, desc: e.desc };
        };
        this.abi.methods.forEach((m) => {
            const args = m.args.map((a) => ({
                name: a.name,
                type: typeInfoToABIString(a.type),
                desc: a.desc ? a.desc : undefined,
            }));
            const events = m.events.map((e) => getEventJSON(this.events[e]));
            methods.push({
                name: m.name,
                desc: m.desc ? m.desc : undefined,
                readonly: m.readonly,
                args,
                returns: {
                    type: typeInfoToABIString(m.returns.type, true),
                    desc: m.returns.desc ? m.returns.desc : undefined,
                },
                events: events.length ? events : undefined,
            });
        });
        const events = Object.values(this.events).map(getEventJSON);
        return { name: this.abi.name, desc: this.abi.desc, methods, events: events.length ? events : undefined };
    }
    verifyTxn(node, type) {
        const firstArg = node.getArguments()[1];
        if (!firstArg.isKind(ts.SyntaxKind.ObjectLiteralExpression))
            throw new Error('Expected object literal as second argument');
        const preTealLength = this.teal[this.currentProgram].length;
        this.processNode(node.getArguments()[0]);
        // Get the opcodes that were needed to process the txn index
        const opcodes = this.teal[this.currentProgram]
            .slice(preTealLength)
            .map((t) => t.teal)
            .filter((t) => !t.startsWith('//'));
        // If more than one opcode was needed, it will be more efficient to store the index in scratch
        const indexInScratch = opcodes.length > 1;
        if (indexInScratch) {
            this.pushVoid(node, `store ${compilerScratch.verifyTxnIndex}`);
        }
        else
            this.teal[this.currentProgram].pop();
        const loadField = (fieldNode, field) => {
            if (indexInScratch) {
                this.pushVoid(fieldNode, `load ${compilerScratch.verifyTxnIndex}`);
            }
            else if (node.getArguments()[0].getText() !== 'this.txn') {
                this.processNode(node.getArguments()[0]);
            }
            const txnOp = node.getArguments()[0].getText() === 'this.txn' ? 'txn' : 'gtxns';
            this.pushVoid(fieldNode, `${txnOp} ${capitalizeFirstChar(field)}`);
        };
        // Don't perform type check on method arguments because they are checked in the method routing
        let skipTypeCheck = false;
        if (node.getArguments()[0].isKind(ts.SyntaxKind.Identifier)) {
            const { name } = this.processFrame(node.getArguments()[0], node.getArguments()[0].getText(), false);
            if (this.currentSubroutine.args.find((a) => a.name === node.getArguments()[0].getText())) {
                skipTypeCheck = typeInfoToABIString(this.localVariables[name].type) === type;
            }
        }
        const txnText = node.getArguments()[0].getText();
        if (type !== undefined &&
            !skipTypeCheck &&
            (this.currentProgram === 'lsig' || node.getArguments()[0].getText() !== 'this.txn')) {
            this.pushVoid(node, `// verify ${type}`);
            loadField(node, 'typeEnum');
            this.pushVoid(node, `int ${type}`);
            this.pushVoid(node, '==');
            this.pushVoid(node, 'assert', `transaction verification failed: ${JSON.stringify({ txn: txnText, field: 'typeEnum', expected: type })}`);
        }
        const processConditionProp = (condAssignment, topProp, field) => {
            const condition = condAssignment.getNameNode().getText();
            if (['includedIn', 'notIncludedIn'].includes(condition)) {
                const propInit = condAssignment.getInitializer();
                if (!propInit?.isKind(ts.SyntaxKind.ArrayLiteralExpression))
                    throw Error('Expected array literal');
                propInit.getElements().forEach((e, eIndex) => {
                    loadField(topProp, field);
                    this.processNode(e);
                    const op = condition === 'includedIn' ? '==' : '!=';
                    this.pushLines(condAssignment, op);
                    if (eIndex)
                        this.pushLines(condAssignment, '||');
                });
                this.pushVoid(condAssignment, 'assert', `transaction verification failed: ${JSON.stringify({
                    txn: { txnText },
                    field,
                    condition,
                    expected: propInit.getText(),
                })}`);
                return;
            }
            const conditionMapping = {
                greaterThan: '>',
                greaterThanEqualTo: '>=',
                lessThan: '<',
                lessThanEqualTo: '<=',
                not: '!=',
            };
            const op = conditionMapping[condition];
            if (op === undefined)
                throw Error();
            loadField(topProp, field);
            this.processNode(condAssignment.getInitializer());
            this.pushLines(condAssignment, op);
            this.pushVoid(condAssignment, 'assert', `transaction verification failed: ${JSON.stringify({
                txn: txnText,
                field,
                condition,
                expected: op + condAssignment.getInitializer().getText(),
            })}`);
        };
        firstArg.getProperties().forEach((topProp, i) => {
            if (!topProp.isKind(ts.SyntaxKind.PropertyAssignment))
                throw new Error();
            const field = topProp.getNameNode().getText();
            this.pushVoid(topProp, `// verify ${field}`);
            const init = topProp.getInitializer();
            if (init?.isKind(ts.SyntaxKind.ObjectLiteralExpression)) {
                init.getProperties().forEach((childProp) => {
                    if (!childProp.isKind(ts.SyntaxKind.PropertyAssignment))
                        throw new Error();
                    const initializer = childProp.getInitializer();
                    if (childProp.getName().match(/^\d+$/)) {
                        this.pushVoid(childProp, `// verify ${field} ${childProp.getName()}`);
                        if (initializer?.isKind(ts.SyntaxKind.ObjectLiteralExpression)) {
                            initializer.getProperties().forEach((grandChildProp) => {
                                if (!grandChildProp.isKind(ts.SyntaxKind.PropertyAssignment))
                                    throw new Error();
                                processConditionProp(grandChildProp, topProp, `${field} ${childProp.getName()}`);
                            });
                        }
                        else {
                            loadField(childProp, `${field} ${childProp.getName()}`);
                            this.processNode(childProp.getInitializer());
                            this.pushLines(childProp, '==');
                            this.pushVoid(childProp, 'assert', `transaction verification failed: ${JSON.stringify({
                                txn: txnText,
                                field,
                                index: childProp.getName(),
                                expected: childProp.getInitializer().getText(),
                            })}`);
                        }
                    }
                    else
                        processConditionProp(childProp, topProp, field);
                });
                return;
            }
            loadField(topProp, field);
            this.processNode(topProp.getInitializer());
            this.pushLines(topProp, '==');
            this.pushVoid(topProp, 'assert', `transaction verification failed: ${JSON.stringify({
                txn: txnText,
                field,
                expected: topProp.getInitializer().getText(),
            })}`);
        });
    }
    forIterator(node, arrayNode, logic, paramName, method) {
        const arrayType = this.getStackTypeFromNode(arrayNode);
        // TODO: Support dynamic array of static type as well
        if (arrayType.kind !== 'staticArray')
            throw Error();
        if (typeInfoToABIString(arrayType.base) === 'bool') {
            throw Error('Iterating over boolean arrays is not currently supported');
        }
        if (this.isDynamicType(arrayType))
            throw Error('Cannot iterate over dynamic elements');
        const baseType = arrayType.base;
        const typeLength = this.getTypeLength(baseType);
        const frameName = `${method}//${node.getStartLinePos()}`;
        this.processNode(arrayNode);
        const lastTealLine = this.teal[this.currentProgram].at(-1).teal;
        // If this is a value larger than 4096 bytes in a box, use box_extract
        if (lastTealLine.startsWith('box_extract') && this.getTypeLength(arrayType) > 4096) {
            this.teal[this.currentProgram].pop(); // pop box_extract
            this.teal[this.currentProgram].pop(); // pop cover 2
            // Save box key
            this.initialFrameBury(node, `${frameName}//box_key`, StackType.bytes, 'key for the box that contains the array we are iterating over');
            // Save offset
            this.pushLines(node, 'swap', 'dup');
            this.initialFrameBury(node, `${frameName}//offset`, StackType.uint64, 'the offset we are extracting the next element from');
            // Save end offset
            this.pushLines(node, '+');
            this.initialFrameBury(node, `${frameName}//end_offset`, StackType.uint64, 'the offset of the last element');
            // Save the current element
            this.frameDig(node, `${frameName}//box_key`);
            this.frameDig(node, `${frameName}//offset`);
            this.pushLines(node, `int ${typeLength}`, 'box_extract');
            this.lastType = baseType;
            this.checkDecoding(node, baseType);
            this.initialFrameBury(node, paramName, baseType);
        }
        else {
            // Save the full array
            this.pushLines(node, 'dup');
            this.initialFrameBury(node, `${frameName}//aray`, arrayType, 'copy of the array we are iterating over');
            this.pushVoid(node, `extract 0 ${typeLength}`);
            this.checkDecoding(node, baseType);
            // Save the current element
            this.initialFrameBury(node, paramName, baseType);
            // Save the offset
            this.pushLines(node, 'int 0');
            this.initialFrameBury(node, `${frameName}//offset`, StackType.uint64, 'the offset we are extracting the next element from');
        }
        const label = `*${method}_${this[`${method}Count`]}`;
        this.pushLines(node, `${label}:`);
        this[`${method}Count`] += 1;
        const prevForEachLabel = this.currentForEachLabel;
        this.currentForEachLabel = label;
        const previousLoop = this.currentLoop;
        if (method === 'forOf')
            this.currentLoop = label;
        this.processNode(logic);
        this.currentLoop = previousLoop;
        this.currentForEachLabel = prevForEachLabel;
        const arrayIndex = this.localVariables[`${frameName}//aray`]?.index;
        // End of for each logic
        if (method === 'forOf')
            this.pushVoid(node, `${label}_continue:`);
        this.pushLines(node, '// increment offset and loop if not out of bounds');
        this.frameDig(node, `${frameName}//offset`);
        this.pushLines(node, `int ${typeLength}`, '+', 'dup');
        if (arrayIndex !== undefined) {
            this.pushVoid(node, `int ${arrayType.length * typeLength} // offset of last element`);
        }
        else {
            this.frameDig(node, `${frameName}//end_offset`);
        }
        this.pushLines(node, '<', `bz ${label}_end`);
        this.frameBury(node, `${frameName}//offset`);
        if (arrayIndex !== undefined) {
            this.frameDig(node, `${frameName}//aray`);
            this.frameDig(node, `${frameName}//offset`);
            this.pushLines(node, `int ${typeLength}`, 'extract');
        }
        else {
            this.frameDig(node, `${frameName}//box_key`);
            this.frameDig(node, `${frameName}//offset`);
            this.pushLines(node, `int ${typeLength}`, 'box_extract');
        }
        this.lastType = baseType;
        this.checkDecoding(node, baseType);
        this.frameBury(node, paramName);
        this.pushLines(node, `b ${label}`, `${label}_end:`);
    }
    constructor(options) {
        this.pendingSubroutines = [];
        this.scratch = {};
        this.currentProgram = 'approval';
        this.teal = {
            approval: [],
            clear: [],
            lsig: [],
        };
        this.generatedTeal = '';
        this.generatedClearTeal = '';
        this.frameInfo = {};
        this.mapKeyTypes = { global: [], local: [], box: [] };
        this.sourceInfo = [];
        this.frameIndex = 0;
        this.frameSize = {};
        this.subroutines = [];
        this.clearStateCompiled = false;
        this.ifCount = -1;
        this.ternaryCount = 0;
        this.whileCount = 0;
        this.doWhileCount = 0;
        this.forCount = 0;
        this.processErrorNodes = [];
        this.localVariables = {};
        this.bareCallConfig = {};
        this.abi = {
            name: '',
            desc: '',
            methods: [],
        };
        this.storageProps = {};
        this.lastType = { kind: 'base', type: 'void' };
        this.pcToLine = {};
        this.lineToPc = {};
        this.lastSourceCommentRange = [-1, -1];
        this.comments = [];
        this.OP_PARAMS = {
            account: [...this.getOpParamObjects('acct_params_get'), ...this.getOpParamObjects('asset_holding_get')],
            application: [
                ...this.getOpParamObjects('app_params_get'),
                {
                    name: 'GlobalStateExists',
                    type: 'any',
                    args: 1,
                    fn: (node) => {
                        this.hasMaybeValue(node, 'app_global_get_ex');
                    },
                },
                {
                    name: 'LocalStateExists',
                    type: 'any',
                    args: 2,
                    fn: (node) => {
                        this.pushLines(node, 'swap', 'cover 2');
                        this.hasMaybeValue(node, 'app_local_get_ex');
                    },
                },
                {
                    name: 'GlobalState',
                    type: 'any',
                    args: 1,
                    fn: (node) => {
                        this.assertMaybeValue(node, 'app_global_get_ex', StackType.any, `global state value does not exist: ${node
                            .getText()
                            .split('\n')
                            .map((l) => l.trim())
                            .join(' ')}`);
                    },
                },
                {
                    name: 'LocalState',
                    type: 'any',
                    args: 2,
                    fn: (node) => {
                        this.pushLines(node, 'swap', 'cover 2');
                        this.assertMaybeValue(node, 'app_local_get_ex', StackType.any, `local state value does not exist: ${node
                            .getText()
                            .split('\n')
                            .map((l) => l.trim())
                            .join(' ')}`);
                    },
                },
            ],
            txn: this.getOpParamObjects('txn'),
            global: this.getOpParamObjects('global'),
            itxn: this.getOpParamObjects('itxn'),
            gtxns: [
                ...this.getOpParamObjects('gtxns'),
                {
                    name: 'LoadScratch',
                    type: 'any',
                    args: 1,
                    fn: (node) => {
                        this.push(node, 'gloadss', StackType.any);
                    },
                },
            ],
            asset: this.getOpParamObjects('asset_params_get'),
            gitxn: this.getOpParamObjects('gitxn'),
            block: this.getOpParamObjects('block'),
        };
        this.programVersion = 10;
        this.templateVars = {};
        this.forEachCount = 0;
        this.forOfCount = 0;
        this.innerTxnHasBegun = false;
        this.compiledPrograms = {};
        this.hasDynamicTemplateVar = false;
        /**
         * The estimated size of the program in bytes
         * This is an estimation because future versions of algod or differen template variable value may change the size
         */
        this.estimatedProgramSize = {};
        this.andCount = 0;
        this.orCount = 0;
        this.nodeDepth = 0;
        this.customProperties = {
            id: {
                check: (node) => this.lastType.kind === 'base' && ['assetid', 'appid'].includes(this.lastType.type),
                fn: (node) => {
                    this.lastType = StackType.uint64;
                },
            },
            zeroIndex: {
                check: (node) => ['AssetID', 'AppID'].includes(node.getExpression().getText()),
                fn: (node) => {
                    this.push(node.getNameNode(), 'int 0', this.getTypeInfo(node.getType()));
                },
            },
            zeroAddress: {
                check: (node) => ['Address', 'Account'].includes(node.getExpression().getText()),
                fn: (node) => {
                    this.push(node.getNameNode(), 'global ZeroAddress', this.getTypeInfo(node.getType()));
                },
            },
            length: {
                check: (node) => {
                    return isBytes(this.lastType) || this.lastType.kind === 'dynamicArray' || this.lastType.kind === 'staticArray';
                },
                fn: (n) => {
                    if (this.lastType.kind === 'staticArray') {
                        this.push(n.getNameNode(), `int ${this.lastType.length}`, StackType.uint64);
                        return;
                    }
                    if (isBytes(this.lastType)) {
                        this.push(n.getNameNode(), 'len', StackType.uint64);
                        return;
                    }
                    if (this.lastType.kind === 'dynamicArray' && this.isDynamicArrayOfStaticType(this.lastType)) {
                        this.pushLines(n.getNameNode(), 'len', `int ${this.getTypeLength(this.lastType.base)}`, '/');
                        this.lastType = StackType.uint64;
                        return;
                    }
                    // Dynamic array of non-static types are still ABI encoded
                    if (this.lastType.kind === 'dynamicArray') {
                        this.pushLines(n.getNameNode(), 'int 0', 'extract_uint16');
                        this.lastType = StackType.uint64;
                        return;
                    }
                    throw Error(`Unsupported length property for type ${typeInfoToABIString(this.lastType)}`);
                },
            },
        };
        this.opcodeImplementations = {
            len: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.Identifier),
                fn: (node) => {
                    const typeArg = node.getTypeArguments()?.[0];
                    const arg = node.getArguments()?.[0];
                    if (typeArg) {
                        if (arg)
                            throw Error('len cannot be called with both a type argument and an argument');
                        const type = this.getTypeInfo(typeArg.getType());
                        if (this.isDynamicType(type))
                            throw Error('len cannot be used with dynamic type as type argument');
                        this.push(node, `int ${this.getTypeLength(type)}`, StackType.uint64);
                        return;
                    }
                    const type = this.getStackTypeFromNode(arg);
                    if (this.isDynamicType(type)) {
                        this.processNode(arg);
                        this.push(node, 'len', StackType.uint64);
                    }
                    else {
                        this.push(node, `int ${this.getTypeLength(type)}`, StackType.uint64);
                    }
                },
            },
            asserts: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.Identifier),
                fn: (node) => {
                    node.getArguments().forEach((a) => {
                        this.processNode(a);
                        this.pushVoid(a, 'assert', `asserts failed: ${node.getText().replace(/\n/g, '\\n')}`);
                    });
                },
            },
            bzero: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.Identifier),
                fn: (node) => {
                    const typeArg = node.getTypeArguments()?.[0];
                    const arg = node.getArguments()[0];
                    if (typeArg && !arg) {
                        const typeInfo = this.getTypeInfo(typeArg.getType());
                        if (this.isDynamicType(typeInfo)) {
                            throw Error('bzero cannot be used with dynamic types');
                        }
                        this.push(node, `byte 0x${'00'.repeat(this.getTypeLength(typeInfo))}`, typeInfo);
                        return;
                    }
                    if (arg && !typeArg) {
                        const staticType = {
                            kind: 'staticArray',
                            base: { kind: 'base', type: 'byte' },
                            length: parseInt(arg.getText(), 10),
                        };
                        const type = this.typeHint && isBytes(this.typeHint) ? this.typeHint : staticType;
                        if (arg.isKind(ts.SyntaxKind.NumericLiteral))
                            this.push(node, `byte 0x${'00'.repeat(parseInt(arg.getText(), 10))}`, type);
                        else {
                            this.processNode(arg);
                            this.push(node, 'bzero', StackType.bytes);
                        }
                        return;
                    }
                    throw Error('bzero cannot be called with both a type argument and an argument');
                },
            },
            addr: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.Identifier),
                fn: (node) => {
                    // TODO: add pseudo op type parsing/assertion to handle this
                    // not currently exported in langspeg.json
                    const args = node.getArguments();
                    if (!args[0].isKind(ts.SyntaxKind.StringLiteral))
                        throw new Error('addr() argument must be a string literal');
                    this.push(args[0], `addr ${args[0].getLiteralText()}`, ForeignType.Address);
                },
            },
            method: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.Identifier),
                fn: (node) => {
                    const args = node.getArguments();
                    if (!args[0].isKind(ts.SyntaxKind.StringLiteral))
                        throw new Error('method() argument must be a string literal');
                    this.push(args[0], `method "${args[0].getLiteralText()}"`, StackType.bytes);
                },
            },
            setbit: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.Identifier),
                fn: (node) => {
                    const args = node.getArguments();
                    this.processNode(args[0]);
                    const inputType = this.lastType;
                    this.processNode(args[1]);
                    this.processNode(args[2]);
                    this.push(node, 'setbit', inputType);
                },
            },
            getbit: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.Identifier),
                fn: (node) => {
                    const args = node.getArguments();
                    this.processNode(args[0]);
                    this.processNode(args[1]);
                    this.push(node, 'getbit', StackType.uint64);
                },
            },
        };
        this.customMethods = {
            ...this.opcodeImplementations,
            // String.subtring
            substring: {
                check: (node) => isBytes(this.lastType),
                fn: (node) => {
                    this.processNode(node.getArguments()[0]);
                    this.processNode(node.getArguments()[1]);
                    this.push(node, 'substring3', StackType.bytes);
                },
            },
            increaseOpcodeBudget: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.Identifier),
                fn: (node) => {
                    this.pushLines(node, 'itxn_begin', 'int appl', 'itxn_field TypeEnum', 'int 0', 'itxn_field Fee', 'byte 0x0a8101 // #pragma version 10; int 1', 'dup', 'itxn_field ApprovalProgram', 'itxn_field ClearStateProgram', 'int DeleteApplication', 'itxn_field OnCompletion', 'itxn_submit');
                },
            },
            // Global methods
            clone: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.Identifier),
                fn: (node) => {
                    this.processNode(node.getArguments()[0]);
                },
            },
            rawBytes: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.Identifier),
                fn: (node) => {
                    if (node.getArguments().length !== 1)
                        throw new Error();
                    this.processNode(node.getArguments()[0]);
                    this.checkEncoding(node.getArguments()[0], this.lastType);
                    this.lastType = StackType.bytes;
                },
            },
            rawByte: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.Identifier),
                fn: (node) => {
                    if (node.getArguments().length !== 1)
                        throw new Error('rawByte must be given a single argument');
                    this.processNode(node.getArguments()[0]);
                    this.checkEncoding(node.getArguments()[0], this.lastType);
                    if (this.getTypeLength(this.lastType) !== 1)
                        throw new Error('rawByte argument must be a single byte');
                    this.lastType = { type: 'byte', kind: 'base' };
                },
            },
            castBytes: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.Identifier),
                fn: (node) => {
                    if (node.getTypeArguments()?.length !== 1)
                        throw Error('castBytes must be given a single type argument');
                    this.processNode(node.getArguments()[0]);
                    const typeArg = node.getTypeArguments()[0];
                    this.lastType = this.getTypeInfo(typeArg.getType());
                    if (!this.disableWarnings)
                        // eslint-disable-next-line no-console
                        console.warn('WARNING: castBytes is UNSAFE and does not validate encoding. Use at your own risk.');
                },
            },
            wideRatio: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.Identifier),
                fn: (node) => {
                    const args = node.getArguments();
                    if (args.length !== 2 ||
                        !args[0].isKind(ts.SyntaxKind.ArrayLiteralExpression) ||
                        !args[1].isKind(ts.SyntaxKind.ArrayLiteralExpression))
                        throw new Error();
                    this.multiplyWideRatioFactors(node, new Array(...args[0].getElements()));
                    this.multiplyWideRatioFactors(node, new Array(...args[1].getElements()));
                    this.pushLines(node, 'divmodw', 'pop', 'pop', 'swap', '!');
                    this.pushVoid(node, 'assert', 'wideRatio failed');
                    this.lastType = StackType.uint64;
                },
            },
            hex: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.Identifier),
                fn: (node) => {
                    const args = node.getArguments();
                    if (args.length !== 1)
                        throw new Error();
                    const arg0Type = args[0].getType();
                    if (!arg0Type.isStringLiteral())
                        throw new Error('Hex argument must be string literal');
                    this.push(args[0], `byte 0x${arg0Type.getLiteralValueOrThrow().toString().replace(/^0x/, '')}`, StackType.bytes);
                },
            },
            btobigint: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.Identifier),
                fn: (node) => {
                    this.processNode(node.getArguments()[0]);
                    this.lastType = { kind: 'base', type: 'bigint' };
                },
            },
            verifyTxn: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.Identifier),
                fn: (node) => this.verifyTxn(node),
            },
            verifyPayTxn: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.Identifier),
                fn: (node) => this.verifyTxn(node, TransactionType.PaymentTx),
            },
            verifyAppCallTxn: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.Identifier),
                fn: (node) => this.verifyTxn(node, TransactionType.ApplicationCallTx),
            },
            verifyAssetTransferTxn: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.Identifier),
                fn: (node) => this.verifyTxn(node, TransactionType.AssetTransferTx),
            },
            verifyAssetConfigTxn: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.Identifier),
                fn: (node) => this.verifyTxn(node, TransactionType.AssetConfigTx),
            },
            verifyKeyRegTxn: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.Identifier),
                fn: (node) => this.verifyTxn(node, TransactionType.KeyRegistrationTx),
            },
            // Array methods
            push: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.PropertyAccessExpression) &&
                    isArrayType(this.getStackTypeFromNode(node.getExpression().getExpression())),
                fn: (node) => {
                    const expr = node.getExpression();
                    if (!expr.isKind(ts.SyntaxKind.PropertyAccessExpression))
                        throw Error();
                    if (this.lastType.kind !== 'dynamicArray')
                        throw new Error('Can only push to dynamic array');
                    if (!this.isDynamicArrayOfStaticType(this.lastType))
                        throw new Error('Cannot push to dynamic array of dynamic types');
                    this.processNode(node.getArguments()[0]);
                    this.checkEncoding(node.getArguments()[0], this.lastType);
                    this.pushVoid(node, 'concat');
                    this.updateValue(expr.getExpression());
                },
            },
            pop: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.PropertyAccessExpression) &&
                    isArrayType(this.getStackTypeFromNode(node.getExpression().getExpression())),
                fn: (node) => {
                    if (!node.getExpression().isKind(ts.SyntaxKind.PropertyAccessExpression))
                        throw Error();
                    if (this.lastType.kind !== 'dynamicArray')
                        throw new Error('Can only pop from dynamic array');
                    if (this.isDynamicType(this.lastType.base))
                        throw new Error('Cannot pop from dynamic array of dynamic types');
                    const poppedType = this.lastType.base;
                    const typeLength = this.getTypeLength(this.lastType.base);
                    this.pushLines(node.getExpression(), 'dup', 'len', `int ${typeLength}`, '-', 'int 0', 'swap', 'extract3');
                    // only get the popped element if we're expecting a return value
                    if (this.topLevelNode !== node) {
                        this.pushLines(node.getExpression(), 'dup', 'len', `int ${typeLength}`);
                        this.processNode(node.getExpression().getExpression());
                        this.pushLines(node.getExpression(), 'cover 2', 'extract3', 'swap');
                    }
                    this.updateValue(node.getExpression().getExpression());
                    if (this.topLevelNode !== node)
                        this.checkDecoding(node, poppedType);
                    this.lastType = poppedType;
                },
            },
            splice: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.PropertyAccessExpression) &&
                    isArrayType(this.getStackTypeFromNode(node.getExpression().getExpression())),
                fn: (node) => {
                    if (!node.getExpression().isKind(ts.SyntaxKind.PropertyAccessExpression))
                        throw Error();
                    if (this.lastType.kind !== 'dynamicArray') {
                        throw new Error(`Can only splice dynamic array (got ${this.lastType})`);
                    }
                    if (!this.isDynamicArrayOfStaticType(this.lastType)) {
                        throw new Error('Cannot splice a dynamic array of dynamic types');
                    }
                    const elementType = this.lastType.base;
                    // `int ${parseInt(node.getArguments()[1].getText(), 10)}`
                    this.processNode(node.getArguments()[1]);
                    // TODO: Optimize for literals
                    // const spliceIndex = parseInt(node.getArguments()[0].getText(), 10);
                    // const spliceStart = spliceIndex * this.getTypeLength(elementType);
                    this.processNode(node.getArguments()[0]);
                    this.pushLines(node, `int ${this.getTypeLength(elementType)}`, '*', `store ${compilerScratch.spliceStart}`);
                    // const spliceElementLength = parseInt(node.getArguments()[1].getText(), 10);
                    // const spliceByteLength = (spliceElementLength + 1) * this.getTypeLength(elementType);
                    this.processNode(node.getArguments()[1]);
                    this.pushLines(node, `int ${this.getTypeLength(elementType)}`, '*', `int ${this.getTypeLength(elementType)}`, '+', `store ${compilerScratch.spliceByteLength}`);
                    // extract first part
                    this.processNode(node.getExpression().getExpression());
                    this.pushLines(node, 'int 0', `load ${compilerScratch.spliceStart}`, 'substring3');
                    // extract second part
                    this.processNode(node.getExpression().getExpression());
                    this.pushLines(node, 
                    // get end
                    'dup', 'len', 
                    // get start (end of splice)
                    `load ${compilerScratch.spliceStart}`, `load ${compilerScratch.spliceByteLength}`, '+', `int ${this.getTypeLength(elementType)}`, '-', 'swap', 
                    // extract second part
                    'substring3', 
                    // concat everything
                    'concat');
                    if (this.topLevelNode !== node) {
                        // this.pushLines(`byte 0x${spliceElementLength.toString(16).padStart(4, '0')}`);
                        this.processNode(node.getExpression().getExpression());
                        this.pushLines(node, `load ${compilerScratch.spliceStart}`, 
                        // `int ${spliceByteLength - this.getTypeLength(elementType)}`,
                        `load ${compilerScratch.spliceByteLength}`, `int ${this.getTypeLength(elementType)}`, '-', 'extract3', 'swap');
                    }
                    this.updateValue(node.getExpression().getExpression());
                    this.lastType = { kind: 'dynamicArray', base: elementType };
                },
            },
            forEach: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.PropertyAccessExpression) &&
                    isArrayType(this.getStackTypeFromNode(node.getExpression().getExpression())),
                fn: (node) => {
                    this.addSourceComment(node.getExpression(), true);
                    const fn = node.getArguments()[0];
                    if (!fn.isKind(ts.SyntaxKind.ArrowFunction))
                        throw Error();
                    const params = fn.getChildrenOfKind(ts.SyntaxKind.SyntaxList)[0].getChildrenOfKind(ts.SyntaxKind.Parameter);
                    if (params.length !== 1)
                        throw Error('forEach function must have exactly one parameter in TEALScript');
                    const paramName = params[0].getName();
                    const expr = node.getExpression().getExpression();
                    this.forIterator(node, expr, fn.getChildrenOfKind(ts.SyntaxKind.Block)[0], paramName, 'forEach');
                },
            },
            // Address methods
            fromBytes: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.PropertyAccessExpression) &&
                    node.getExpression().getExpression().getText() === 'Address',
                fn: (node) => {
                    if (!node.getExpression().isKind(ts.SyntaxKind.PropertyAccessExpression))
                        throw Error();
                    this.processNode(node.getArguments()[0]);
                    this.lastType = ForeignType.Address;
                },
            },
            fromAddress: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.PropertyAccessExpression) &&
                    node.getExpression().getExpression().getText() === 'Address',
                fn: (node) => {
                    if (!node.getExpression().isKind(ts.SyntaxKind.PropertyAccessExpression))
                        throw Error();
                    const type = node.getArguments()[0].getType();
                    if (!type.isStringLiteral())
                        throw Error('fromAddress must be called with a string literal');
                    this.push(node, `addr ${type.getLiteralValueOrThrow()}`, ForeignType.Address);
                },
            },
            // Asset / Application fromUint64
            fromUint64: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.PropertyAccessExpression) &&
                    (node.getExpression().getExpression().getText() === 'AssetID' ||
                        node.getExpression().getExpression().getText() === 'AppID'),
                fn: (node) => {
                    if (!node.getExpression().isKind(ts.SyntaxKind.PropertyAccessExpression))
                        throw Error();
                    this.processNode(node.getArguments()[0]);
                    this.lastType = this.getTypeInfo(node.getExpression().getExpression().getType());
                },
            },
            // number methods
            Uint: {
                check: (node) => node.getExpression().isKind(ts.SyntaxKind.Identifier),
                fn: (node) => {
                    const args = node.getArguments();
                    if (args.length !== 1)
                        throw new Error();
                    const arg0Type = args[0].getType();
                    if (!arg0Type.isStringLiteral())
                        throw new Error('Uint argument must be string literal');
                    const widthArg = node.getTypeArguments()?.[0];
                    if (widthArg === undefined) {
                        throw Error('Uint must have a type argument specifying the width');
                    }
                    const width = parseInt(widthArg.getText(), 10);
                    const typeInfo = { kind: 'base', type: `uint${width}` };
                    const value = BigInt(arg0Type.getLiteralValueOrThrow());
                    const maxValue = 2n ** BigInt(width) - 1n;
                    if (value > maxValue) {
                        throw Error(`Value ${value} is too large for uint${width}. Max value is ${maxValue}`);
                    }
                    if (width === 64 || isSmallNumber(typeInfo))
                        this.push(node, `int ${value}`, typeInfo);
                    else
                        this.push(node, `byte 0x${value.toString(16).padStart(width / 4, '0')}`, typeInfo);
                },
            },
            toString: {
                check: (node) => {
                    return this.lastType.kind === 'base' && !!this.lastType.type.match(/uint\d+$/);
                },
                fn: (node) => {
                    if (this.lastType.kind !== 'base')
                        throw Error();
                    if (!equalTypes(this.lastType, StackType.uint64)) {
                        const width = parseInt(this.lastType.type.match(/\d+/)[0], 10);
                        if (width > 64)
                            throw Error('toString is only supported for uint64 and smaller');
                        this.pushVoid(node, 'btoi');
                    }
                    this.pushVoid(node, 'callsub *itoa');
                    this.lastType = StackType.bytes;
                },
            },
        };
        this.events = {};
        this.compilerSubroutines = {
            '*itoa': () => [
                '*intToAscii:',
                'proto 1 1',
                'byte 0x30313233343536373839 // "0123456789"',
                'frame_dig -1 // i: uint64',
                'int 1',
                'extract3',
                'retsub',
                '',
                '*itoa:',
                'proto 1 1',
                'frame_dig -1 // i: uint64',
                'int 0',
                '==',
                'bz *itoa_if_end',
                'byte 0x30',
                'retsub',
                '*itoa_if_end:',
                'frame_dig -1 // i: uint64',
                'int 10',
                '/',
                'int 0',
                '>',
                'bz *itoa_ternary_false',
                'frame_dig -1 // i: uint64',
                'int 10',
                '/',
                'callsub *itoa',
                'b *itoa_ternary_end',
                '*itoa_ternary_false:',
                'byte 0x // ""',
                '*itoa_ternary_end:',
                'frame_dig -1 // i: uint64',
                'int 10',
                '%',
                'callsub *intToAscii',
                'concat',
                'retsub',
            ],
            '*process_static_tuple_element': () => {
                const tupleHead = '-4 // tuple head';
                const tupleTail = '-3 // tuple tail';
                const headOffset = '-2 // head offset';
                const element = '-1 // element';
                return [
                    '*process_static_tuple_element:',
                    'proto 4 3',
                    `frame_dig ${tupleHead}`,
                    `frame_dig ${element}`,
                    'concat',
                    `frame_dig ${tupleTail}`,
                    `frame_dig ${headOffset}`,
                    'retsub',
                ];
            },
            '*process_dynamic_tuple_element': () => {
                const tupleHead = '-4 // tuple head';
                const tupleTail = '-3 // tuple tail';
                const headOffset = '-2 // head offset';
                const element = '-1 // element';
                return [
                    '*process_dynamic_tuple_element:',
                    'proto 4 3',
                    `frame_dig ${tupleHead}`,
                    `frame_dig ${headOffset}`,
                    'concat',
                    `frame_bury ${tupleHead}`,
                    `frame_dig ${element}`,
                    'dup',
                    'len',
                    `frame_dig ${headOffset}`,
                    'btoi',
                    '+',
                    'itob',
                    'extract 6 2',
                    `frame_bury ${headOffset}`,
                    `frame_dig ${tupleTail}`,
                    'swap',
                    'concat',
                    `frame_bury ${tupleTail}`,
                    `frame_dig ${tupleHead}`,
                    `frame_dig ${tupleTail}`,
                    `frame_dig ${headOffset}`,
                    'retsub',
                ];
            },
            // -2: length difference
            // -1: offset
            '*update_dynamic_head': () => [
                '*update_dynamic_head:',
                'proto 2 0',
                'frame_dig -2 // length difference',
                `load ${compilerScratch.fullArray}`,
                'frame_dig -1 // dynamic array offset',
                'extract_uint16 // extract dynamic array offset',
                `load ${compilerScratch.subtractHeadDifference}`,
                'bz *subtract_head_difference',
                '+ // add difference to offset',
                'b *end_calc_new_head',
                '*subtract_head_difference:',
                'swap',
                '- // subtract difference from offet',
                '*end_calc_new_head:',
                'itob // convert to bytes',
                'extract 6 2 // convert to uint16',
                `load ${compilerScratch.fullArray}`,
                'swap',
                'frame_dig -1 // offset',
                'swap',
                'replace3 // update offset',
                `store ${compilerScratch.fullArray}`,
                'retsub',
            ],
            '*get_length_difference': () => [
                '*get_length_difference:',
                // Get new element length
                `load ${compilerScratch.newElement}`,
                'len // length of new element',
                `load ${compilerScratch.elementLength}`,
                '<',
                'bnz *swapped_difference',
                `load ${compilerScratch.newElement}`,
                'len // length of new element',
                `load ${compilerScratch.elementLength}`,
                'int 1',
                `store ${compilerScratch.subtractHeadDifference}`,
                'b *get_difference',
                '*swapped_difference:',
                `load ${compilerScratch.elementLength}`,
                `load ${compilerScratch.newElement}`,
                'len // length of new element',
                'int 0',
                `store ${compilerScratch.subtractHeadDifference}`,
                '*get_difference:',
                '- // get length difference',
                `store ${compilerScratch.lengthDifference}`,
                'retsub',
            ],
        };
        this.mathType = '';
        this.opcodeAliases = {
            extractUint16: 'extract_uint16',
            extractUint32: 'extract_uint32',
            extractUint64: 'extract_uint64',
            ed25519VerifyBare: 'ed25519verify_bare',
            ed25519Verify: 'ed25519verify',
            vrfVefiry: 'vrf_verify',
            ecScalarMul: 'ec_scalar_mul',
            ecPairingCheck: 'ec_pairing_check',
            ecMultiScalarMul: 'ec_multi_scalar_mul',
            ecSubgroupCheck: 'ec_subgroup_check',
            ecMapTo: 'ec_map_to',
            ecAdd: 'ec_add',
            base64Decode: 'base64_decode',
            jsonRef: 'json_ref',
            ecdsaVerify: 'ecdsa_verify',
            ecdsaPkDecompress: 'ecdsa_pk_decompress',
            ecdsaPkRecover: 'ecdsa_pk_recover',
            onlineStake: 'online_stake',
        };
        this.project = options.project;
        this.disableWarnings = options.disableWarnings || false;
        this.algodServer = options.algodServer || 'http://localhost';
        this.algodPort = options.algodPort || 4001;
        this.algodToken = options.algodToken || 'a'.repeat(64);
        this.srcPath = options.srcPath;
        this.disableOverflowChecks = options.disableOverflowChecks || false;
        this.disableTypeScript = options.disableTypeScript || false;
        this.skipAlgod = options.skipAlgod || false;
        this.libDir = path_1.default.normalize(options.tealscriptLibDir || __dirname);
        this.typesDir = path_1.default.normalize(options.tealscriptTypesDir || path_1.default.join(__dirname, '..', '..', 'types'));
        this.cwd = options.cwd;
        this.name = options.className;
        this.sourceFile = this.project.getSourceFile(this.srcPath);
    }
    static compileAll(options) {
        const compilers = options.project
            .getSourceFile(options.srcPath)
            .getStatements()
            .filter((body) => body.isKind(ts.SyntaxKind.ClassDeclaration))
            .map(async (body) => {
            if (!body.isKind(ts.SyntaxKind.ClassDeclaration))
                throw Error();
            const name = body.getNameNode().getText();
            const compiler = new Compiler({ ...options, className: name });
            await compiler.compile();
            if (!options.skipAlgod)
                await compiler.algodCompile();
            return compiler;
        });
        return compilers;
    }
    getOpParamObjects(op) {
        const opSpec = langspec_json_1.default.Ops.find((o) => o.Name === op);
        if (opSpec === undefined) {
            throw new Error(`Unknown op ${op}`);
        }
        return opSpec.ArgEnum.map((arg, i) => {
            let fn;
            const type = PARAM_TYPES[arg] || opSpec.ArgEnumTypes[i].replace(/\[\d*\]byte/, 'bytes');
            const typeInfo = { kind: 'base', type };
            if (['txn', 'global', 'itxn', 'gtxns', 'gitxn', 'block'].includes(op)) {
                fn = (node) => this.push(node, `${op} ${arg}`, typeInfo);
            }
            else {
                fn = (node) => this.popMaybeValue(node, `${op} ${arg}`, typeInfo);
            }
            return {
                name: arg,
                args: opSpec.Args?.length || 0,
                fn,
            };
        });
    }
    isDynamicType(type) {
        if (type.kind === 'dynamicArray')
            return true;
        if (type.kind === 'tuple') {
            return type.elements.map((e) => this.isDynamicType(e)).includes(true);
        }
        if (type.kind === 'staticArray') {
            return this.isDynamicType(type.base);
        }
        if (type.kind === 'object') {
            return Object.values(type.properties)
                .map((p) => this.isDynamicType(p))
                .includes(true);
        }
        if (type.kind === 'base') {
            return type.type === 'bytes' || type.type === 'string' || type.type === 'byte[]';
        }
        throw Error();
    }
    getTypeLength(inputType) {
        if (inputType.kind === 'staticArray') {
            if (equalTypes(inputType.base, { kind: 'base', type: 'bool' })) {
                return Math.ceil(inputType.length / 8);
            }
            return inputType.length * this.getTypeLength(inputType.base);
        }
        if (inputType.kind === 'tuple') {
            let totalLength = 0;
            let consecutiveBools = 0;
            inputType.elements.forEach((e) => {
                if (equalTypes(e, { kind: 'base', type: 'bool' })) {
                    consecutiveBools += 1;
                }
                else {
                    if (consecutiveBools > 0) {
                        totalLength += Math.ceil(consecutiveBools / 8);
                    }
                    totalLength += this.getTypeLength(e);
                    consecutiveBools = 0;
                }
            });
            // If the last element is a bool, make sure to add the length
            if (consecutiveBools > 0) {
                totalLength += Math.ceil(consecutiveBools / 8);
            }
            return totalLength;
        }
        if (inputType.kind === 'object') {
            let totalLength = 0;
            let consecutiveBools = 0;
            Object.values(inputType.properties).forEach((e) => {
                if (equalTypes(e, { kind: 'base', type: 'bool' })) {
                    consecutiveBools += 1;
                }
                else {
                    if (consecutiveBools > 0) {
                        totalLength += Math.ceil(consecutiveBools / 8);
                    }
                    totalLength += this.getTypeLength(e);
                    consecutiveBools = 0;
                }
            });
            return totalLength;
        }
        if (inputType.kind === 'base') {
            const { type } = inputType;
            if (MULTI_OUTPUT_TYPES.includes(type)) {
                // TODO: Link to docs
                throw Error('You cannot directly use a multi-output opcode in an array. You must fist assign the output to a variable.');
            }
            if (inputType.type.startsWith('uint') || inputType.type.startsWith('ufixed')) {
                return parseInt(type.match(/\d+/)[0], 10) / 8;
            }
            switch (type) {
                case 'bool':
                    return 1;
                case 'assetid':
                case 'appid':
                    return 8;
                case 'byte':
                case 'string':
                case 'bytes':
                    return 1;
                case 'address':
                case 'account':
                    return 32;
                default:
                    throw new Error(`Unknown type ${JSON.stringify(type, null, 2)}`);
            }
        }
        throw Error(`Cannot determine length for dynamic array. If you are seeing this, file an issue on GitHub`);
    }
    getClassInfo(node) {
        const classDeclarationNodes = [];
        node.getDefinitionNodes().forEach((d) => {
            if (d.isKind(ts.SyntaxKind.ClassDeclaration))
                classDeclarationNodes.push(d);
        });
        if (classDeclarationNodes.length === 0)
            return undefined;
        if (classDeclarationNodes.length > 1) {
            throw Error(`Multiple class declarations found for ${node.getText()}. Please report this error on GitHub https://github.com/algorandfoundation/tealscript`);
        }
        const declaration = classDeclarationNodes[0];
        const sourcePath = path_1.default.normalize(declaration?.getSourceFile().getFilePath() ?? '');
        if (sourcePath.startsWith(this.typesDir) || sourcePath.startsWith(this.libDir)) {
            if (declaration.getName() === CONTRACT_CLASS) {
                return {
                    declaration,
                    type: 'contract',
                };
            }
            if (declaration.getName() === LSIG_CLASS) {
                return {
                    declaration,
                    type: 'lsig',
                };
            }
            return {
                declaration,
                type: 'core',
            };
        }
        const superClass = declaration.getHeritageClauses()[0].getTypeNodes()[0].getExpression();
        if (superClass.getText() === CONTRACT_CLASS ||
            (superClass.isKind(ts.SyntaxKind.Identifier) && this.getClassInfo(superClass)?.type === 'contract') ||
            superClass.getText().startsWith(`${CONTRACT_CLASS}.extend(`)) {
            return {
                declaration,
                type: 'contract',
            };
        }
        if (superClass.getText() === LSIG_CLASS ||
            (superClass.isKind(ts.SyntaxKind.Identifier) && this.getClassInfo(superClass)?.type === 'lsig') ||
            superClass.getText().startsWith(`${LSIG_CLASS}.extend(`)) {
            return {
                declaration,
                type: 'lsig',
            };
        }
        return {
            declaration,
            type: 'core',
        };
    }
    async postProcessTeal(input) {
        const compilerOptions = {
            algodPort: this.algodPort,
            algodServer: this.algodServer,
            algodToken: this.algodToken,
            disableWarnings: this.disableWarnings,
            disableOverflowChecks: this.disableOverflowChecks,
            disableTypeScript: this.disableTypeScript,
            project: this.project,
            cwd: this.cwd,
            skipAlgod: this.skipAlgod,
        };
        return (await Promise.all(input.map(async (t) => {
            const tealLine = t.teal;
            if (tealLine.startsWith('#pragma')) {
                return { teal: `#pragma version ${this.programVersion}`, node: t.node };
            }
            if (tealLine.startsWith('PENDING_SCHEMA')) {
                const className = tealLine.split(' ')[1];
                const classNode = t.node.getDescendantsOfKind(ts.SyntaxKind.Identifier)[0];
                const { declaration } = this.getClassInfo(classNode);
                const srcPath = declaration.getSourceFile()?.getFilePath() || this.srcPath;
                const c = new Compiler({ ...compilerOptions, srcPath, className });
                await c.compile();
                if (tealLine.startsWith('PENDING_SCHEMA_GLOBAL_INT')) {
                    return { teal: `int ${c.arc32Description().state.global.num_uints}`, node: t.node };
                }
                if (tealLine.startsWith('PENDING_SCHEMA_GLOBAL_BYTES')) {
                    return { teal: `int ${c.arc32Description().state.global.num_byte_slices}`, node: t.node };
                }
                if (tealLine.startsWith('PENDING_SCHEMA_LOCAL_INT')) {
                    return { teal: `int ${c.arc32Description().state.local.num_uints}`, node: t.node };
                }
                if (tealLine.startsWith('PENDING_SCHEMA_LOCAL_BYTES')) {
                    return { teal: `int ${c.arc32Description().state.local.num_byte_slices}`, node: t.node };
                }
            }
            if (tealLine.startsWith('PENDING_COMPILE') && !compilerOptions.skipAlgod) {
                const className = tealLine.split(' ')[1];
                const classNode = t.node.getDescendantsOfKind(ts.SyntaxKind.Identifier)[0];
                const { declaration } = this.getClassInfo(classNode);
                const srcPath = declaration.getSourceFile()?.getFilePath() || this.srcPath;
                const c = new Compiler({ ...compilerOptions, srcPath, className });
                await c.compile();
                if (tealLine.split(':')[0].endsWith('ADDR')) {
                    const compiledProgram = await c.algodCompileProgram('lsig');
                    return { teal: `addr ${compiledProgram.hash}`, node: t.node };
                }
                const target = tealLine.split(':')[0].split('_').at(-1).toLowerCase();
                const compiledProgram = await c.algodCompileProgram(target);
                // decode result from base64 to hex
                const hexResult = Buffer.from(compiledProgram.result, 'base64').toString('hex');
                return { teal: `byte 0x${hexResult}`, node: t.node };
            }
            const method = tealLine.split(' ')[1];
            const subroutine = this.subroutines.find((s) => s.name === method);
            if (tealLine.startsWith('PENDING_PROTO')) {
                if (subroutine === undefined)
                    throw new Error(`Subroutine ${method} not found`);
                const newLines = [];
                newLines.push(`proto ${subroutine.args.length} ${equalTypes(subroutine.returns.type, StackType.void) ? 0 : 1}`);
                if (this.frameSize[method])
                    newLines.push('// Push empty bytes after the frame pointer to reserve space for local variables', 'byte 0x');
                if (this.frameSize[method] > 1)
                    newLines.push(`dupn ${this.frameSize[method] - 1}`);
                return newLines.map((l) => {
                    return { node: t.node, teal: l };
                });
            }
            const { errorMessage } = t;
            return { node: t.node, teal: tealLine, errorMessage };
        }))).flat();
    }
    getTypeScriptDiagnostics() {
        Compiler.diagsRan.push(this.srcPath);
        const sourceFile = this.project.getSourceFile(this.srcPath);
        const diags = sourceFile.getPreEmitDiagnostics();
        if (diags.length > 0) {
            throw Error(`TypeScript diagnostics failed\n${this.project.formatDiagnosticsWithColorAndContext(diags)}`);
        }
    }
    /**
     * Process the signatures of all of the subroutines so that they can be called in any order
     *
     * @param methods The methods to process
     */
    preProcessMethods(methods) {
        methods.forEach((node) => {
            if (!node.getNameNode()?.isKind(ts.SyntaxKind.Identifier))
                throw Error('Method name must be identifier');
            const name = node.getNameNode().getText();
            const typeNode = node.getReturnType();
            if (typeNode === undefined)
                throw Error(`A return type annotation must be defined for ${name}`);
            const returnType = node.getReturnTypeNode()?.getType()
                ? this.getTypeInfo(node.getReturnTypeNode().getType())
                : StackType.void;
            const sub = {
                name,
                allows: { call: [], create: [] },
                nonAbi: { call: [], create: [] },
                args: [],
                desc: '',
                returns: { type: returnType, desc: '' },
                node,
                events: [],
            };
            new Array(...node.getParameters()).reverse().forEach((p) => {
                let type = this.getTypeInfo(p.getType());
                if (p.getTypeNode()?.getText() === 'Account') {
                    type = { kind: 'base', type: 'account' };
                }
                sub.args.push({
                    name: p.getNameNode().getText(),
                    type,
                    desc: '',
                });
            });
            this.subroutines.push(sub);
        });
    }
    /**
     * Gets the class child nodes for a superclass
     */
    getSuperClassNodes(superClassNode, methodNodes, propertyNodes) {
        const options = {
            algodPort: this.algodPort,
            algodServer: this.algodServer,
            algodToken: this.algodToken,
            disableWarnings: this.disableWarnings,
            disableOverflowChecks: this.disableOverflowChecks,
            disableTypeScript: this.disableTypeScript,
            project: this.project,
            cwd: this.cwd,
        };
        const symbol = superClassNode.getSymbol()?.getAliasedSymbol() || superClassNode.getSymbol();
        const srcPath = symbol.getDeclarations().at(-1).getSourceFile().getFilePath();
        const superCompiler = new Compiler({ ...options, srcPath, className: symbol.getName() });
        const superClassNodes = superCompiler.getClassChildren();
        methodNodes.push(...superClassNodes.methodNodes);
        propertyNodes.push(...superClassNodes.propertyNodes);
    }
    /**
     * Get the child nodes of the contract class
     */
    getClassChildren() {
        const classNode = this.sourceFile.getStatements().find((body) => {
            if (!body.isKind(ts.SyntaxKind.ClassDeclaration))
                return false;
            if (body.getName() === this.name)
                return true;
            return false;
        });
        if (classNode === undefined)
            throw Error(`Class ${this.name} not found`);
        const heritageClauses = classNode.getHeritageClauses();
        if (heritageClauses === undefined) {
            throw Error(`Contract ${this.name} must extend Contract, LogicSig, a subclass of either, or .extend() of either`);
        }
        const methodNodes = [];
        const propertyNodes = [];
        const superClassNode = heritageClauses[0].getTypeNodes()[0].getExpression();
        if (superClassNode.isKind(ts.SyntaxKind.CallExpression)) {
            const superExpr = superClassNode.getExpression();
            if (!superExpr.isKind(ts.SyntaxKind.PropertyAccessExpression))
                throw Error();
            if ([CONTRACT_CLASS, LSIG_CLASS].includes(superExpr.getName()))
                throw Error();
            superClassNode.getArguments().forEach((a) => {
                this.getSuperClassNodes(a, methodNodes, propertyNodes);
            });
        }
        else if (superClassNode.isKind(ts.SyntaxKind.Identifier)) {
            const superClass = superClassNode.getText();
            if (![CONTRACT_CLASS, LSIG_CLASS].includes(superClass)) {
                this.getSuperClassNodes(superClassNode, methodNodes, propertyNodes);
            }
        }
        classNode.forEachChild((c) => {
            if (c.isKind(ts.SyntaxKind.MethodDeclaration))
                methodNodes.push(c);
            if (c.isKind(ts.SyntaxKind.PropertyDeclaration))
                propertyNodes.push(c);
        });
        const uniqueNodes = (n, i, arr) => {
            return arr.indexOf(n) === i;
        };
        return { methodNodes: methodNodes.filter(uniqueNodes), propertyNodes: propertyNodes.filter(uniqueNodes) };
    }
    initializeTEAL(node) {
        this.pushLines(node, '#pragma version PROGAM_VERSION');
        if (this.currentProgram === 'lsig') {
            this.pushLines(node, '//#pragma mode logicsig');
        }
        this.pushLines(node, '', `// This TEAL was generated by TEALScript v${version_1.VERSION}`, '// https://github.com/algorandfoundation/TEALScript', '');
        if (this.currentProgram === 'approval') {
            const createLabels = '*create_NoOp *create_OptIn *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_DeleteApplication ';
            const callLabels = '*call_NoOp *call_OptIn *call_CloseOut *NOT_IMPLEMENTED *call_UpdateApplication *call_DeleteApplication';
            this.pushLines(node, '// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]', '', '// The following ten lines of TEAL handle initial program flow', '// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed', '// Here, action refers to the OnComplete in combination with whether the app is being created or called', '// Every possible action for this contract is represented in the switch statement', '// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"', 'txn ApplicationID', '!', 'int 6', '*', 'txn OnCompletion', '+', `switch ${callLabels} ${createLabels}`, '*NOT_IMPLEMENTED:');
            this.pushVoid(node, 'err', 'The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?');
            this.teal.clear.push({ node, teal: '#pragma version PROGAM_VERSION' });
        }
        else if (this.currentProgram === 'lsig') {
            this.pushLines(node, '// The address of this logic signature is', '', 'b *route_logic');
        }
    }
    async compile() {
        const sourceFile = this.project.getSourceFile(this.srcPath);
        const importedFiles = sourceFile?.getImportDeclarations().map((d) => d.getModuleSpecifierSourceFile()) || [];
        // Go over all the files we are importing and check for number keywords
        [sourceFile, ...importedFiles].forEach((f) => {
            f?.getStatements().forEach((s) => {
                const numberKeywords = s.getDescendantsOfKind(ts.SyntaxKind.NumberKeyword);
                if (numberKeywords.length > 0) {
                    const node = numberKeywords[0];
                    const loc = ts.ts.getLineAndCharacterOfPosition(node.getSourceFile().compilerNode, node.getStart());
                    const errPath = path_1.default.relative(this.cwd, node.getSourceFile().getFilePath());
                    const msg = `number keyword not allowed at ${errPath}:${loc.line + 1}:${loc.character}. Use uint64 instead.`;
                    throw Error(msg);
                }
            });
        });
        if (!Compiler.diagsRan.includes(this.srcPath) && !this.disableTypeScript) {
            this.getTypeScriptDiagnostics();
        }
        this.sourceFile.getStatements().forEach((body) => {
            const errNode = body;
            const loc = ts.ts.getLineAndCharacterOfPosition(errNode.getSourceFile().compilerNode, errNode.getStart());
            const lines = [];
            const errPath = path_1.default.relative(this.cwd, errNode.getSourceFile().getFilePath());
            errNode
                .getText()
                .split('\n')
                .forEach((l, i) => {
                lines.push(`${errPath}:${loc.line + i + 1}: ${l}`);
            });
            const msg = `${errNode.getKindName()} at ${errPath}:${loc.line}:${loc.character}\n    ${lines.join('\n    ')}\n`;
            if (body.isKind(ts.SyntaxKind.VariableStatement) &&
                body.getDeclarationKind() !== ts.VariableDeclarationKind.Const) {
                throw new Error(`Top-level variables must be constants\n${msg}`);
            }
        });
        const { methodNodes, propertyNodes } = this.getClassChildren();
        this.preProcessMethods(methodNodes);
        propertyNodes.forEach((n) => this.processPropertyDefinition(n));
        this.sourceFile.getStatements().forEach((body) => {
            if (!body.isKind(ts.SyntaxKind.ClassDeclaration))
                return;
            this.lastNode = body;
            const superClass = body.getHeritageClauses()[0].getTypeNodes()[0].getExpression();
            if ([CONTRACT_CLASS, LSIG_CLASS].includes(superClass.getText()) ||
                (superClass.isKind(ts.SyntaxKind.Identifier) && this.getClassInfo(superClass)?.type === 'contract') ||
                (superClass.isKind(ts.SyntaxKind.Identifier) && this.getClassInfo(superClass)?.type === 'lsig') ||
                superClass.getText().startsWith(`${CONTRACT_CLASS}.extend(`) ||
                superClass.getText().startsWith(`${LSIG_CLASS}.extend(`)) {
                const className = body.getName();
                if (className === this.name) {
                    if (superClass.getText() === LSIG_CLASS)
                        this.currentProgram = 'lsig';
                    this.classNode = body;
                    this.initializeTEAL(body);
                    this.abi = {
                        name: className,
                        desc: '',
                        methods: [],
                    };
                    methodNodes.forEach((node) => this.processNode(node));
                }
            }
        });
        if (this.currentProgram !== 'lsig' &&
            this.subroutines.map((a) => a.allows.create).flat().length === 0 &&
            !Object.values(this.bareCallConfig)
                .map((c) => c.action)
                .includes('CREATE')) {
            const name = 'createApplication';
            const m = {
                name,
                desc: 'The default create method generated by TEALScript',
                returns: { type: StackType.void, desc: '' },
                args: [],
                events: [],
            };
            this.subroutines.push({
                ...m,
                allows: { create: ['NoOp'], call: [] },
                nonAbi: {
                    create: [],
                    call: [],
                },
                node: this.classNode,
            });
            this.abi.methods.push(m);
            this.pushLines(this.classNode, `*abi_route_${name}:`, 'int 1', 'return');
        }
        if (this.currentProgram !== 'lsig')
            this.routeAbiMethods();
        while (this.pendingSubroutines.length > 0) {
            this.processSubroutine(this.pendingSubroutines.pop());
        }
        Object.keys(this.compilerSubroutines).forEach((sub) => {
            if (this.teal[this.currentProgram].map((t) => t.teal).includes(`callsub ${sub}`)) {
                this.pushLines(this.classNode, ...this.compilerSubroutines[sub]());
            }
        });
        this.teal[this.currentProgram] = await this.postProcessTeal(this.teal[this.currentProgram]);
        this.teal[this.currentProgram] = (0, optimize_1.optimizeTeal)(this.teal[this.currentProgram]);
        this.teal[this.currentProgram] = this.prettyTeal(this.teal[this.currentProgram]);
        this.teal[this.currentProgram].forEach((t, i) => {
            if (t.teal.length === 0 || t.teal.trim().startsWith('//') || t.teal.trim().split(' ')[0].endsWith(':'))
                return;
            const relativePath = path_1.default.relative(this.cwd, t.node.getSourceFile().getFilePath());
            const line = ts.ts.getLineAndCharacterOfPosition(t.node.getSourceFile().compilerNode, t.node.getStart()).line + 1;
            this.sourceInfo.push({
                teal: i + 1,
                source: `${relativePath}:${line}`,
                errorMessage: t.errorMessage,
            });
        });
        let hasNonAbi = false;
        this.subroutines.forEach((sub) => {
            if (sub.nonAbi.call.length + sub.nonAbi.create.length > 0) {
                hasNonAbi = true;
            }
        });
        if (hasNonAbi) {
            const i = this.teal[this.currentProgram].map((t) => t.teal).findIndex((t) => t.includes('[ ARC4 ]'));
            this.teal[this.currentProgram][i].teal =
                '// !!!! WARNING: This contract is *NOT* ARC4 compliant. It may contain ABI methods, but it also allows app calls where the first argument does NOT match an ABI selector';
        }
        this.abi.methods = this.abi.methods.map((m) => ({
            ...m,
            args: m.args.map((a) => ({ ...a, type: a.type })),
            returns: { ...m.returns, type: m.returns.type },
        }));
        this.abi.methods.forEach((method) => {
            const m = method;
            const subroutine = this.subroutines.find((s) => s.name === m.name);
            if (subroutine === undefined)
                throw Error(`Subroutine ${m.name} not found`);
            const comment = subroutine.desc;
            if (comment === '')
                return;
            try {
                const tsdocParser = new tsdoc.TSDocParser();
                const { docComment } = tsdocParser.parseString(comment);
                m.desc = renderDocNode(docComment.summarySection);
                docComment.params.blocks.forEach((p) => {
                    const arg = m.args.find((a) => a.name === p.parameterName);
                    if (arg === undefined)
                        throw new Error(`${p.parameterName} is not an argument of ${m.name}`);
                    arg.desc = renderDocNode(p.content);
                });
                if (docComment.returnsBlock) {
                    m.returns.desc = renderDocNode(docComment.returnsBlock.content);
                }
            }
            catch (e) {
                // eslint-disable-next-line no-console
                if (!this.disableWarnings)
                    console.warn(`Error when parsing tsdoc comment for ${m.name}: ${e}`);
            }
        });
        if (this.currentProgram === 'lsig')
            return;
        // Start of clear program compiliation
        this.currentProgram = 'clear';
        this.teal.clear
            .map((t) => t.teal)
            .forEach((t) => {
            if (t.startsWith('callsub')) {
                const subNode = this.subroutines.find((s) => s.name === t.split(' ')[1]);
                if (subNode === undefined)
                    return;
                this.processNode(subNode.node);
            }
        });
        while (this.pendingSubroutines.length > 0) {
            this.processSubroutine(this.pendingSubroutines.pop());
        }
        this.teal.clear = await this.postProcessTeal(this.teal.clear);
        this.teal.clear = (0, optimize_1.optimizeTeal)(this.teal.clear);
        this.teal.clear = this.prettyTeal(this.teal.clear);
    }
    push(node, teal, type, errorMessage) {
        this.lastNode = node;
        if (!equalTypes(type, StackType.void))
            this.lastType = type;
        if (errorMessage)
            this.teal[this.currentProgram].push({ teal: `// ${errorMessage}`, node });
        this.teal[this.currentProgram].push({ teal, node, errorMessage });
    }
    pushVoid(node, teal, errorMessage) {
        this.push(node, teal, StackType.void, errorMessage);
    }
    getSignature(node) {
        if (node.isKind(ts.SyntaxKind.ClassDeclaration)) {
            return 'createApplication()void';
        }
        const abiArgs = node.getParameters().map((p) => {
            return typeInfoToABIString(this.getTypeInfo(p.getType()));
        });
        return `${node.getName()}(${abiArgs.join(',')})${typeInfoToABIString(this.getTypeInfo(node.getReturnType()))
            .replace(/account/g, 'address')
            .replace(/asset/g, 'uint64')
            .replace(/application/g, 'uint64')}`;
    }
    pushMethod(subroutine) {
        this.pushVoid(this.lastNode, `method "${this.getSignature(subroutine)}"`);
    }
    routeAbiMethods() {
        const switchIndex = this.teal[this.currentProgram].map((t) => t.teal).findIndex((t) => t.startsWith('switch '));
        ON_COMPLETES.forEach((onComplete) => {
            if (onComplete === 'ClearState')
                return;
            ['create', 'call'].forEach((a) => {
                const methods = this.abi.methods.filter((m) => {
                    const subroutine = this.subroutines.find((s) => s.name === m.name);
                    return subroutine.allows[a].includes(onComplete);
                });
                const nonAbi = this.subroutines.find((s) => s.nonAbi[a].includes(onComplete));
                if (methods.length === 0 && this.bareCallConfig[onComplete] === undefined && nonAbi === undefined) {
                    this.teal[this.currentProgram][switchIndex].teal = this.teal[this.currentProgram][switchIndex].teal.replace(`*${a}_${onComplete}`, '*NOT_IMPLEMENTED');
                    return;
                }
                this.pushVoid(this.classNode, `*${a}_${onComplete}:`);
                if (a.toUpperCase() === this.bareCallConfig[onComplete]?.action) {
                    this.pushLines(this.classNode, 'txn NumAppArgs', `bz *abi_route_${this.bareCallConfig[onComplete].method}`);
                }
                if (methods.length === 0 && nonAbi === undefined) {
                    this.pushVoid(this.classNode, 'err', `this contract does not implement any ABI methods for ${onComplete} ${a}`);
                    return;
                }
                methods.forEach((m) => {
                    this.pushMethod(this.subroutines.find((s) => s.name === m.name).node);
                });
                if (methods.length > 0) {
                    this.pushLines(this.classNode, 'txna ApplicationArgs 0', `match ${methods.map((m) => `*abi_route_${m.name}`).join(' ')}`);
                }
                if (nonAbi) {
                    this.pushLines(this.classNode, '// !!!! WARNING: non-ABI routing', `callsub ${nonAbi.name}`, 'int 1', 'return');
                }
                else {
                    this.pushVoid(this.classNode, 'err', `this contract does not implement the given ABI method for ${a} ${onComplete}`);
                }
            });
        });
        if (this.teal[this.currentProgram][switchIndex].teal.endsWith('*NOT_IMPLEMENTED')) {
            const removeLastDuplicates = (array) => {
                let lastIndex = array.length - 1;
                const element = array[lastIndex];
                while (array[lastIndex] === element && lastIndex >= 0) {
                    array.pop();
                    lastIndex--;
                }
                return array;
            };
            const switchLine = removeLastDuplicates(this.teal[this.currentProgram][switchIndex].teal.split(' ')).join(' ');
            this.teal[this.currentProgram][switchIndex].teal = switchLine;
        }
    }
    assertMaybeValue(node, opcode, type, errorMessage) {
        this.pushVoid(node, opcode);
        this.push(node, 'assert', type, errorMessage);
    }
    popMaybeValue(node, opcode, type) {
        this.pushVoid(node, opcode);
        this.push(node, 'pop', type);
    }
    hasMaybeValue(node, opcode) {
        this.pushVoid(node, opcode);
        this.pushVoid(node, 'swap');
        this.push(node, 'pop', { kind: 'base', type: 'bool' });
    }
    pushComments(node) {
        const commentRanges = [
            ...(ts.ts.getLeadingCommentRanges(this.sourceFile.getText(), node.compilerNode.pos) || []),
            ...(ts.ts.getTrailingCommentRanges(this.sourceFile.getText(), node.compilerNode.pos) || []),
        ];
        commentRanges.forEach((c) => {
            const comment = this.sourceFile.getText().slice(c.pos, c.end);
            if (comment.startsWith('///') && !this.comments.includes(c.pos)) {
                this.pushVoid(this.lastNode, comment.replace('///', '//'));
                this.comments.push(c.pos);
            }
        });
    }
    processThrowStatement(node) {
        const expr = node.getExpression();
        if (!expr.isKind(ts.SyntaxKind.CallExpression))
            throw Error('Must throw Error');
        if (expr.getExpression().getText() !== 'Error')
            throw Error('Must throw Error');
        const args = expr.getArguments();
        const errorMessage = args?.[0].getType().isStringLiteral()
            ? args[0].getType().getLiteralValueOrThrow().valueOf().toString()
            : undefined;
        this.pushVoid(node, 'err', errorMessage);
    }
    processDoStatement(node) {
        const thisLoop = `*do_while_${this.doWhileCount}`;
        this.doWhileCount += 1;
        const prevLoop = this.currentLoop;
        this.currentLoop = thisLoop;
        this.pushVoid(node, `${thisLoop}_statement:`);
        this.processNode(node.getStatement());
        this.pushVoid(node, `${thisLoop}:`);
        this.pushVoid(node, `${thisLoop}_continue:`);
        this.processConditional(node.getExpression());
        this.pushVoid(node, `bnz ${thisLoop}_statement`);
        this.pushVoid(node, `${thisLoop}_end:`);
        this.currentLoop = prevLoop;
    }
    processWhileStatement(node) {
        const thisLoop = `*while_${this.whileCount}`;
        this.whileCount += 1;
        const prevLoop = this.currentLoop;
        this.currentLoop = thisLoop;
        this.pushVoid(node, `${thisLoop}:`);
        this.pushVoid(node, `${thisLoop}_continue:`);
        this.processConditional(node.getExpression());
        this.pushVoid(node, `bz ${thisLoop}_end`);
        this.processNode(node.getStatement());
        this.pushVoid(node, `b ${thisLoop}`);
        this.pushVoid(node, `${thisLoop}_end:`);
        this.currentLoop = prevLoop;
    }
    processForStatement(node) {
        const start = node.getStart();
        const end = node.getChildren()[7].getEnd();
        const forComment = node.getSourceFile().getFullText().slice(start, end);
        this.addSourceComment(node, true, forComment);
        this.processNode(node.getInitializerOrThrow());
        const preLoop = this.currentLoop;
        const thisLoop = `*for_${this.forCount}`;
        this.forCount += 1;
        this.currentLoop = thisLoop;
        this.pushVoid(node, `${thisLoop}:`);
        this.addSourceComment(node.getConditionOrThrow(), true);
        this.processConditional(node.getConditionOrThrow());
        this.pushVoid(node, `bz ${thisLoop}_end`);
        this.processNode(node.getStatement());
        this.pushVoid(node, `${thisLoop}_continue:`);
        this.addSourceComment(node.getIncrementorOrThrow(), true);
        this.processNode(node.getIncrementorOrThrow());
        this.pushVoid(node, `b ${thisLoop}`);
        this.pushVoid(node, `${thisLoop}_end:`);
        this.currentLoop = preLoop;
    }
    processForOfStatement(node) {
        const arrayNode = node.getExpression();
        const logic = node.getStatement();
        const declarations = node.getInitializer();
        const name = declarations.getDeclarations()[0].getNameNode().getText();
        this.forIterator(node, arrayNode, logic, name, 'forOf');
    }
    /**
     * Every node in the AST is passed through this function.
     */
    processNode(node) {
        this.pushComments(node);
        // See comment on topLevelNode property for explanation
        let isTopLevelNode = false;
        if (!node.isKind(ts.SyntaxKind.ClassDeclaration) &&
            !node.isKind(ts.SyntaxKind.MethodDeclaration) &&
            !node.isKind(ts.SyntaxKind.Block) &&
            !node.isKind(ts.SyntaxKind.ExpressionStatement) &&
            !node.isKind(ts.SyntaxKind.NonNullExpression)) {
            if (this.nodeDepth === 0) {
                this.topLevelNode = node;
                isTopLevelNode = true;
            }
            this.nodeDepth += 1;
        }
        try {
            if (node.isKind(ts.SyntaxKind.PropertyDeclaration))
                this.processPropertyDefinition(node);
            else if (node.isKind(ts.SyntaxKind.ForOfStatement))
                this.processForOfStatement(node);
            else if (node.isKind(ts.SyntaxKind.MethodDeclaration))
                this.processMethodDefinition(node);
            else if (node.isKind(ts.SyntaxKind.PropertyAccessExpression))
                this.processExpressionChain(node);
            else if (node.isKind(ts.SyntaxKind.AsExpression))
                this.processTypeCast(node);
            else if (node.isKind(ts.SyntaxKind.TypeAssertionExpression))
                this.processTypeCast(node);
            else if (node.isKind(ts.SyntaxKind.NewExpression))
                this.processNewExpression(node);
            else if (node.isKind(ts.SyntaxKind.ArrayLiteralExpression))
                this.processArrayLiteralExpression(node);
            else if (node.isKind(ts.SyntaxKind.NonNullExpression))
                this.processNode(node.getExpression());
            else if (node.isKind(ts.SyntaxKind.ObjectLiteralExpression))
                this.processObjectLiteralExpression(node);
            else if (node.compilerNode.kind === 108)
                this.lastType = { kind: 'base', type: 'this' };
            else if (node.isKind(ts.SyntaxKind.ThrowStatement))
                this.processThrowStatement(node);
            else if (node.isKind(ts.SyntaxKind.WhileStatement))
                this.processWhileStatement(node);
            else if (node.isKind(ts.SyntaxKind.ForStatement))
                this.processForStatement(node);
            else if (node.isKind(ts.SyntaxKind.DoStatement))
                this.processDoStatement(node);
            // Vars/Consts
            else if (node.isKind(ts.SyntaxKind.Identifier))
                this.processIdentifier(node);
            else if (node.isKind(ts.SyntaxKind.VariableDeclarationList))
                this.processVariableDeclaration(node);
            else if (node.isKind(ts.SyntaxKind.VariableDeclaration))
                this.processVariableDeclarator(node);
            else if (node.isKind(ts.SyntaxKind.NumericLiteral) || node.isKind(ts.SyntaxKind.StringLiteral))
                this.processLiteral(node);
            // Logical
            else if (node.isKind(ts.SyntaxKind.Block))
                this.processBlockStatement(node);
            else if (node.isKind(ts.SyntaxKind.IfStatement))
                this.processIfStatement(node);
            else if (node.isKind(ts.SyntaxKind.PrefixUnaryExpression))
                this.processUnaryExpression(node);
            else if (node.isKind(ts.SyntaxKind.BinaryExpression))
                this.processBinaryExpression(node);
            else if (node.isKind(ts.SyntaxKind.CallExpression)) {
                const expr = node.getExpression();
                if (expr.isKind(ts.SyntaxKind.PropertyAccessExpression)) {
                    this.processExpressionChain(node);
                }
                else {
                    this.processCallExpression(node);
                }
            }
            else if (node.isKind(ts.SyntaxKind.ExpressionStatement))
                this.processExpressionStatement(node);
            else if (node.isKind(ts.SyntaxKind.ReturnStatement))
                this.processReturnStatement(node);
            else if (node.isKind(ts.SyntaxKind.ParenthesizedExpression))
                this.processNode(node.getExpression());
            else if (node.isKind(ts.SyntaxKind.VariableStatement))
                this.processNode(node.getDeclarationList());
            else if (node.isKind(ts.SyntaxKind.ElementAccessExpression))
                this.processExpressionChain(node);
            else if (node.isKind(ts.SyntaxKind.ConditionalExpression))
                this.processConditionalExpression(node);
            else if (node.compilerNode.kind === ts.SyntaxKind.TrueKeyword) {
                this.push(node, 'int 1', { kind: 'base', type: 'bool' });
            }
            else if (node.compilerNode.kind === ts.SyntaxKind.FalseKeyword) {
                this.push(node, 'int 0', { kind: 'base', type: 'bool' });
            }
            else if (node.isKind(ts.SyntaxKind.BreakStatement)) {
                this.pushVoid(node, `b ${this.currentLoop}_end`);
            }
            else if (node.isKind(ts.SyntaxKind.ContinueStatement)) {
                this.pushVoid(node, `b ${this.currentLoop}_continue`);
            }
            else
                throw new Error(`Unknown node type: ${node.getKindName()}`);
        }
        catch (e) {
            if (!(e instanceof Error))
                throw e;
            // Because this is recursive, we need to keep track of the error from
            // the node that actually caused the error and ignore all other error messages
            this.processErrorNodes.push(node);
            const errNode = this.processErrorNodes[0];
            const loc = ts.ts.getLineAndCharacterOfPosition(errNode.getSourceFile().compilerNode, errNode.getStart());
            const lines = [];
            const errPath = path_1.default.relative(this.cwd, errNode.getSourceFile().getFilePath());
            errNode
                .getText()
                .split('\n')
                .forEach((l, i) => {
                lines.push(`${errPath}:${loc.line + i + 1}: ${l}`);
            });
            const msg = `TEALScript can not process ${errNode.getKindName()} at ${errPath}:${loc.line}:${loc.character}\n    ${lines.join('\n    ')}\n`;
            e.message = `${e.message.replace(`\n${msg}`, '')}\n${msg}`;
            throw e;
        }
        if (isTopLevelNode)
            this.nodeDepth = 0;
    }
    processObjectLiteralExpression(node) {
        const type = this.typeHint;
        if (type === undefined)
            throw new Error();
        const elements = [];
        const objTypes = getObjectTypes(type);
        node.getProperties().forEach((p) => {
            if (!p.isKind(ts.SyntaxKind.PropertyAssignment))
                throw new Error();
            elements[Object.keys(objTypes).indexOf(p.getNameNode().getText())] = p.getInitializer();
        });
        this.processArrayElements(elements, node);
    }
    processConditionalExpression(node) {
        const tc = this.ternaryCount;
        const thisTernary = `*ternary${tc}`;
        this.ternaryCount += 1;
        this.processConditional(node.getCondition());
        this.pushVoid(node, `bz ${thisTernary}_false`);
        this.processNode(node.getWhenTrue());
        this.pushVoid(node, `b ${thisTernary}_end`);
        this.pushVoid(node, `${thisTernary}_false:`);
        this.processNode(node.getWhenFalse());
        this.pushVoid(node, `${thisTernary}_end:`);
    }
    pushLines(node, ...lines) {
        lines.forEach((l) => this.push(node, l, StackType.void));
    }
    getarrayElementTypes(elements) {
        if (this.typeHint === undefined)
            throw new Error('Type hint is undefined');
        if (this.typeHint.kind === 'dynamicArray') {
            return new Array(elements).fill(this.typeHint.base);
        }
        if (this.typeHint.kind === 'tuple') {
            return this.typeHint.elements;
        }
        if (this.typeHint.kind === 'base') {
            return new Array(elements).fill(this.typeHint);
        }
        if (this.typeHint.kind === 'object') {
            return Object.values(this.typeHint.properties);
        }
        if (this.typeHint.kind === 'staticArray') {
            return new Array(elements).fill(this.typeHint.base);
        }
        throw new Error();
    }
    processBools(nodes, isDynamicArray = false) {
        const boolByteLength = Math.ceil(nodes.length / 8);
        if (isDynamicArray)
            this.pushVoid(nodes[0], `byte 0x${nodes.length.toString(16).padStart(4, '0')}`);
        this.pushVoid(nodes[0], `byte 0x${'00'.repeat(boolByteLength)}`);
        nodes.forEach((n, i) => {
            this.pushVoid(n, `int ${i}`);
            this.processNode(n);
            this.pushVoid(n, 'setbit');
        });
        if (isDynamicArray)
            this.pushVoid(nodes[0], 'concat');
    }
    processTuple(elements, parentNode) {
        if (this.typeHint === undefined)
            throw new Error('Type hint is undefined');
        const { typeHint } = this;
        // TODO figure out what this was for
        // if (!this.getABIType(typeHint).includes(']')) typeHint = `${typeHint}[]`;
        const types = this.getarrayElementTypes(elements.length);
        const dynamicTypes = types.filter((t) => this.isDynamicType(t));
        const staticTypes = types.filter((t) => !this.isDynamicType(t));
        const staticTuple = { kind: 'tuple', elements: staticTypes };
        const headLength = this.getTypeLength(staticTuple) + dynamicTypes.length * 2;
        const isStatic = !this.isDynamicType(typeHint);
        let consecutiveBools = [];
        elements.forEach((e, i) => {
            if (i === 0 && !isStatic) {
                this.pushLines(parentNode, 'byte 0x // initial head', 'byte 0x // initial tail', `byte 0x${headLength.toString(16).padStart(4, '0')} // initial head offset`);
            }
            if (equalTypes(types[i], { kind: 'base', type: 'bool' })) {
                consecutiveBools.push(e);
                return;
            }
            if (consecutiveBools.length > 0) {
                this.processBools(consecutiveBools);
                if (!isStatic)
                    this.pushVoid(e, 'callsub *process_static_tuple_element');
                // Don't concat if bools are the first elements
                else if (consecutiveBools.length !== i)
                    this.pushVoid(e, `concat // ${i}`);
                consecutiveBools = [];
            }
            this.typeHint = types[i];
            if (e.getType().isNumberLiteral()) {
                this.processNumericLiteralWithType(e, types[i]);
            }
            else {
                this.processNode(e);
            }
            this.checkEncoding(e, this.lastType);
            typeComparison(this.lastType, types[i]);
            if (this.isDynamicType(types[i]))
                this.pushVoid(e, 'callsub *process_dynamic_tuple_element');
            else if (!isStatic)
                this.pushVoid(e, 'callsub *process_static_tuple_element');
            else if (i !== 0)
                this.pushVoid(e, 'concat');
        });
        if (consecutiveBools.length > 0) {
            this.processBools(consecutiveBools);
            if (!isStatic)
                this.pushVoid(parentNode, 'callsub *process_static_tuple_element');
            if (isStatic && consecutiveBools.length !== elements.length)
                this.pushVoid(parentNode, 'concat');
        }
        if (!isStatic)
            this.pushLines(parentNode, 'pop // pop head offset', 'concat // concat head and tail');
    }
    checkEncoding(node, type) {
        if (type.kind === 'base') {
            const width = parseInt(type.type.match(/\d+/)?.[0] || '512', 10);
            if (isSmallNumber(type)) {
                this.pushVoid(node, 'itob');
                if (type.type.startsWith('unsafe'))
                    this.overflowCheck(node, width);
                this.pushLines(node, `extract ${(64 - width) / 8} ${width / 8}`);
                this.lastType = { kind: 'base', type: type.type.replace(/unsafe /g, '') };
                return;
            }
            if (type.type.startsWith('unsafe')) {
                this.overflowCheck(node, width);
                this.fixBitWidth(node, width);
                this.lastType = { kind: 'base', type: type.type.replace(/unsafe /g, '') };
                return;
            }
        }
        const abiType = typeInfoToABIString(type);
        if (type.kind === 'dynamicArray' && this.isDynamicArrayOfStaticType(type)) {
            const baseType = typeInfoToABIString(type.base);
            if (baseType === 'bool')
                return;
            const length = this.getTypeLength(type.base);
            this.pushLines(node, 'dup', 'len');
            if (length > 1) {
                this.pushLines(node, `int ${length}`, '/');
            }
            this.pushLines(node, 'itob', 'extract 6 2', 'swap', 'concat');
        }
        else if (isBytes(type)) {
            this.pushLines(node, 'dup', 'len', 'itob', 'extract 6 2', 'swap', 'concat');
        }
        else if (abiType === 'bool') {
            this.pushLines(node, 'byte 0x00', 'int 0', 'uncover 2', 'setbit');
        }
        else if (isNumeric(type)) {
            this.pushLines(node, 'itob');
        }
    }
    getTupleElement(type) {
        const elem = new TupleElement(type, 0);
        let offset = 0;
        let consecutiveBools = 0;
        const processTypeInfo = (ti) => {
            const abiType = typeInfoToABIString(ti);
            if (abiType === 'bool') {
                consecutiveBools += 1;
                elem.add(new TupleElement(ti, offset));
                return;
            }
            if (consecutiveBools) {
                offset += Math.ceil(consecutiveBools / 8);
                consecutiveBools = 0;
            }
            if (ti.kind === 'tuple' || ti.kind === 'object') {
                const t = new TupleElement(ti, offset);
                t.add(...this.getTupleElement(ti));
                elem.add(t);
            }
            else if (ti.kind === 'staticArray' || ti.kind === 'dynamicArray') {
                const t = new TupleElement(ti, offset);
                t.add(this.getTupleElement(ti.base));
                elem.add(t);
            }
            else
                elem.add(new TupleElement(ti, offset));
            if (this.isDynamicType(ti)) {
                offset += 2;
            }
            else {
                offset += this.getTypeLength(ti);
            }
        };
        if (type.kind === 'object') {
            Object.values(type.properties).forEach((t) => {
                processTypeInfo(t);
            });
        }
        if (type.kind === 'tuple') {
            type.elements.forEach((t) => {
                processTypeInfo(t);
            });
        }
        if (type.kind === 'staticArray') {
            elem.add(this.getTupleElement(type.base));
        }
        if (type.kind === 'dynamicArray') {
            elem.add(this.getTupleElement(type.base));
        }
        return elem;
    }
    processArrayElements(elements, parentNode) {
        const { typeHint } = this;
        if (typeHint === undefined)
            throw Error('Type hint must be provided to process object or array');
        if (typeHint.kind === 'tuple' ||
            typeHint.kind === 'object' ||
            ((typeHint.kind === 'staticArray' || typeHint.kind === 'dynamicArray') && this.isDynamicType(typeHint.base))) {
            this.processTuple(elements, parentNode);
            if (typeHint.kind === 'dynamicArray') {
                this.pushLines(parentNode, `byte 0x${elements.length.toString(16).padStart(4, '0')}`, 'swap', 'concat');
            }
            this.lastType = typeHint;
            return;
        }
        const types = this.getarrayElementTypes(elements.length);
        if ((typeHint.kind === 'staticArray' || typeHint.kind === 'dynamicArray') &&
            equalTypes(typeHint.base, { kind: 'base', type: 'bool' })) {
            this.processBools(elements, typeHint.kind === 'dynamicArray');
        }
        else {
            elements.forEach((e, i) => {
                this.typeHint = types[i];
                if (e.getType().isNumberLiteral()) {
                    this.processNumericLiteralWithType(e, types[i]);
                }
                else {
                    this.processNode(e);
                }
                typeComparison(this.lastType, types[i]);
                this.checkEncoding(e, types[i]);
                if (i)
                    this.pushVoid(parentNode, 'concat');
            });
        }
        if (typeHint.kind === 'staticArray') {
            const { length } = typeHint;
            if (length && elements.length < length) {
                const typeLength = this.getTypeLength(typeHint.base);
                this.pushVoid(parentNode, `byte 0x${'00'.repeat(typeLength * (length - elements.length))}`);
                if (elements.length > 0)
                    this.pushVoid(parentNode, 'concat');
            }
        }
        this.lastType = typeHint;
    }
    processArrayLiteralExpression(node) {
        if (this.typeHint === undefined)
            throw new Error('Type hint is undefined');
        const { typeHint } = this;
        if (typeHint.kind === 'dynamicArray' && node.getElements().length === 0) {
            this.push(node, 'byte 0x', typeHint);
            return;
        }
        this.processArrayElements(node.getElements(), node);
    }
    /**
     *
     * @param node The top level node to process
     * @param chain The existing expression chain to add to
     * @returns The base expression and reversed expression chain `this.txn.sender` ->
     * `{ chain: [this.txn, this.txn.sender], base: [this] }`
     */
    getExpressionChain(node, chain = []) {
        chain.push(node);
        /**
         * The expression on the given node
         * `this.txn.sender` -> `this.txn`
         */
        let expr = node.getExpression();
        /* this.txn.applicationArgs! -> this.txn.applicationArgs */
        if (expr.isKind(ts.SyntaxKind.NonNullExpression)) {
            expr = expr.getExpression();
        }
        if (expr.isKind(ts.SyntaxKind.ElementAccessExpression) ||
            expr.isKind(ts.SyntaxKind.PropertyAccessExpression) ||
            expr.isKind(ts.SyntaxKind.CallExpression)) {
            return this.getExpressionChain(expr, chain);
        }
        chain.reverse();
        return { base: expr, chain };
    }
    getAccessChain(node, chain = []) {
        chain.push(node);
        const expr = node.getExpression();
        if (expr.isKind(ts.SyntaxKind.ElementAccessExpression)) {
            this.getAccessChain(expr, chain);
        }
        return chain;
    }
    /**
     * Given a variable name, this function will return the value that we ultimately need to get from the frame
     *
     * For example:
     *
     * ```ts
     * const x = a[1][2]
     * const y = x[3][4]
     * ```
     *
     * Given `y`, return that we are ultimately accessing `a[1][2][3][4]`
     *
     * @param node The node of the variable that we're accessing
     * @param inputName The name of the variable that we're accessing
     * @param load Whether or not to load the value and put it on the stack. If false, it will just return information about the frame object
     * @returns
     */
    processFrame(node, inputName, load) {
        let name = inputName;
        let currentFrame = this.localVariables[inputName];
        let type = 'frame';
        let storageExpression;
        const accessors = [];
        /*
        Walk through the pointers until we get the base frame object
        Each step might include array access, which we need to return
        For example:
        
        ```ts
        const x = a[1][2]
        const y = x[3][4]
        ```
    
        `y` frame object has the accessor [3,4] and `x` frame object has accessors `[1,2]`, giving us the full access chain `[1,2,3,4]`
        */
        while (currentFrame.framePointer !== undefined) {
            if (currentFrame.accessors)
                accessors.push(currentFrame.accessors);
            name = currentFrame.framePointer;
            currentFrame = this.localVariables[name];
        }
        // If the base is saving a storage map or local storage, then we need to get the storage expression
        if (currentFrame.storageExpression !== undefined) {
            if (currentFrame.accessors)
                accessors.push(currentFrame.accessors);
            // eslint-disable-next-line prefer-destructuring
            name = getStorageName(currentFrame.storageExpression);
            type = 'storage';
            storageExpression = currentFrame.storageExpression;
        }
        // If we aren't loading the value, the just retun the information about it
        if (!load) {
            return {
                name,
                type,
                accessors: accessors.reverse().flat(),
                storageExpression,
                storageKeyFrame: currentFrame.storageKeyFrame,
                storageAccountFrame: currentFrame.storageAccountFrame,
            };
        }
        // If we are loading, then either dig from the frame or load from storage
        if (currentFrame.storageExpression !== undefined) {
            this.handleStorageAction({
                node: currentFrame.storageExpression,
                storageKeyFrame: currentFrame.storageKeyFrame,
                storageAccountFrame: currentFrame.storageAccountFrame,
                action: 'get',
            });
            // Don't actually load the result of multi-output opcodes because there's an explicit load later when processing the property access
        }
        else if (!MULTI_OUTPUT_TYPES.includes(typeInfoToABIString(currentFrame.type))) {
            this.push(node, `frame_dig ${currentFrame.index} // ${name}: ${currentFrame.typeString}`, currentFrame.type);
        }
        else {
            this.lastType = currentFrame.type;
        }
        return { name, type, accessors: accessors.reverse().flat() };
    }
    updateValue(node) {
        const currentArgs = this.currentSubroutine.args;
        // Add back to frame/storage if necessary
        if (node.isKind(ts.SyntaxKind.Identifier)) {
            const name = node.getText();
            const frameObj = this.localVariables[name];
            if (frameObj.index !== undefined) {
                const { index, type, typeString } = this.localVariables[name];
                if (currentArgs.find((s) => s.name === name && isArrayType(s.type))) {
                    throw Error('Mutating argument array is not allowed. Use "clone()" method to create a deep copy.');
                }
                this.pushVoid(node, `frame_bury ${index} // ${name}: ${typeString}`);
            }
            else {
                const processedFrame = this.processFrame(node, name, false);
                if (processedFrame.type === 'frame') {
                    const frame = this.localVariables[processedFrame.name];
                    if (currentArgs.find((s) => s.name === processedFrame.name && isArrayType(s.type))) {
                        throw Error('Mutating argument array is not allowed. Use "clone()" method to create a deep copy.');
                    }
                    this.pushVoid(node, `frame_bury ${frame.index} // ${name}: ${frame.typeString}`);
                }
                else {
                    const { type, valueType } = this.storageProps[processedFrame.name];
                    const action = type === 'box' && !this.isDynamicType(valueType) ? 'replace' : 'set';
                    this.handleStorageAction({
                        node: processedFrame.storageExpression,
                        storageAccountFrame: processedFrame.storageAccountFrame,
                        storageKeyFrame: processedFrame.storageKeyFrame,
                        action,
                    });
                }
            }
        }
        else if (node.isKind(ts.SyntaxKind.CallExpression) || node.isKind(ts.SyntaxKind.PropertyAccessExpression)) {
            let storageName;
            if (node.isKind(ts.SyntaxKind.CallExpression)) {
                if (!node.getExpression().isKind(ts.SyntaxKind.PropertyAccessExpression))
                    throw new Error('Must be property access expression');
                storageName = getStorageName(node.getExpression());
            }
            else
                storageName = getStorageName(node);
            if (this.scratch[storageName]) {
                const scratch = this.scratch[storageName];
                const { slot, type } = scratch;
                typeComparison(this.lastType, type);
                if (slot !== undefined) {
                    this.pushVoid(node, `store ${slot}`);
                }
                else {
                    const call = node.getDescendantsOfKind(ts.SyntaxKind.CallExpression)[0];
                    this.processNode(call.getArguments()[0]);
                    this.pushVoid(node, 'swap');
                    this.pushVoid(node, `stores`);
                }
                return;
            }
            const storageProp = this.storageProps[storageName];
            const { type, valueType } = storageProp;
            let action = type === 'box' && !this.isDynamicType(valueType) && !typeInfoToABIString(valueType).includes('bool')
                ? 'replace'
                : 'set';
            if (valueType.kind === 'base')
                action = 'set';
            // Honestly not sure why I needed to add this after b89ddc6c24d6102f9e890a0e76222de7e0ca79b5 (0.67.2)
            // But it works...
            if (type === 'box' &&
                action === 'replace' &&
                this.teal[this.currentProgram].at(-1)?.teal.startsWith('replace3')) {
                this.teal[this.currentProgram].pop();
            }
            this.handleStorageAction({
                node,
                action,
            });
        }
        else {
            throw new Error(`Can't update ${node.getKindName()} array`);
        }
    }
    getElementHead(topLevelTuple, accessors, node) {
        let previousTupleElement = topLevelTuple;
        let previousElemIsBool = false;
        // At the end of this forEach, the stack will contain the HEAD offset of the accessed element
        accessors.forEach((acc, i) => {
            if (typeof acc === 'string') {
                if (!acc.startsWith('accessor//')) {
                    const index = Object.keys(getObjectTypes(previousTupleElement.type)).indexOf(acc);
                    const elem = previousTupleElement[index];
                    this.pushLines(node, `int ${elem.headOffset} // headOffset`, '+');
                    previousTupleElement = elem;
                    return;
                }
                const elem = previousTupleElement[0];
                const frame = this.localVariables[acc];
                this.push(node, `frame_dig ${frame.index} // saved accessor: ${acc}`, StackType.uint64);
                this.pushLines(node, 
                // `int ${accNumber * this.getTypeLength(elem.type)} // acc * typeLength`,
                `int ${this.getTypeLength(elem.type)}`, '* // acc * typeLength', '+');
                previousTupleElement = elem;
                return;
            }
            const accNumber = parseInt(acc.getText(), 10);
            const elem = Number.isNaN(accNumber)
                ? previousTupleElement[0]
                : previousTupleElement[accNumber] || previousTupleElement[0];
            if (typeInfoToABIString(elem.type) === 'bool' && !previousElemIsBool) {
                this.pushLines(acc, `int ${elem.headOffset} // headOffset`, '+');
                previousElemIsBool = true;
            }
            else if (previousTupleElement.arrayType === 'tuple') {
                this.pushLines(acc, `int ${elem.headOffset} // headOffset`, '+');
                // Dynamic element in static or dynamic array
            }
            else if (this.isDynamicType(elem.type)) {
                if (!Number.isNaN(accNumber)) {
                    this.pushLines(acc, `int ${accNumber * 2} // acc * 2`, '+');
                }
                else {
                    this.processNode(acc);
                    if (!isNumeric(this.lastType))
                        this.pushVoid(acc, 'btoi');
                    this.pushLines(acc, 'int 2', '* // acc * 2', '+');
                }
                // Static element in array
            }
            else if (!previousElemIsBool) {
                if (!Number.isNaN(accNumber)) {
                    this.pushLines(acc, `int ${accNumber * this.getTypeLength(elem.type)} // acc * typeLength`, '+');
                }
                else {
                    this.processNode(acc);
                    if (!isNumeric(this.lastType))
                        this.pushVoid(acc, 'btoi');
                    this.pushLines(acc, `int ${this.getTypeLength(elem.type)}`, '* // acc * typeLength', '+');
                }
            }
            if (previousTupleElement.arrayType === 'dynamic' &&
                !(i === 0 && this.isDynamicArrayOfStaticType(previousTupleElement.type))) {
                this.pushLines(acc, 'int 2', '+ // add two for length');
            }
            if (this.isDynamicType(elem.type) && i !== accessors.length - 1) {
                this.pushLines(acc, `load ${compilerScratch.fullArray}`, 'swap', 'extract_uint16');
            }
            previousTupleElement = elem;
        });
        return previousTupleElement;
    }
    processLiteralStaticTupleAccess(node, accessors, parentExpression, newValue) {
        const parentType = this.lastType;
        let previousTupleElement = this.getTupleElement(parentType);
        accessors.forEach((acc, i) => {
            let accNumber;
            if (typeof acc === 'string') {
                if (acc.startsWith('accessor//')) {
                    const frame = this.localVariables[acc];
                    this.push(node, `frame_dig ${frame.index} // saved accessor: ${acc}`, StackType.uint64);
                }
                else
                    accNumber = Object.keys(getObjectTypes(previousTupleElement.type)).indexOf(acc);
            }
            else if (acc.isKind(ts.SyntaxKind.NumericLiteral)) {
                accNumber = parseInt(acc.getText(), 10);
            }
            else {
                this.processNode(acc);
            }
            const accessedElem = previousTupleElement[accNumber ?? 0] || previousTupleElement[0];
            if (accNumber && previousTupleElement[accNumber]) {
                this.pushLines(node, `int ${accessedElem.headOffset} // headOffset`);
            }
            else {
                if (accNumber !== undefined)
                    this.pushVoid(node, `int ${accNumber}`);
                this.pushLines(node, `int ${this.getTypeLength(accessedElem.type)}`, '* // acc * typeLength');
            }
            if (i)
                this.pushVoid(node, '+');
            previousTupleElement = accessedElem;
        });
        const elem = previousTupleElement;
        const length = this.getTypeLength(elem.type);
        const storageExpression = this.localVariables[parentExpression.getText()]?.storageExpression ?? parentExpression;
        const isBox = storageExpression.isKind(ts.SyntaxKind.PropertyAccessExpression) &&
            getStorageName(storageExpression) &&
            this.storageProps[getStorageName(storageExpression)] &&
            this.storageProps[getStorageName(storageExpression)].type === 'box' &&
            !this.isDynamicType(this.storageProps[getStorageName(storageExpression)].valueType);
        if (newValue) {
            if (newValue.getType().isNumberLiteral()) {
                this.processNewValue(newValue, elem.type);
            }
            else {
                this.processNewValue(newValue);
            }
            this.checkEncoding(node, elem.type);
            if (!isBox) {
                this.pushVoid(node, 'replace3');
            }
            this.updateValue(parentExpression);
        }
        else {
            this.pushVoid(node, `int ${length}`);
            if (isBox) {
                this.handleStorageAction({
                    node: storageExpression,
                    action: 'extract',
                });
            }
            else
                this.pushLines(node, 'extract3');
            this.checkDecoding(node, elem.type);
            this.lastType = elem.type;
        }
    }
    processParentArrayAccess(node, accessors, parentExpression, newValue) {
        const parentType = this.lastType;
        // If we know the tuple is static and doesn't contain bools or dynamic accessors,
        // we can skip all of the opcodes and just use the offset calculated by getElementHead directly
        // TODO: add bool support
        const isNonBoolStatic = !this.isDynamicType(parentType) && !typeInfoToABIString(parentType).includes('bool');
        let literalAccessors = true;
        accessors.forEach((a) => {
            if (typeof a === 'string') {
                if (a.startsWith('accessor//'))
                    literalAccessors = false;
                return;
            }
            if (Number.isNaN(parseInt(a.getText(), 10)))
                literalAccessors = false;
        });
        if (isNonBoolStatic) {
            this.processLiteralStaticTupleAccess(node, accessors, parentExpression, newValue);
            return;
        }
        this.pushLines(node, `store ${compilerScratch.fullArray}`, 'int 0 // initial offset');
        const topLevelTuple = this.getTupleElement(parentType);
        const element = this.getElementHead(topLevelTuple, accessors, node);
        let baseType;
        if (element.type.kind === 'staticArray' || element.type.kind === 'dynamicArray') {
            baseType = element.type.base;
        }
        else {
            baseType = element.type;
        }
        if (this.isDynamicType(element.type)) {
            if (!isBytes(element.type) && this.isDynamicType(baseType)) {
                throw new Error(`Cannot access nested dynamic array element: ${typeInfoToABIString(element.type)}`);
            }
            if (newValue) {
                this.pushLines(node, 'dup', `store ${compilerScratch.elementHeadOffset}`);
            }
            this.pushLines(node, `load ${compilerScratch.fullArray}`, `load ${compilerScratch.fullArray}`, 'uncover 2', 'extract_uint16');
            if (element.parent.type.kind === 'dynamicArray') {
                this.pushLines(node, 'int 2', '+ // add two for length');
            }
            if (newValue) {
                this.pushLines(node, 'dup', `store ${compilerScratch.elementStart}`);
            }
            this.pushLines(node, 'dup // duplicate start of element', `load ${compilerScratch.fullArray}`, 'swap', 'extract_uint16 // get number of elements', `int ${this.getTypeLength(baseType)} // get type length`, '* // multiply by type length', 'int 2', '+ // add two for length');
            this.pushVoid(node, newValue ? `store ${compilerScratch.elementLength}` : 'extract3');
        }
        if (newValue) {
            if (this.isDynamicType(element.type)) {
                if (element.parent?.arrayType !== 'tuple') {
                    throw new Error('Updating nested dynamic array elements not yet supported. The entire array must be overwritten to change a value');
                }
                // Get pre element
                this.pushLines(node, `load ${compilerScratch.fullArray}`, 'int 0', `load ${compilerScratch.elementStart}`, 'substring3');
                // Get new element
                if (newValue.getType().isNumberLiteral()) {
                    this.processNumericLiteralWithType(newValue, element.type);
                }
                else {
                    this.processNewValue(newValue);
                }
                this.checkEncoding(newValue, this.lastType);
                this.pushLines(newValue, 'dup', `store ${compilerScratch.newElement}`);
                // Get post element
                this.pushLines(node, `load ${compilerScratch.fullArray}`, `load ${compilerScratch.elementStart}`, `load ${compilerScratch.elementLength}`, '+ // get end of Element', `load ${compilerScratch.fullArray}`, 'len', 'substring3');
                // Form new tuple
                this.pushLines(node, 'concat', 'concat', `store ${compilerScratch.fullArray}`);
                // Get length difference
                this.pushLines(node, 'callsub *get_length_difference');
                const elementIndex = element.parent.findIndex((e) => e.id === element.id);
                const nextDynamicSiblings = element.parent.slice(elementIndex + 1).filter((e) => this.isDynamicType(e.type));
                const headDiffs = nextDynamicSiblings.map((e) => e.headOffset - element.headOffset);
                headDiffs.forEach((diff) => {
                    this.pushLines(node, `load ${compilerScratch.lengthDifference}`, `load ${compilerScratch.elementHeadOffset}`, `int ${diff}`, '+ // head ofset', 'callsub *update_dynamic_head');
                });
                this.pushVoid(node, `load ${compilerScratch.fullArray}`);
            }
            else if (typeInfoToABIString(element.type) === 'bool') {
                this.pushLines(node, 'int 8', '* // get bit offset');
                let consecutiveBools = 0;
                const elementIndex = element.parent.findIndex((e) => e.id === element.id);
                const boolParentType = element.parent.type;
                if (boolParentType.kind === 'tuple' || boolParentType.kind === 'object') {
                    for (let i = elementIndex - 1; i >= 0; i--) {
                        const { type } = element.parent[i];
                        if (type.kind === 'base' && type.type === 'bool') {
                            consecutiveBools += 1;
                        }
                        else
                            break;
                    }
                    this.pushLines(node, `int ${consecutiveBools}`);
                }
                else if (node.isKind(ts.SyntaxKind.ElementAccessExpression)) {
                    const argExpr = node.getArgumentExpression();
                    if (argExpr === undefined)
                        throw Error();
                    this.processNode(argExpr);
                }
                else if (node.isKind(ts.SyntaxKind.PropertyAccessExpression)) {
                    if (parentType?.kind !== 'object')
                        throw Error();
                    const idx = Object.keys(parentType.properties).indexOf(node.getName());
                    this.pushVoid(node, `int ${idx}`);
                }
                else
                    throw Error();
                this.pushLines(node, '+ // add accessor bits');
                if (element.parent.arrayType === 'dynamic') {
                    this.pushLines(node, 'int 16', '+ // 16 bits for length prefix');
                }
                this.pushLines(node, `load ${compilerScratch.fullArray}`, 'swap');
                this.processNewValue(newValue);
                this.pushVoid(node, 'setbit');
            }
            else {
                this.pushLines(node, `load ${compilerScratch.fullArray}`, 'swap');
                this.processNewValue(newValue);
                this.checkEncoding(newValue, this.lastType);
                this.pushVoid(node, 'replace3');
            }
            this.updateValue(parentExpression);
        }
        else {
            if (typeInfoToABIString(element.type) === 'bool') {
                this.pushLines(node, 'int 8', '*');
                let consecutiveBools = 0;
                const elementIndex = element.parent.findIndex((e) => e.id === element.id);
                const boolParentType = element.parent.type;
                if (boolParentType.kind === 'tuple' || boolParentType.kind === 'object') {
                    for (let i = elementIndex - 1; i >= 0; i--) {
                        const { type } = element.parent[i];
                        if (type.kind === 'base' && type.type === 'bool') {
                            consecutiveBools += 1;
                        }
                        else
                            break;
                    }
                    this.pushLines(node, `int ${consecutiveBools}`);
                }
                else if (node.isKind(ts.SyntaxKind.ElementAccessExpression)) {
                    const argExpr = node.getArgumentExpression();
                    if (argExpr === undefined)
                        throw Error();
                    this.processNode(argExpr);
                }
                else if (node.isKind(ts.SyntaxKind.PropertyAccessExpression)) {
                    if (parentType?.kind !== 'object')
                        throw Error();
                    const idx = Object.keys(parentType.properties).indexOf(node.getName());
                    this.pushVoid(node, `int ${idx}`);
                }
                else
                    throw Error();
                this.pushLines(node, '+', `load ${compilerScratch.fullArray}`, 'swap', 'getbit');
                this.lastType = { kind: 'base', type: 'bool' };
                return;
            }
            if (!this.isDynamicType(element.type)) {
                this.pushLines(node, `load ${compilerScratch.fullArray}`, 'swap', `int ${this.getTypeLength(element.type)}`, 'extract3');
            }
            this.checkDecoding(node, element.type);
            this.lastType = element.type;
        }
    }
    processMethodDefinition(node) {
        if (!node.getNameNode().isKind(ts.SyntaxKind.Identifier))
            throw Error('Method name must be identifier');
        if (node.getReturnType() === undefined)
            throw Error(`A return type annotation must be defined for ${node.getNameNode().getText()}`);
        const returnType = node.getReturnTypeNode()?.getType()
            ? this.getTypeInfo(node.getReturnTypeNode().getType())
            : StackType.void;
        this.currentSubroutine = this.subroutines.find((s) => s.name === node.getNameNode().getText());
        this.currentSubroutine.desc = node
            .getJsDocs()
            .map((j) => j.getText())
            .join('\n');
        if (!node.getBody())
            throw new Error(`A method body must be defined for ${node.getNameNode().getText()}`);
        let scope = 'public';
        node.getModifiers()?.forEach((m) => {
            if (node
                .getDecorators()
                .map((d) => d.getStart())
                .includes(m.getStart()))
                return;
            if (m.compilerNode.kind === ts.SyntaxKind.PrivateKeyword)
                scope = 'private';
            else if (m.compilerNode.kind === ts.SyntaxKind.ProtectedKeyword)
                scope = 'protected';
            else if (m.compilerNode.kind !== ts.SyntaxKind.PublicKeyword) {
                throw Error(`Method modifier "${m.getText()}" is not supported by TEALScript`);
            }
        });
        if (scope !== 'public') {
            this.processSubroutine(node);
            return;
        }
        if (this.currentProgram === 'lsig' && node.getNameNode().getText() !== 'logic') {
            throw Error('Only one method called "logic" can be defined in a logic signature');
        }
        if (this.currentProgram === 'lsig' && !equalTypes(returnType, StackType.void))
            throw Error('logic method must have a void return type');
        this.currentSubroutine.allows = { create: [], call: [] };
        let bareAction = false;
        const n = this.currentSubroutine.name;
        if ([
            'createApplication',
            'updateApplication',
            'deleteApplication',
            'optInToApplication',
            'closeOutOfApplication',
            'clearState',
        ].includes(n)) {
            const isCreate = this.currentSubroutine.name === 'createApplication';
            let oc;
            if (n === 'createApplication')
                oc = 'NoOp';
            else if (n === 'updateApplication')
                oc = 'UpdateApplication';
            else if (n === 'deleteApplication')
                oc = 'DeleteApplication';
            else if (n === 'optInToApplication')
                oc = 'OptIn';
            else if (n === 'closeOutOfApplication')
                oc = 'CloseOut';
            else if (n === 'clearState')
                oc = 'ClearState';
            else
                throw Error();
            const action = isCreate ? 'create' : 'call';
            this.currentSubroutine.allows[action].push(oc);
        }
        node.getDecorators().forEach((d) => {
            const expr = d.getExpression();
            if (expr.isKind(ts.SyntaxKind.PropertyAccessExpression)) {
                if (expr.getExpression().getText() !== 'abi')
                    throw Error(`Unknown decorator ${d.getText()}`);
                if (expr.getName() !== 'readonly')
                    throw Error(`Unknown decorator ${d.getText()}`);
                this.currentSubroutine.readonly = true;
                return;
            }
            const callExpr = d.getExpression();
            if (!callExpr.isKind(ts.SyntaxKind.CallExpression))
                throw Error(`Unknown decorator ${d.getText()}`);
            const propExpr = callExpr.getExpression();
            if (!propExpr.isKind(ts.SyntaxKind.PropertyAccessExpression))
                throw Error(`Unknown decorator ${d.getText()}`);
            const decoratorClass = propExpr.getExpression().getText();
            const decoratorFunction = propExpr.getNameNode().getText();
            switch (decoratorClass) {
                case 'abi':
                    this.currentSubroutine.readonly = true;
                    break;
                case 'allow':
                    if (!['call', 'create', 'bareCreate', 'bareCall'].includes(decoratorFunction))
                        throw Error(`Unknown decorator ${d.getText()}`);
                    if (decoratorFunction.startsWith('bare') && this.currentSubroutine.args.length > 0)
                        throw Error('Cannot use bare decorator on method with arguments');
                    if (['create', 'bareCreate'].includes(decoratorFunction) && callExpr.getArguments().length === 0) {
                        if (decoratorFunction.startsWith('bare')) {
                            bareAction = true;
                            if (this.bareCallConfig.NoOp)
                                throw Error('Duplicate bare decorator for NoOp');
                            this.bareCallConfig.NoOp = { action: 'CREATE', method: this.currentSubroutine.name };
                        }
                        else
                            this.currentSubroutine.allows.create.push('NoOp');
                    }
                    else {
                        const arg = callExpr.getArguments()[0];
                        if (arg === undefined)
                            throw Error(`Missing OnComplete in decorator ${d.getText()}`);
                        if (!arg.isKind(ts.SyntaxKind.StringLiteral))
                            throw Error(`Invalid OnComplete: ${arg.getText()}`);
                        const oc = arg.getLiteralText();
                        if (!ON_COMPLETES.includes(oc))
                            throw Error(`Invalid OnComplete: ${oc}`);
                        if (decoratorFunction.startsWith('bare')) {
                            bareAction = true;
                            if (this.bareCallConfig[oc])
                                throw Error(`Duplicate bare decorator for ${oc}`);
                            const action = decoratorFunction.replace('bare', '').toUpperCase();
                            this.bareCallConfig[oc] = { action, method: this.currentSubroutine.name };
                        }
                        else
                            this.currentSubroutine.allows[decoratorFunction].push(oc);
                    }
                    break;
                case 'nonABIRouterFallback':
                    if (callExpr.getArguments()[0]) {
                        const arg = callExpr.getArguments()[0];
                        if (!arg.isKind(ts.SyntaxKind.StringLiteral))
                            throw Error(`Invalid OnComplete: ${arg.getText()}`);
                        const oc = arg.getLiteralText();
                        if (!ON_COMPLETES.includes(oc))
                            throw Error(`Invalid OnComplete: ${oc}`);
                        if (decoratorFunction !== 'call' && decoratorFunction !== 'create')
                            throw Error(`Unknown decorator ${d.getText()}`);
                        if (this.currentSubroutine.args.length !== 0)
                            throw Error('Non-ABI methods must not have arguments defined');
                        if (!equalTypes(this.currentSubroutine.returns.type, StackType.void))
                            throw Error('Non-ABI methods must return void');
                        this.currentSubroutine.nonAbi[decoratorFunction].push(oc);
                    }
                    else
                        throw Error(`Missing OnComplete in decorator ${d.getText()}`);
                    break;
                default:
                    throw Error(`Unknown decorator ${d.getText()}`);
            }
        });
        const { allows, nonAbi } = this.currentSubroutine;
        if (nonAbi.call.length + nonAbi.create.length > 0) {
            if (allows.call.length + allows.create.length > 0) {
                throw Error('Cannot mix @allow and @nonABIRouterFallback decorators');
            }
            this.processSubroutine(node);
            return;
        }
        if (allows.create.length + allows.call.length === 0 && bareAction === false) {
            allows.call.push('NoOp');
        }
        this.processRoutableMethod(node);
    }
    processBlockStatement(node) {
        node.getStatements().forEach((s) => {
            this.processNode(s);
        });
    }
    processReturnStatement(node) {
        this.addSourceComment(node);
        if (this.currentForEachLabel) {
            this.pushVoid(node, `b ${this.currentForEachLabel}_end`);
            return;
        }
        const returnType = this.currentSubroutine.returns.type;
        if (typeInfoToABIString(returnType) === 'void') {
            if (node.getExpression() &&
                this.currentSubroutine.node.isKind(ts.SyntaxKind.MethodDeclaration) &&
                this.currentSubroutine.node.getReturnTypeNode()?.getType() === undefined) {
                throw Error(`TEALScript does not support implicit return types. Please add a return type to ${this.currentSubroutine.name}`);
            }
            this.pushVoid(node, 'retsub');
            return;
        }
        this.typeHint = returnType;
        this.processNode(node.getExpression());
        typeComparison(this.lastType, returnType, true);
        this.pushVoid(node, `b *${this.currentSubroutine.name}*return`);
        this.typeHint = undefined;
    }
    fixBitWidth(node, desiredWidth) {
        if (desiredWidth === 64 && this.teal[this.currentProgram].at(-1).teal === 'itob')
            return;
        const lastTypeStr = typeInfoToABIString(this.lastType);
        const lastWidth = parseInt(lastTypeStr.match(/\d+/)?.[0] || '512', 10);
        if (lastTypeStr === 'bigint' || lastTypeStr.startsWith('unsafe')) {
            this.pushLines(node, `byte 0x${'FF'.repeat(desiredWidth / 8)}`, 'b&', `dup`, 'len', 'dup', `int ${desiredWidth / 8}`, '-', 'swap', 'substring3');
            return;
        }
        if (desiredWidth < lastWidth) {
            this.pushLines(node, `extract ${(lastWidth - desiredWidth) / 8} ${desiredWidth / 8}`);
            return;
        }
        this.pushLines(node, `byte 0x${'FF'.repeat(desiredWidth / 8)}`, 'b&');
        this.lastType = { kind: 'base', type: `uint${desiredWidth}` };
    }
    getStackTypeAfterFunction(fn) {
        const preType = this.lastType;
        const preTeal = this.teal[this.currentProgram].slice();
        const preLastComment = new Array(...this.lastSourceCommentRange);
        const preTypeHint = this.typeHint;
        fn();
        const type = this.lastType;
        this.lastType = preType;
        this.typeHint = preTypeHint;
        this.teal[this.currentProgram] = preTeal;
        this.lastSourceCommentRange = preLastComment;
        return type;
    }
    getStackTypeFromNode(node) {
        return this.getStackTypeAfterFunction(() => this.processNode(node));
    }
    isBinaryExpression(node) {
        if (node.isKind(ts.SyntaxKind.BinaryExpression)) {
            return true;
        }
        if (node.isKind(ts.SyntaxKind.ParenthesizedExpression)) {
            return this.isBinaryExpression(node.getExpression());
        }
        return false;
    }
    usingValue(node) {
        const parent = node.getParentOrThrow();
        if (parent.isKind(ts.SyntaxKind.ForStatement)) {
            if (node.getStart() === parent.getIncrementor()?.getStart())
                return false;
        }
        if (parent.isKind(ts.SyntaxKind.ParenthesizedExpression))
            return this.usingValue(parent);
        if (parent.isKind(ts.SyntaxKind.ExpressionStatement))
            return false;
        if (parent.isKind(ts.SyntaxKind.Block))
            return false;
        return true;
    }
    processBinaryExpression(node, processAssignmentOp = false) {
        const leftNode = node.getLeft();
        const rightNode = node.getRight();
        let prevTypeHint = this.typeHint;
        if (node.getOperatorToken().getText() === '=') {
            prevTypeHint = undefined;
            this.addSourceComment(node);
            const leftType = this.getStackTypeFromNode(leftNode);
            this.typeHint = leftType;
            if (leftNode.isKind(ts.SyntaxKind.Identifier)) {
                const name = leftNode.getText();
                const processedFrame = this.processFrame(leftNode, name, false);
                const target = this.localVariables[processedFrame.name];
                this.processNode(rightNode);
                if (this.usingValue(node)) {
                    this.pushVoid(node, 'dup');
                }
                const currentArgs = this.currentSubroutine.args;
                if (currentArgs.find((s) => s.name === name && isArrayType(s.type))) {
                    throw Error('Mutating argument array is not allowed. Create a new variable using the "clone()" method to create a deep copy first.');
                }
                this.pushVoid(node, `frame_bury ${target.index} // ${name}: ${target.typeString}`);
            }
            else if (leftNode.isKind(ts.SyntaxKind.ElementAccessExpression)) {
                this.processExpressionChain(leftNode, rightNode);
                if (this.usingValue(node)) {
                    this.pushVoid(node, `load ${compilerScratch.assignmentValue}`);
                }
            }
            else if (leftNode.isKind(ts.SyntaxKind.PropertyAccessExpression)) {
                const isStorageValue = leftNode
                    .getFirstChild()
                    ?.getType()
                    .getText()
                    .match(/(Box|LocalState|GlobalState)Value/);
                if (isStorageValue) {
                    this.handleStorageAction({
                        node: leftNode,
                        action: 'set',
                        newValue: rightNode,
                    });
                }
                else
                    this.processExpressionChain(leftNode, rightNode);
                if (this.usingValue(node)) {
                    this.pushVoid(node, `load ${compilerScratch.assignmentValue}`);
                }
            }
            this.typeHint = prevTypeHint;
            return;
        }
        let operator = node
            .getOperatorToken()
            .getText()
            .replace('>>', 'shr')
            .replace('<<', 'shl')
            .replace('===', '==')
            .replace('!==', '!=')
            .replace('**', 'exp');
        let updateValue = false;
        if (['+=', '-=', '*=', '/='].includes(operator)) {
            if (processAssignmentOp === false) {
                this.addSourceComment(node);
                const isStorageExpr = leftNode
                    .getFirstChild()
                    ?.getType()
                    .getText()
                    .match(/(Scratch|Box|LocalState|GlobalState)Value/);
                const isExprChain = leftNode.isKind(ts.SyntaxKind.ElementAccessExpression) ||
                    leftNode.isKind(ts.SyntaxKind.PropertyAccessExpression);
                if (!isStorageExpr && isExprChain && this.getTypeInfo(leftNode.getFirstChild().getType()).kind !== 'base') {
                    this.processExpressionChain(leftNode, node);
                    if (this.usingValue(node)) {
                        this.pushLines(node, `load ${compilerScratch.assignmentValue}`);
                        this.lastType = this.getTypeInfo(rightNode.getType());
                    }
                    return;
                }
                updateValue = true;
            }
            operator = operator.replace('=', '');
        }
        if (['&&', '||'].includes(operator)) {
            this.processLogicalExpression(node);
            return;
        }
        const rightType = this.getStackTypeFromNode(rightNode);
        const leftType = this.getStackTypeFromNode(leftNode);
        const leftTypeStr = typeInfoToABIString(leftType);
        const rightTypeStr = typeInfoToABIString(rightType);
        if (!isNumeric(leftType) &&
            !leftTypeStr.match(/\d+$/) &&
            leftTypeStr !== 'bigint' &&
            (operator.startsWith('<') || operator.startsWith('>'))) {
            throw Error('TEALScript only supports number comparison. If you want to compare these values as numbers, use btobigint');
        }
        const isMathOp = ['+', '-', '*', '/', '%', 'exp', '|', '&', '^'].includes(operator);
        if ((isMathOp && leftTypeStr.startsWith('ufixed')) || rightTypeStr.startsWith('ufixed')) {
            throw Error('ufixed math is not supported in TEALScript');
        }
        if (leftNode.getType().isNumberLiteral()) {
            this.processNumericLiteralWithType(leftNode, rightType);
        }
        else
            this.processNode(leftNode);
        if (rightNode.getType().isNumberLiteral()) {
            this.processNumericLiteralWithType(rightNode, leftType);
        }
        else
            this.processNode(rightNode);
        if (operator === '+' &&
            (isBytes(leftType) ||
                (leftType.kind === 'staticArray' && equalTypes(leftType.base, { kind: 'base', type: 'byte' })))) {
            this.push(node.getOperatorToken(), 'concat', StackType.bytes);
            if (updateValue)
                this.updateValue(leftNode);
            return;
        }
        if (operator === 'exp' && leftTypeStr !== 'uint64' && !isSmallNumber(leftType)) {
            throw new Error(`Exponent operator only supported for uintN <= 64, got ${leftTypeStr} and ${rightTypeStr}`);
        }
        if ((leftTypeStr.match(/\d+$/) || leftTypeStr === 'bigint') &&
            !isNumeric(leftType) &&
            !isSmallNumber(leftType) &&
            (operator === '==' || operator === '!=' || operator.startsWith('<') || operator.startsWith('>'))) {
            this.push(node, `b${operator}`, { kind: 'base', type: 'bool' });
        }
        else if (isMathOp && leftTypeStr.match(/\d+$/) && !isSmallNumber(leftType) && !isNumeric(leftType)) {
            this.push(node.getOperatorToken(), `b${operator}`, { kind: 'base', type: `unsafe ${leftTypeStr}` });
        }
        else if (isMathOp && leftTypeStr === 'bigint') {
            this.push(node.getOperatorToken(), `b${operator}`, leftType);
        }
        else {
            this.push(node.getOperatorToken(), operator, leftType);
        }
        if (isMathOp && !isNumeric(leftType) && !leftTypeStr.startsWith('ufixed64') && leftTypeStr !== 'bigint') {
            this.lastType = { kind: 'base', type: `unsafe ${leftTypeStr}` };
        }
        if (leftTypeStr.startsWith('unsafe') || rightTypeStr.startsWith('unsafe')) {
            typeComparison({ kind: 'base', type: leftTypeStr.replace('unsafe ', '') }, { kind: 'base', type: rightTypeStr.replace('unsafe ', '') });
            if (isMathOp)
                this.lastType = { kind: 'base', type: `unsafe ${leftTypeStr.replace(/unsafe /g, '')}` };
        }
        else if (!leftNode.getType().isNumberLiteral() && !rightNode.getType().isNumberLiteral()) {
            typeComparison(leftType, rightType);
        }
        if (updateValue) {
            if (this.usingValue(node))
                this.pushLines(node, 'dup', `store ${compilerScratch.assignmentValue}`);
            this.updateValue(leftNode);
            if (this.usingValue(node))
                this.pushLines(node, `load ${compilerScratch.assignmentValue}`);
            this.lastType = this.getTypeInfo(rightNode.getType());
        }
        if (operator === '==' || operator === '!=' || operator.startsWith('<') || operator.startsWith('>')) {
            this.lastType = { kind: 'base', type: 'bool' };
        }
    }
    processLogicalExpression(node) {
        this.processNode(node.getLeft());
        const type = this.lastType;
        let label;
        if (node.getOperatorToken().getText() === '&&') {
            label = `*skip_and${this.andCount}`;
            this.andCount += 1;
            this.pushVoid(node.getOperatorToken(), 'dup');
            this.pushVoid(node.getOperatorToken(), `bz ${label}`);
        }
        else if (node.getOperatorToken().getText() === '||') {
            label = `*skip_or${this.orCount}`;
            this.orCount += 1;
            this.pushVoid(node.getOperatorToken(), 'dup');
            this.pushVoid(node.getOperatorToken(), `bnz ${label}`);
        }
        this.processNode(node.getRight());
        this.push(node.getOperatorToken(), node.getOperatorToken().getText(), StackType.uint64);
        this.pushVoid(node.getOperatorToken(), `${label}:`);
        this.lastType = type;
    }
    processIdentifier(node) {
        // should only be true when calling getStackTypeFromNode
        if (node.getText() === 'globals') {
            this.lastType = { kind: 'base', type: 'globals' };
            return;
        }
        const type = node.getType();
        if (type.isStringLiteral()) {
            this.push(node, `byte "${type.getLiteralValueOrThrow()}"`, StackType.bytes);
            return;
        }
        if (type.isNumberLiteral()) {
            this.push(node, `int ${type.getLiteralValueOrThrow()}`, StackType.uint64);
            return;
        }
        // Lookup const definition
        const defNode = node.getDefinitionNodes()[0];
        const inClass = defNode
            .getAncestors()
            .map((a) => a.getKind())
            .includes(ts.SyntaxKind.ClassDeclaration);
        /** True if defined in a function outside of a class */
        const inFunction = defNode
            .getAncestors()
            .map((a) => a.getKind())
            .includes(ts.SyntaxKind.FunctionDeclaration);
        // This is true when we are in a non-class function and the identifier is a function parameter
        const isFunctionParam = defNode.getParent()?.isKind(ts.SyntaxKind.FunctionDeclaration);
        if (!inClass && !isFunctionParam && !inFunction) {
            if (!defNode.isKind(ts.SyntaxKind.VariableDeclaration))
                throw Error();
            this.processNode(defNode.getInitializerOrThrow());
            return;
        }
        const processedFrame = this.processFrame(node, node.getText(), true);
        if (processedFrame.accessors.length > 0) {
            this.processParentArrayAccess(node, processedFrame.accessors, node);
        }
    }
    processNewExpression(node) {
        (node.getArguments() || []).forEach((a) => {
            this.processNode(a);
        });
        this.lastType = this.getTypeInfo(node.getExpression().getType());
    }
    fixByteWidth(node, desiredWidth) {
        const { lastType } = this;
        if (isBytes(lastType)) {
            this.pushLines(node, `byte 0x${'00'.repeat(desiredWidth)}`, 'concat', 'dup', `extract ${desiredWidth} 0`, 'byte 0x', 'b==', 'assert', `extract 0 ${desiredWidth}`);
            return;
        }
        const lastWidth = parseInt(typeInfoToABIString(lastType).match(/\d+/)[0], 10);
        if (lastWidth > desiredWidth) {
            this.pushLines(node, `extract 0 ${desiredWidth}`);
        }
        else if (lastWidth < desiredWidth) {
            this.pushLines(node, `byte 0x${'00'.repeat(desiredWidth - lastWidth)}`, 'concat');
        }
    }
    processTypeCast(node) {
        const expr = node.getExpression();
        if (expr.getType().isNumberLiteral()) {
            this.processNumericLiteralWithType(expr, this.getTypeInfo(node.getTypeNode().getType()));
            return;
        }
        const prevTypeHint = this.typeHint;
        this.typeHint = this.getTypeInfo(node.getTypeNode().getType());
        const { typeHint } = this;
        const typeStr = typeInfoToABIString(typeHint);
        if (TXN_TYPES.includes(typeStr)) {
            const lastTypeStr = typeInfoToABIString(this.getTypeInfo(expr.getType()));
            if (lastTypeStr !== typeStr && lastTypeStr !== 'txn') {
                throw new Error(`Cannot cast ${lastTypeStr} to ${typeStr}`);
            }
            this.processNode(expr);
            this.pushLines(node, 'dup', 'gtxns TypeEnum', `int ${typeStr}`, '==');
            this.pushVoid(node, 'assert', `failed to cast ${expr.getText()} to ${typeStr}`);
            this.lastType = typeHint;
            return;
        }
        if (expr.isKind(ts.SyntaxKind.StringLiteral)) {
            const width = parseInt(typeStr.match(/\d+/)[0], 10);
            const str = expr.getLiteralText();
            if (str.length > width)
                throw new Error(`String literal too long for ${typeStr}`);
            const padBytes = width - str.length;
            const hex = Buffer.from(str).toString('hex');
            const paddedHex = hex + '00'.repeat(padBytes);
            this.push(node, `byte 0x${paddedHex} // "${str}"`, typeHint);
            return;
        }
        this.processNode(node.getExpression());
        if (typeStr.match(/byte\[\d+\]$/)) {
            const typeWidth = parseInt(typeStr.match(/\d+/)[0], 10);
            this.fixByteWidth(node, typeWidth);
        }
        if (typeInfoToABIString(this.lastType) === 'any') {
            this.lastType = typeHint;
            return;
        }
        if ((typeStr.match(/uint\d+$/) || typeStr.match(/ufixed\d+x\d+$/)) &&
            typeStr !== typeInfoToABIString(this.lastType)) {
            if (equalTypes(typeHint, StackType.uint64)) {
                if (!isSmallNumber(this.lastType)) {
                    this.overflowCheck(node, 64);
                    this.fixBitWidth(node, 64);
                    this.push(node, 'btoi', StackType.uint64);
                }
                else
                    this.lastType = StackType.uint64;
                return;
            }
            // If going from uint64
            if (equalTypes(this.lastType, StackType.uint64)) {
                // itob it only if its bigger
                if (!isSmallNumber(typeHint))
                    this.pushVoid(node, 'itob');
                // if going from a small int to a bigger int
            }
            else if (isSmallNumber(this.lastType) && !isSmallNumber(typeHint)) {
                this.pushLines(node, 'itob');
                // going from a big into a smaller int
            }
            else if (!isSmallNumber(this.lastType) && isSmallNumber(typeHint)) {
                const width = parseInt(typeStr.match(/\d+/)[0], 10);
                this.overflowCheck(node, width);
                this.fixBitWidth(node, width);
                this.push(node, 'btoi', typeHint);
                return;
            }
            this.lastType = { kind: 'base', type: `unsafe ${typeStr}` };
            return;
        }
        this.lastType = typeHint;
        this.typeHint = prevTypeHint;
    }
    processVariableDeclaration(node) {
        node.getDeclarations().forEach((d) => {
            const typeNode = d.getTypeNode();
            this.typeHint = typeNode === undefined ? undefined : this.getTypeInfo(typeNode.getType());
            this.processNode(d);
            this.typeHint = undefined;
        });
    }
    /**
     * Saves information about storage access such as the key (and account if local storage) to the frame
     *
     * @param node The node that is saving storage access in a variable
     * @param name The name of the new variable
     * @param storageExpression The expression for accessing the storage property
     * @param type The value type
     * @param accessors If accessing an array, save the accessors used (ie. if `this.myArrays('foo').value[0][1]` then save [0, 1])
     */
    initializeStorageFrame(node, name, storageExpression, type, accessors) {
        this.localVariables[name] = {
            accessors,
            storageExpression,
            type,
            typeString: typeInfoToABIString(type),
        };
        // Get information about the storage access and ensure there are keys we need to save
        const storageName = getStorageName(storageExpression);
        const storageProp = this.storageProps[storageName];
        const expr = storageExpression.getExpression();
        if (!expr.isKind(ts.SyntaxKind.CallExpression))
            return;
        const exprArgs = expr.getArguments();
        // Save the key to the frame. For local storage this will be the second argument, for global and box storage it will be the first argument
        const argLength = exprArgs.length;
        const keyNode = exprArgs[argLength === 2 ? 1 : 0];
        // If the storage object has a key (any GlobalStateMap, LocalStateMap, and BoxMap)
        if (keyNode !== undefined && !keyNode.isKind(ts.SyntaxKind.StringLiteral) && !keyNode.getType().isNumberLiteral()) {
            this.addSourceComment(node, true);
            // Add the prefix to the given key if it exists
            if (storageProp.prefix) {
                const hex = Buffer.from(storageProp.prefix).toString('hex');
                this.pushVoid(keyNode, `byte 0x${hex} // "${storageProp.prefix}"`);
            }
            this.processNode(keyNode);
            // Ensure the key is properly encoded (except for bytes which are not ABI encoded)
            if (!equalTypes(storageProp.keyType, StackType.bytes)) {
                this.checkEncoding(keyNode, this.lastType);
            }
            if (storageProp.prefix)
                this.pushVoid(keyNode, 'concat');
            const keyFrameName = `storage key//${name}`;
            // Save the map key to the frame
            this.pushVoid(keyNode, `frame_bury ${this.frameIndex} // ${keyFrameName}`);
            this.localVariables[keyFrameName] = {
                index: this.frameIndex,
                type: StackType.uint64,
                typeString: 'uint64',
            };
            this.frameIndex += 1;
            // Save the name of the storage key frame in the variable frame object
            this.localVariables[name].storageKeyFrame = keyFrameName;
        }
        // If we are saving access for local storage, we need to save the account to the frame as well
        if (storageProp.type === 'local') {
            const accountNode = exprArgs[0];
            const accountFrameName = `storage account//${name}`;
            this.addSourceComment(node, true);
            // Save the account in the frame
            this.processNode(accountNode);
            this.pushVoid(accountNode, `frame_bury ${this.frameIndex} // ${accountFrameName}`);
            this.localVariables[accountFrameName] = {
                index: this.frameIndex,
                type: StackType.uint64,
                typeString: 'uint64',
            };
            this.frameIndex += 1;
            // Save the name of the storage frame in the variable frame object
            this.localVariables[name].storageAccountFrame = accountFrameName;
        }
    }
    processVariableDeclarator(node) {
        if (node.getType().isStringLiteral() || node.getType().isNumberLiteral())
            return;
        const name = node.getNameNode().getText();
        if (node.getInitializer()) {
            const initializerType = this.getTypeInfo(node.getType());
            const initializerTypeString = typeInfoToABIString(initializerType);
            let lastFrameAccess;
            const isArray = isArrayType(initializerType);
            if (node.getInitializer().isKind(ts.SyntaxKind.Identifier) &&
                (isArray || MULTI_OUTPUT_TYPES.includes(initializerTypeString))) {
                lastFrameAccess = node.getInitializer().getText();
                this.localVariables[name] = {
                    framePointer: lastFrameAccess,
                    type: initializerType,
                    typeString: node.getType()?.getText().replace(/\n/g, ' ') || typeInfoToABIString(initializerType),
                };
                return;
            }
            const init = node.getInitializer();
            if (init?.isKind(ts.SyntaxKind.ElementAccessExpression) && isArray) {
                const accessChain = this.getAccessChain(init);
                lastFrameAccess = accessChain[0].getExpression().getText();
                // Only add source comments if there will be generated TEAL
                if (accessChain.find((e) => e.getArgumentExpression()?.getType().isNumberLiteral())) {
                    this.addSourceComment(node);
                }
                const accessors = accessChain.map((e, i) => {
                    if (e.getArgumentExpression()?.getType().isNumberLiteral())
                        return e.getArgumentExpression();
                    if (e.getArgumentExpression()?.getType().isNumberLiteral()) {
                        this.push(e.getArgumentExpression(), `int ${e.getArgumentExpression().getText()}`, StackType.uint64);
                    }
                    else
                        this.processNode(e.getArgumentExpression());
                    const accName = `accessor//${i}//${name}`;
                    this.pushVoid(node.getInitializer(), `frame_bury ${this.frameIndex} // accessor: ${accName}`);
                    this.localVariables[accName] = {
                        index: this.frameIndex,
                        type: StackType.uint64,
                        typeString: 'uint64',
                    };
                    this.frameIndex += 1;
                    return accName;
                });
                if (lastFrameAccess.startsWith('this.')) {
                    if (!accessChain[0].getExpression().isKind(ts.SyntaxKind.PropertyAccessExpression)) {
                        throw new Error('Expected call expression');
                    }
                    this.initializeStorageFrame(node, name, accessChain[0].getExpression(), initializerType, accessors);
                }
                else {
                    this.localVariables[name] = {
                        accessors,
                        framePointer: lastFrameAccess,
                        type: initializerType,
                        typeString: node.getType()?.getText().replace(/\n/g, ' ') || typeInfoToABIString(initializerType),
                    };
                }
                if (node.getTypeNode())
                    typeComparison(this.lastType, this.getTypeInfo(node.getTypeNode().getType()));
                return;
            }
            const isStorageValue = init
                ?.getFirstChild()
                ?.getType()
                .getText()
                .match(/(Box|LocalState|GlobalState)Value/);
            if (init?.isKind(ts.SyntaxKind.PropertyAccessExpression) && isStorageValue && isArray) {
                this.initializeStorageFrame(node, name, init, initializerType);
                if (node.getTypeNode())
                    typeComparison(this.storageProps[getStorageName(init)].valueType, this.getTypeInfo(node.getTypeNode().getType()));
                return;
            }
            if (init?.isKind(ts.SyntaxKind.PropertyAccessExpression) && isArray) {
                lastFrameAccess = init.getExpression().getText();
                const type = this.getStackTypeFromNode(init.getExpression());
                if (isArray) {
                    const index = Object.keys(getObjectTypes(type)).indexOf(init.getNameNode().getText());
                    if (lastFrameAccess.startsWith('this.')) {
                        const initExpr = init.getExpression();
                        if (!initExpr.isKind(ts.SyntaxKind.PropertyAccessExpression))
                            throw new Error('Expected call expression');
                        this.initializeStorageFrame(node, name, initExpr, initializerType, [
                            ts.createWrappedNode(stringToExpression(index.toString())),
                        ]);
                    }
                    else {
                        this.localVariables[name] = {
                            accessors: [ts.createWrappedNode(stringToExpression(index.toString()))],
                            framePointer: lastFrameAccess,
                            type: initializerType,
                            typeString: node.getType()?.getText().replace(/\n/g, ' ') || typeInfoToABIString(initializerType),
                        };
                    }
                    if (node.getTypeNode())
                        typeComparison(initializerType, this.getTypeInfo(node.getTypeNode().getType()));
                    return;
                }
            }
            this.addSourceComment(node);
            const hint = node.getTypeNode() ? this.getTypeInfo(node.getTypeNode().getType()) : undefined;
            if (init?.getType().isNumberLiteral() && this.typeHint) {
                this.processNumericLiteralWithType(init, this.typeHint);
            }
            else {
                this.typeHint = hint;
                this.processNode(init);
                if (hint) {
                    if (this.lastType.kind === 'base' && this.lastType.type.startsWith('unsafe')) {
                        this.checkEncoding(init, this.lastType);
                    }
                    typeComparison(this.lastType, hint);
                }
            }
            const type = hint || this.lastType;
            let typeString = node.getTypeNode()?.getText().replace(/\n/g, ' ') || typeInfoToABIString(type);
            const parent = node.getParentOrThrow();
            let isLet = false;
            if (parent.isKind(ts.SyntaxKind.VariableDeclarationList)) {
                isLet = parent.getFlags() === ts.NodeFlags.Let;
            }
            if (isLet && type.kind === 'base' && type.type.match(/^(ufixed|uint)(?!64)/)) {
                type.type = `unsafe ${type.type}`;
                typeString = `unsafe ${typeString}`;
            }
            this.localVariables[name] = {
                index: this.frameIndex,
                type,
                typeString,
            };
            if (MULTI_OUTPUT_TYPES.includes(typeInfoToABIString(type)))
                return;
            this.pushVoid(node, `frame_bury ${this.frameIndex} // ${name}: ${typeString}`);
            this.frameIndex += 1;
        }
        else {
            if (!node.getTypeNode())
                throw new Error('Uninitialized variables must have a type');
            this.localVariables[name] = {
                index: this.frameIndex,
                type: this.getTypeInfo(node.getTypeNode().getType()),
                typeString: node.getTypeNode().getText().replace(/\n/g, ' '),
            };
            this.frameIndex += 1;
        }
    }
    processExpressionStatement(node) {
        this.processNode(node.getExpression());
    }
    isDynamicArrayOfStaticType(type) {
        return type.kind === 'dynamicArray' && !this.isDynamicType(type.base);
    }
    processConditional(node) {
        this.addSourceComment(node);
        this.processNode(node);
        if (!isNumeric(this.lastType) && typeInfoToABIString(this.lastType) !== 'bool') {
            this.pushLines(node, 'byte 0x', 'b!=');
        }
    }
    processIfStatement(node, elseIfCount = 0, parentIf = (this.ifCount += 1)) {
        let labelPrefix;
        const thisIf = `*if${parentIf}`;
        if (elseIfCount === 0) {
            labelPrefix = thisIf;
            this.pushVoid(node, `// ${labelPrefix}_condition`);
        }
        else {
            labelPrefix = `${thisIf}_elseif${elseIfCount}`;
            this.pushVoid(node, `${labelPrefix}_condition:`);
        }
        this.processConditional(node.getExpression());
        const elseStatement = node.getElseStatement();
        if (elseStatement === undefined) {
            this.pushVoid(node, `bz ${thisIf}_end`);
            this.pushVoid(node, `// ${labelPrefix}_consequent`);
            this.processNode(node.getThenStatement());
        }
        else if (elseStatement?.isKind(ts.SyntaxKind.IfStatement)) {
            this.pushVoid(node, `bz ${thisIf}_elseif${elseIfCount + 1}_condition`);
            this.pushVoid(node, `// ${labelPrefix}_consequent`);
            this.processNode(node.getThenStatement());
            this.pushVoid(node, `b ${thisIf}_end`);
            this.processIfStatement(elseStatement, elseIfCount + 1, parentIf);
        }
        else {
            this.pushVoid(node, `bz ${thisIf}_else`);
            this.pushVoid(node, `// ${labelPrefix}_consequent`);
            this.processNode(node.getThenStatement());
            this.pushVoid(node, `b ${thisIf}_end`);
            this.pushVoid(node, `${thisIf}_else:`);
            this.processNode(elseStatement);
        }
        if (elseIfCount === 0) {
            this.pushVoid(node, `${thisIf}_end:`);
        }
    }
    processUnaryExpression(node) {
        this.processNode(node.getOperand());
        switch (node.getOperatorToken()) {
            case ts.SyntaxKind.ExclamationToken:
                this.pushVoid(node.getOperand(), '!');
                break;
            case ts.SyntaxKind.TildeToken:
                if (isNumeric(this.lastType) || isSmallNumber(this.lastType))
                    this.pushVoid(node.getOperand(), '~');
                else
                    this.pushVoid(node.getOperand(), 'b~');
                break;
            default:
                throw new Error(`Unsupported unary operator ${ts.SyntaxKind[node.getOperatorToken()]}`);
        }
    }
    processPropertyDefinition(node) {
        const init = node.getInitializer();
        if (init === undefined)
            throw Error();
        if (node.getNameNode().getText() === 'programVersion') {
            if (!init.isKind(ts.SyntaxKind.NumericLiteral))
                throw Error('programVersion must be a number');
            this.programVersion = parseInt(init.getLiteralText(), 10);
            if (this.programVersion < 8)
                throw Error('programVersion must be >= 8');
            return;
        }
        if (init.isKind(ts.SyntaxKind.CallExpression) &&
            ['BoxMap', 'GlobalStateMap', 'LocalStateMap', 'BoxKey', 'GlobalStateKey', 'LocalStateKey'].includes(init.getExpression().getText())) {
            if (this.currentProgram === 'lsig') {
                throw Error('Logic signatures cannot have stateful properties');
            }
            let props;
            const klass = init.getExpression().getText();
            const type = klass.toLocaleLowerCase().replace('state', '').replace('map', '').replace('key', '');
            const typeArgs = init.getTypeArguments();
            if (typeArgs === undefined) {
                throw new Error('Type arguments must be specified for storage properties');
            }
            if (klass.includes('Map')) {
                if (typeArgs.length !== 2)
                    throw new Error(`Expected 2 type arguments for ${klass}`);
                props = {
                    name: node.getName(),
                    type,
                    keyType: this.getTypeInfo(typeArgs[0].getType()),
                    valueType: this.getTypeInfo(typeArgs[1].getType()),
                    initNode: init,
                };
            }
            else {
                if (typeArgs.length !== 1)
                    throw new Error(`Expected a type argument for ${klass}`);
                props = {
                    name: node.getName(),
                    type,
                    keyType: StackType.bytes,
                    valueType: this.getTypeInfo(typeArgs[0].getType()),
                    initNode: init,
                };
            }
            if (props.type === 'box' && this.isDynamicType(props.valueType)) {
                props.dynamicSize = true;
            }
            const initArgs = init.getArguments();
            if (initArgs[0] !== undefined) {
                if (!initArgs[0].isKind(ts.SyntaxKind.ObjectLiteralExpression))
                    throw new Error('Expected object literal');
                initArgs[0].getProperties().forEach((p) => {
                    if (!p.isKind(ts.SyntaxKind.PropertyAssignment))
                        throw new Error();
                    const name = p.getNameNode()?.getText();
                    const propInit = p.getInitializer();
                    switch (name) {
                        case 'key':
                            if (klass.includes('Map'))
                                throw new Error(`${name} only applies to storage keys`);
                            if (!propInit?.isKind(ts.SyntaxKind.StringLiteral))
                                throw new Error('Storage key must be string');
                            props.key = propInit.getLiteralText();
                            break;
                        case 'dynamicSize':
                            if (props.type !== 'box')
                                throw new Error(`${name} only applies to box storage`);
                            if (!this.isDynamicType(props.valueType))
                                throw new Error(`${name} only applies to dynamic types`);
                            props.dynamicSize = propInit.getText() === 'true';
                            break;
                        case 'prefix':
                            if (!klass.includes('Map'))
                                throw new Error(`${name} only applies to storage maps`);
                            if (!propInit.isKind(ts.SyntaxKind.StringLiteral))
                                throw new Error('Storage prefix must be string');
                            props.prefix = propInit.getLiteralText();
                            break;
                        case 'maxKeys':
                            if (!klass.includes('Map'))
                                throw new Error(`${name} only applies to storage maps`);
                            if (!propInit.isKind(ts.SyntaxKind.NumericLiteral))
                                throw new Error('Storage maxKeys must be number');
                            props.maxKeys = parseInt(propInit.getLiteralText(), 10);
                            break;
                        case 'allowPotentialCollisions':
                            if (propInit?.compilerNode.kind !== ts.SyntaxKind.TrueKeyword &&
                                propInit?.compilerNode.kind !== ts.SyntaxKind.FalseKeyword) {
                                throw new Error('Storage allowPotentialCollisions must be boolean');
                            }
                            props.allowPotentialCollisions = propInit?.compilerNode.kind === ts.SyntaxKind.TrueKeyword;
                            break;
                        default:
                            throw new Error(`Unknown property ${name}`);
                    }
                });
            }
            if (!props.key && klass.includes('Key')) {
                props.key = node.getNameNode().getText();
            }
            if (klass.includes('StateMap') && !props.maxKeys)
                throw new Error('maxKeys must be specified for state maps');
            // If this is a state map
            if (klass.includes('Map') && props.allowPotentialCollisions !== true) {
                const prefixRequired = Object.keys(this.storageProps).find((propName) => {
                    const p = this.storageProps[propName];
                    // Only check the same storage type (box, local, global)
                    if (p.type !== type)
                        return false;
                    // If the existing prop is a key, make sure the length of the new key doesn't match the length of the existing key
                    if (p.key !== undefined) {
                        return this.isDynamicType(props.keyType) || p.key.length === this.getTypeLength(props.keyType);
                    }
                    return (p.keyType === props.keyType ||
                        this.isDynamicType(p.keyType) ||
                        this.getTypeLength(p.keyType) === this.getTypeLength(props.keyType));
                });
                if (prefixRequired) {
                    if (props.prefix === undefined)
                        throw Error(`Prefix must be defined for "${node
                            .getNameNode()
                            .getText()}" due to potential collision with "${prefixRequired}"`);
                    const collision = Object.keys(this.storageProps).find((propName) => {
                        const p = this.storageProps[propName];
                        // Only check the same storage type (box, local, global)
                        if (p.type !== type)
                            return false;
                        return p.key?.startsWith(props.prefix) || p.prefix === props.prefix;
                    });
                    if (collision) {
                        throw Error(`Storage prefix "${props.prefix}" collides with existing storage property "${collision}"`);
                    }
                }
                // If this is a state key
            }
            else if (props.allowPotentialCollisions !== true) {
                // Get potential a Map that collides with this key and doesn't have a prefix
                const prefixRequired = Object.keys(this.storageProps).find((propName) => {
                    const p = this.storageProps[propName];
                    // Only check the same storage type (box, local, global)
                    if (p.type !== type)
                        return false;
                    // Only check storage map
                    if (p.key !== undefined)
                        return false;
                    return (p.prefix === undefined &&
                        (this.isDynamicType(p.keyType) || this.getTypeLength(p.keyType) === this.getTypeLength(props.keyType)));
                });
                if (prefixRequired) {
                    throw Error(`"${node
                        .getNameNode()
                        .getText()}" has a potential key collision with "${prefixRequired}". "${prefixRequired}" must have a prefix or "${node
                        .getNameNode()
                        .getText()}" must have a different key name`);
                }
                const thisKey = props.key || node.getNameNode().getText();
                const collision = Object.keys(this.storageProps).find((propName) => {
                    const p = this.storageProps[propName];
                    // Only check the same storage type (box, local, global)
                    if (p.type !== type)
                        return false;
                    return p.key === thisKey || (p.prefix && thisKey.startsWith(p.prefix));
                });
                if (collision) {
                    throw Error(`Storage key for "${node
                        .getNameNode()
                        .getText()}" collides with existing storage property "${collision}". One of the names or prefixes must be changed`);
                }
            }
            this.storageProps[node.getNameNode().getText()] = props;
        }
        else if (init.isKind(ts.SyntaxKind.NewExpression) && init.getExpression().getText() === 'EventLogger') {
            if (this.currentProgram === 'lsig') {
                throw Error('Logic signatures cannot log events');
            }
            const initTypeArgs = init.getTypeArguments();
            if (!initTypeArgs[0].isKind(ts.SyntaxKind.TypeLiteral)) {
                throw Error(`EventLogger type argument must be a type literal`);
            }
            this.events[node.getNameNode().getText()] = {
                name: node.getNameNode().getText(),
                args: [],
                desc: node
                    .getJsDocs()
                    .map((d) => d.getCommentText())
                    .join(''),
                argTupleType: this.getTypeInfo(initTypeArgs[0].getType()),
            };
            const event = this.events[node.getNameNode().getText()];
            initTypeArgs[0].getProperties().forEach((p) => {
                const desc = p
                    .getJsDocs()
                    .map((d) => d.getCommentText())
                    .join();
                const name = p.getName();
                const type = this.getTypeInfo(p.getType());
                event.args.push({ name, type, desc });
            });
        }
        else if (init.isKind(ts.SyntaxKind.CallExpression) && init.getExpression().getText() === 'ScratchSlot') {
            if (init.getTypeArguments()?.length !== 1)
                throw Error('ScratchSlot must have one type argument ');
            if (init.getArguments()?.length !== 1)
                throw Error('ScratchSlot must have one argument');
            if (!init.getArguments()[0].isKind(ts.SyntaxKind.NumericLiteral))
                throw Error('ScratchSlot argument must be a literal number');
            const type = this.getTypeInfo(init.getTypeArguments()[0].getType());
            const name = node.getNameNode().getText();
            const slot = parseInt(init.getArguments()[0].getText(), 10);
            if (slot < 0 || slot > 200)
                throw Error('Scratch slot must be between 0 and 200 (inclusive). 201-256 is reserved for the compiler');
            this.scratch[name] = { type, slot, initNode: init };
        }
        else if (init.isKind(ts.SyntaxKind.CallExpression) && init.getExpression().getText() === 'DynamicScratchSlot') {
            if (init.getTypeArguments()?.length !== 1)
                throw Error('ScratchSlot must have one type argument ');
            const type = this.getTypeInfo(init.getTypeArguments()[0].getType());
            const name = node.getNameNode().getText();
            this.scratch[name] = { type, initNode: init };
        }
        else if (init.isKind(ts.SyntaxKind.CallExpression) && init.getExpression().getText() === 'TemplateVar') {
            if (init.getTypeArguments()?.length !== 1)
                throw Error('TemplateVar must have one type argument ');
            if (init.getArguments()[0] && !init.getArguments()[0].isKind(ts.SyntaxKind.NumericLiteral)) {
                throw Error('TemplateVar name argument must be a string literal');
            }
            const name = init.getArguments()[0]?.getText() || node.getNameNode().getText();
            const type = this.getTypeInfo(init.getTypeArguments()[0].getType());
            // TODO: Add slot argument, otherwise assign one automatically
            const slot = 200 + Object.keys(this.templateVars).length;
            this.scratch[node.getNameNode().getText()] = { slot, type, initNode: init };
            this.templateVars[node.getNameNode().getText()] = {
                type,
                name,
                initNode: init,
            };
        }
        else {
            throw new Error();
        }
    }
    getNumericLiteralValueString(node) {
        let value = '';
        if (node.isKind(ts.SyntaxKind.Identifier)) {
            const symbol = node.getSymbol()?.getAliasedSymbol() || node.getSymbolOrThrow();
            symbol.getDeclarations().forEach((d) => {
                if (d.isKind(ts.SyntaxKind.VariableDeclaration)) {
                    value = this.getNumericLiteralValueString(d.getInitializerOrThrow());
                }
            });
        }
        else
            return node.getText().replace(/_/g, '');
        if (value === '')
            throw Error();
        return value;
    }
    processNumericLiteralWithType(node, typeInfo) {
        const type = typeInfoToABIString(typeInfo);
        if (!node.getType().isNumberLiteral())
            throw Error();
        const textWithoutUnderscores = this.getNumericLiteralValueString(node);
        if (BigInt(textWithoutUnderscores.split('.')[0]) > BigInt(Number.MAX_SAFE_INTEGER)) {
            throw Error(`Number ${node.getText()} is too large for a number literal. Use Uint constructor with string")`);
        }
        if (type === 'uint64') {
            this.processNode(node);
            return;
        }
        if (type === 'bigint') {
            const value = Number(textWithoutUnderscores);
            let hex = value.toString(16);
            if (hex.length % 2)
                hex = `0${hex}`;
            this.push(node, `byte 0x${hex}`, typeInfo);
            return;
        }
        if (type.match(/ufixed\d+x\d+$/)) {
            const match = type.match(/\d+/g);
            const n = parseInt(match[0], 10);
            const m = parseInt(match[1], 10);
            const numDecimals = textWithoutUnderscores.match(/(?<=\.)\d+/)[0].length;
            if (numDecimals > m)
                throw Error(`Value ${node.getText()} cannot be represented as ${type}. A more precise type is required.`);
            const valueStr = textWithoutUnderscores.replace('.', '') + '0'.repeat(m - numDecimals);
            const fixedValue = BigInt(valueStr);
            if (isSmallNumber(typeInfo)) {
                this.push(node, `int ${fixedValue}`, typeInfo);
            }
            else
                this.push(node, `byte 0x${fixedValue.toString(16).padStart(n / 4, '00')}`, typeInfo);
            return;
        }
        if (type.match(/uint\d+$/)) {
            const width = Number(type.match(/\d+/)[0]);
            const value = Number(textWithoutUnderscores);
            const maxValue = 2 ** width - 1;
            if (value > maxValue) {
                throw Error(`Value ${value} is too large for ${type}. Max value is ${maxValue}`);
            }
            if (isSmallNumber(typeInfo))
                this.push(node, `int ${value}`, typeInfo);
            else
                this.push(node, `byte 0x${value.toString(16).padStart(width / 4, '0')}`, typeInfo);
        }
    }
    processLiteral(node) {
        if (node.compilerNode.kind === ts.SyntaxKind.StringLiteral) {
            const hex = Buffer.from(node.getLiteralText(), 'utf8').toString('hex');
            this.push(node, `byte 0x${hex} // "${node.getLiteralText()}"`, StackType.bytes);
        }
        else {
            const textWithoutUnderscores = this.getNumericLiteralValueString(node);
            if (BigInt(textWithoutUnderscores) > BigInt(Number.MAX_SAFE_INTEGER)) {
                throw Error(`Number ${node.getText()} is too large for a number literal. Use Uint64 constructor with string: Uint64("${textWithoutUnderscores}")`);
            }
            this.push(node, `int ${node.getText()}`, StackType.uint64);
        }
    }
    /**
     * Method for handling an expression chain that starts with `this`
     *
     * Note this method will delete elements from the chain as they are processed
     *
     * @param chain Expression chain to process
     * @param newValue New value to assign to the chain expression
     */
    processThisBase(chain, newValue) {
        // If this is a pendingGroup call (ie. `this.pendingGroup.submit()`)
        if (chain[0] &&
            chain[0].isKind(ts.SyntaxKind.PropertyAccessExpression) &&
            chain[0].getNameNode().getText() === 'pendingGroup') {
            if (!chain[1].isKind(ts.SyntaxKind.PropertyAccessExpression))
                throw Error(`Unsupported ${chain[1].getKindName()} ${chain[1].getText()}`);
            if (!chain[2].isKind(ts.SyntaxKind.CallExpression))
                throw Error(`Unsupported ${chain[2].getKindName()} ${chain[2].getText()}`);
            const methodName = chain[1].getNameNode().getText();
            if (chain[2].getArguments()[0]) {
                const { returnType, argTypes, name } = this.methodTypeArgsToTypes(chain[2].getTypeArguments());
                this.processTransaction(chain[2], methodName, chain[2].getArguments()[0], argTypes, returnType, name);
            }
            else if (methodName === 'submit') {
                this.pushVoid(chain[2], 'itxn_submit');
            }
            else
                throw new Error(`Unknown method ${chain[2].getText()}`);
            chain.splice(0, 3);
            return;
        }
        if (chain[0] &&
            chain[0].isKind(ts.SyntaxKind.PropertyAccessExpression) &&
            chain[0].getNameNode().getText() === 'txn' &&
            chain[1]?.isKind(ts.SyntaxKind.PropertyAccessExpression) &&
            chain[2]?.isKind(ts.SyntaxKind.PropertyAccessExpression) &&
            chain[1].getName() === 'applicationArgs' &&
            chain[2].getName() === 'length') {
            this.push(chain[2], 'txn NumAppArgs', StackType.uint64);
            chain.splice(0, 3);
            return;
        }
        // If accessing the txnGroup
        if (chain[0] &&
            chain[0].isKind(ts.SyntaxKind.PropertyAccessExpression) &&
            chain[0].getNameNode().getText() === 'txnGroup') {
            // If getting the group size
            if (chain[1] &&
                chain[1].isKind(ts.SyntaxKind.PropertyAccessExpression) &&
                chain[1].getNameNode().getText() === 'length') {
                this.push(chain[1], 'global GroupSize', StackType.uint64);
                chain.splice(0, 2);
                return;
            }
            // Otherwise this should be a group index
            if (!chain[1].isKind(ts.SyntaxKind.ElementAccessExpression))
                throw Error(`Unsupported ${chain[1].getKindName()} ${chain[1].getText()}`);
            this.processNode(chain[1].getArgumentExpression());
            this.lastType = { kind: 'base', type: 'txn' };
            chain.splice(0, 2);
            return;
        }
        // If accessing the inner txn group
        if (chain[0] &&
            chain[0].isKind(ts.SyntaxKind.PropertyAccessExpression) &&
            chain[0].getNameNode().getText() === 'lastInnerGroup') {
            // Otherwise this should be a group index
            if (!chain[1].isKind(ts.SyntaxKind.ElementAccessExpression))
                throw Error(`Unsupported ${chain[1].getKindName()} ${chain[1].getText()}`);
            const index = chain[1].getArgumentExpression()?.getType().getLiteralValue();
            if (index === undefined)
                throw Error('Inner group txn index must be a literal');
            this.processNode(chain[1].getArgumentExpression());
            this.lastType = { kind: 'base', type: 'gitxn' };
            chain.splice(0, 2);
            return;
        }
        // If this is a template variable
        if (chain[0].isKind(ts.SyntaxKind.PropertyAccessExpression) &&
            this.templateVars[chain[0].getNameNode().getText()]) {
            const propName = chain[0].getNameNode().getText();
            const { name, type } = this.templateVars[propName];
            let op = 'byte';
            if (isNumeric(type))
                op = 'int';
            this.push(chain[0], `${op} TMPL_${name}`, type);
            chain.splice(0, 1);
            return;
        }
        // If this is a scratch slot
        if (chain[0].isKind(ts.SyntaxKind.PropertyAccessExpression) && this.scratch[chain[0].getNameNode().getText()]) {
            const name = chain[0].getNameNode().getText();
            let slot;
            // If this is a dynamic scratch slot
            if (chain[1].isKind(ts.SyntaxKind.CallExpression) &&
                chain[2].isKind(ts.SyntaxKind.PropertyAccessExpression) &&
                chain[2].getName() === 'value') {
                this.processNode(chain[1].getArguments()[0]);
                typeComparison(this.lastType, StackType.uint64);
            }
            // else if this is a static scratch slot
            else if (chain[1].isKind(ts.SyntaxKind.PropertyAccessExpression) && chain[1].getName() === 'value') {
                slot = this.scratch[name].slot;
            }
            else {
                throw Error(`Invalid scratch expression ${chain[1].getText()}`);
            }
            let opcode;
            if (newValue !== undefined) {
                this.processNode(newValue);
                typeComparison(this.lastType, this.scratch[name].type);
                opcode = 'store';
            }
            else {
                opcode = 'load';
            }
            if (slot !== undefined) {
                opcode += ` ${slot}`;
            }
            else {
                opcode += 's';
            }
            this.push(chain[1], opcode, this.scratch[name].type);
            chain.splice(0, slot === undefined ? 3 : 2);
            return;
        }
        // If this is an event
        if (chain[0].isKind(ts.SyntaxKind.PropertyAccessExpression) && this.events[chain[0].getNameNode().getText()]) {
            const name = chain[0].getNameNode().getText();
            if (!this.currentSubroutine.events.includes(name))
                this.currentSubroutine.events.push(name);
            const { argTupleType } = this.events[name];
            if (!chain[1].isKind(ts.SyntaxKind.PropertyAccessExpression) || !chain[2].isKind(ts.SyntaxKind.CallExpression))
                throw Error(`Unsupported ${chain[1].getKindName()} ${chain[1].getText()}`);
            if (chain[1].getNameNode().getText() !== 'log')
                throw Error(`Unsupported event method ${chain[1].getNameNode().getText()}`);
            const argTypes = typeInfoToABIString(argTupleType)
                .replace(/asset/g, 'uint64')
                .replace(/account/g, 'address')
                .replace(/application/g, 'uint64');
            const signature = `${name}${argTypes}`;
            const selector = (0, js_sha512_1.sha512_256)(Buffer.from(signature)).slice(0, 8);
            this.typeHint = argTupleType;
            this.pushVoid(chain[2], `byte 0x${selector} // ${signature}`);
            this.processNode(chain[2].getArguments()[0]);
            this.pushVoid(chain[2], 'concat');
            this.pushVoid(chain[2], 'log');
            chain.splice(0, 3);
            return;
        }
        // If this is a storage property (ie. GlobalMap, BoxKey, etc.)
        if (chain[0].isKind(ts.SyntaxKind.PropertyAccessExpression) &&
            this.storageProps[chain[0].getNameNode().getText()]) {
            const name = chain[0].getNameNode().getText();
            const storageProp = this.storageProps[name];
            /**
             * Specifies whether this is a storage Map or LocalState, which means it's
             * always a call expression.
             */
            const isMapOrLocal = storageProp.key === undefined || storageProp.type === 'local';
            /** The index of the node that specifies which action to take. ie `.value` or `.delete()` */
            let actionNodeIndex = isMapOrLocal ? 2 : 1;
            if (chain[actionNodeIndex + 1] && chain[actionNodeIndex + 1].isKind(ts.SyntaxKind.CallExpression)) {
                actionNodeIndex += 1;
            }
            const actionNode = chain[actionNodeIndex];
            /** name of the action. ie "value" or "delete" */
            let action;
            if (actionNode.isKind(ts.SyntaxKind.PropertyAccessExpression))
                action = actionNode.getNameNode().getText();
            if (actionNode.isKind(ts.SyntaxKind.CallExpression)) {
                action = actionNode.getExpression().getNameNode().getText();
            }
            const getFullValue = actionNode.getText() === chain.at(-1)?.getText();
            // Don't get the box value if we can use box_replace or box_extract later
            if (action !== 'value' ||
                getFullValue ||
                storageProp.valueType.kind === 'base' ||
                !(storageProp.type === 'box' &&
                    !this.isDynamicType(storageProp.valueType) &&
                    !typeInfoToABIString(storageProp.valueType).match('bool'))) {
                this.handleStorageAction({
                    node: actionNode,
                    action: action.replace('value', 'get'),
                });
            }
            else
                this.lastType = storageProp.valueType;
            chain.splice(0, actionNodeIndex + 1);
            return;
        }
        // If `this.txn`, `this.app`, or `this.itxn`
        if (chain[0].isKind(ts.SyntaxKind.PropertyAccessExpression) &&
            ['txn', 'app', 'itxn'].includes(chain[0].getNameNode().getText())) {
            const op = chain[0].getNameNode().getText();
            // If the entire expression is simply `this.txn` which returns the current txn
            if (op === 'txn' && chain[1] === undefined) {
                this.push(chain[0], 'txn', { kind: 'base', type: 'txn' });
                chain.splice(0, 1);
                return;
            }
            // If the entire expression is simply `this.app` which returns the current app
            if (op === 'app' && chain[1] === undefined) {
                this.push(chain[0], 'txna Applications 0', ForeignType.Application);
                chain.splice(0, 1);
                return;
            }
            // If the expression is an app argument
            if (op === 'app') {
                // If the expression is `this.app.address`, then use `CurrentApplicationAddress` rather
                // than app_params_get (which would be handled later by processOpcodeImmediate if we didn't
                // return here)
                if (chain[1].isKind(ts.SyntaxKind.PropertyAccessExpression) && chain[1].getNameNode().getText() === 'address') {
                    this.push(chain[1], 'global CurrentApplicationAddress', ForeignType.Address);
                    chain.splice(0, 2);
                    return;
                }
                this.push(chain[0], 'txna Applications 0', ForeignType.Application);
                chain.splice(0, 1);
                return;
            }
            // Assume this is an param opcode (ie. `this.txn.sender` or `this.app.creator`)
            if (!chain[1].isKind(ts.SyntaxKind.PropertyAccessExpression))
                throw Error(`Unsupported ${chain[1].getKindName()} ${chain[1].getText()}`);
            this.processOpcodeImmediate(chain[0], this.getTypeInfo(chain[0].getNameNode().getType()), chain[1].getNameNode().getText(), false, true);
            chain.splice(0, 2);
            return;
        }
        if (chain[0].isKind(ts.SyntaxKind.PropertyAccessExpression) && chain[1].isKind(ts.SyntaxKind.CallExpression)) {
            const methodName = chain[0].getNameNode().getText();
            this.processCallExpression(chain[1]);
            chain.splice(0, 2);
        }
    }
    processCallExpression(node) {
        this.addSourceComment(node);
        const expr = node.getExpression();
        let methodName;
        if (expr?.isKind(ts.SyntaxKind.PropertyAccessExpression)) {
            methodName = expr.getNameNode().getText();
        }
        else if (expr?.isKind(ts.SyntaxKind.Identifier)) {
            methodName = expr.getText();
            // If this is a custom method
            if (this.customMethods[methodName] && this.customMethods[methodName].check(node)) {
                this.customMethods[methodName].fn(node);
                return;
            }
            // If this is an opcode
            if (langspec_json_1.default.Ops.map((o) => o.Name).includes(this.opcodeAliases[methodName] ?? methodName)) {
                this.processOpcode(node);
                return;
            }
            // If a txn method like sendMethodCall, sendPayment, etc.
            if (TXN_METHODS.includes(methodName)) {
                const { returnType, argTypes, name } = this.methodTypeArgsToTypes(node.getTypeArguments());
                this.processTransaction(node, methodName, node.getArguments()[0], argTypes, returnType, name);
                return;
            }
            if (this.subroutines.find((s) => s.name === methodName) === undefined) {
                const definition = expr.getDefinitionNodes()[0];
                if (!definition.isKind(ts.SyntaxKind.FunctionDeclaration))
                    throw Error();
                this.preProcessMethods([definition]);
                this.pendingSubroutines.push(definition);
            }
        }
        else
            throw new Error(`Invalid parent for call expression: ${expr?.getKindName()} ${expr?.getText()}`);
        const preArgsType = this.lastType;
        const subroutine = this.subroutines.find((s) => s.name === methodName);
        if (!subroutine)
            throw new Error(`Unknown subroutine ${methodName}`);
        new Array(...node.getArguments()).reverse().forEach((a, i) => {
            const prevTypeHint = this.typeHint;
            this.typeHint = subroutine.args[i].type;
            this.processNode(a);
            this.typeHint = prevTypeHint;
            if (this.lastType.kind === 'base' && this.lastType.type.startsWith('unsafe ')) {
                this.checkEncoding(a, this.lastType);
                if (isSmallNumber(this.lastType))
                    this.push(a, 'btoi', this.lastType);
            }
            typeComparison(this.lastType, subroutine.args[i].type);
        });
        this.lastType = preArgsType;
        const returnTypeStr = typeInfoToABIString(subroutine.returns.type);
        let returnType = subroutine.returns.type;
        if (returnTypeStr.match(/\d+$/) && !returnTypeStr.match(/^(uint|ufixed)64/)) {
            returnType = { kind: 'base', type: `unsafe ${returnTypeStr}` };
        }
        this.push(node, `callsub ${methodName}`, returnType);
        if (this.nodeDepth === 1 && !equalTypes(subroutine.returns.type, StackType.void))
            this.pushVoid(node, 'pop');
    }
    methodTypeArgsToTypes(typeArgs) {
        let argTypes = [];
        let name;
        if (typeArgs[0]?.isKind(ts.SyntaxKind.TupleType)) {
            argTypes = typeArgs[0].getElements().map((t) => {
                return this.getTypeInfo(t.getType());
            });
        }
        else if (typeArgs[0]) {
            const sig = typeArgs[0].getType().getCallSignatures()[0];
            argTypes = sig.getParameters().map((param) => this.getTypeInfo(param.getDeclarations()[0].getType()));
        }
        let returnType = StackType.void;
        if (typeArgs[0]?.isKind(ts.SyntaxKind.TypeQuery)) {
            const sig = typeArgs[0].getType().getCallSignatures()[0];
            name = sig.getDeclaration().getName();
            returnType = this.getTypeInfo(sig.getReturnType());
        }
        else if (typeArgs[1]) {
            returnType = this.getTypeInfo(typeArgs[1].getType());
        }
        return { returnType, argTypes, name };
    }
    /**
     * Walks an expression chain and processes each node
     * @param node The node to process
     * @param newValue If we are setting the value of an array, the new value will be passed here
     */
    processExpressionChain(node, newValue) {
        // Check for forEach first because the chain is processed differently
        if (node.isKind(ts.SyntaxKind.CallExpression)) {
            const expr = node.getExpression();
            if (expr.isKind(ts.SyntaxKind.PropertyAccessExpression)) {
                const methodName = expr.getNameNode().getText();
                if (methodName === 'forEach') {
                    this.customMethods.forEach.fn(node);
                    return;
                }
            }
        }
        const { base, chain } = this.getExpressionChain(node);
        if (base.isKind(ts.SyntaxKind.ParenthesizedExpression)) {
            if (!base.getExpression().isKind(ts.SyntaxKind.BinaryExpression))
                throw Error(`Unexpected parentheses around ${base.getExpression().getKindName()}`);
            this.processNode(base.getExpression());
        }
        this.addSourceComment(node);
        let storageBase;
        if (base.compilerNode.kind === ts.SyntaxKind.ThisKeyword) {
            // If the chain starts with a storage expression, then we need to handle it differently
            // than just an identifer when it comes to updating array values, so save it seperately here
            if (chain[0].isKind(ts.SyntaxKind.PropertyAccessExpression) &&
                chain[1] &&
                (chain[1].isKind(ts.SyntaxKind.PropertyAccessExpression) || chain[1].isKind(ts.SyntaxKind.CallExpression)) &&
                this.storageProps[chain[0].getNameNode().getText()]) {
                storageBase = (chain[1].isKind(ts.SyntaxKind.CallExpression) ? chain[2] : chain[1]);
            }
            this.processThisBase(chain, newValue);
        }
        /**
         * An array of objects used to access the base array.
         * For example, `myObj.foo[2]` -> `["myObj", ts.Node(2)]`
         * */
        const accessors = [];
        if (base.isKind(ts.SyntaxKind.Identifier)) {
            if (base.getText() === 'blocks') {
                if (chain[0].isKind(ts.SyntaxKind.ElementAccessExpression)) {
                    this.processNode(chain[0].getArgumentExpressionOrThrow());
                    this.lastType = { kind: 'base', type: 'block' };
                    chain.splice(0, 1);
                }
                else
                    throw Error('Blocks must be accessed via array index');
            }
            if (base.getText() === 'OnCompletion') {
                if (chain[0].isKind(ts.SyntaxKind.PropertyAccessExpression)) {
                    const oc = chain[0].getNameNode().getText();
                    this.pushVoid(chain[0], `int ${ON_COMPLETES.indexOf(oc)} // ${oc}`);
                    chain.splice(0, 1);
                }
            }
            const classInfo = this.getClassInfo(base);
            if (classInfo?.type === 'contract') {
                if (chain[0].isKind(ts.SyntaxKind.PropertyAccessExpression)) {
                    const propName = chain[0].getNameNode().getText();
                    switch (propName) {
                        case 'approvalProgram':
                            if (!chain[1].isKind(ts.SyntaxKind.CallExpression))
                                throw Error(`approvralProgram must be a function call`);
                            this.push(chain[1], `PENDING_COMPILE_APPROVAL: ${base.getText()}`, StackType.bytes);
                            chain.splice(0, 2);
                            break;
                        case 'clearProgram':
                            if (!chain[1].isKind(ts.SyntaxKind.CallExpression))
                                throw Error(`clearProgram must be a function call`);
                            this.push(chain[1], `PENDING_COMPILE_CLEAR: ${base.getText()}`, StackType.bytes);
                            chain.splice(0, 2);
                            break;
                        case 'schema':
                            if (!chain[1].isKind(ts.SyntaxKind.PropertyAccessExpression))
                                throw Error();
                            if (!chain[2].isKind(ts.SyntaxKind.PropertyAccessExpression))
                                throw Error();
                            // eslint-disable-next-line no-case-declarations
                            const globalOrLocal = chain[1].getNameNode().getText() === 'global' ? 'GLOBAL' : 'LOCAL';
                            // eslint-disable-next-line no-case-declarations
                            const uintOrBytes = chain[2].getNameNode().getText() === 'numUint' ? 'INT' : 'BYTES';
                            this.push(chain[1], `PENDING_SCHEMA_${globalOrLocal}_${uintOrBytes}: ${base.getText()}`, StackType.uint64);
                            chain.splice(0, 3);
                            break;
                        default:
                            throw Error(`Unknown contract property ${propName}`);
                    }
                }
            }
            if (classInfo?.type === 'lsig') {
                if (chain[0].isKind(ts.SyntaxKind.PropertyAccessExpression)) {
                    const propName = chain[0].getNameNode().getText();
                    switch (propName) {
                        case 'program':
                            if (!chain[1].isKind(ts.SyntaxKind.CallExpression))
                                throw Error(`program must be a function call`);
                            this.push(chain[1], `PENDING_COMPILE_LSIG: ${base.getText()}`, StackType.bytes);
                            chain.splice(0, 2);
                            break;
                        case 'address':
                            if (!chain[1].isKind(ts.SyntaxKind.CallExpression))
                                throw Error(`address must be a function call`);
                            this.push(chain[1], `PENDING_COMPILE_LSIG_ADDR: ${base.getText()}`, StackType.bytes);
                            chain.splice(0, 2);
                            break;
                        default:
                            throw Error(`Unknown lsig property ${propName}`);
                    }
                }
            }
            const type = base.getType();
            if (type.isStringLiteral()) {
                this.push(base, `byte "${type.getLiteralValueOrThrow()}"`, StackType.bytes);
            }
            if (type.isNumberLiteral()) {
                this.push(base, `int ${type.getLiteralValueOrThrow()}`, StackType.uint64);
            }
            // If getting a txn type via the TransactionType enum
            if (base.getText() === 'TransactionType') {
                const enums = {
                    Unknown: 'unknown',
                    Payment: 'pay',
                    KeyRegistration: 'keyreg',
                    AssetConfig: 'acfg',
                    AssetTransfer: 'axfer',
                    AssetFreeze: 'afrz',
                    ApplicationCall: 'appl',
                };
                if (!chain[0].isKind(ts.SyntaxKind.PropertyAccessExpression))
                    throw Error(`Unsupported ${chain[0].getKindName()} ${chain[0].getText()}`);
                const txType = chain[0].getNameNode().getText();
                if (!enums[txType])
                    throw new Error(`Unknown transaction type ${txType}`);
                this.push(node, `int ${enums[txType]}`, StackType.uint64);
                return;
            }
            // If this is a global variable
            if (base.getText() === 'globals') {
                if (!chain[0].isKind(ts.SyntaxKind.PropertyAccessExpression))
                    throw Error(`Unsupported ${chain[0].getKindName()} ${chain[0].getText()}`);
                this.processOpcodeImmediate(chain[0], { kind: 'base', type: 'global' }, chain[0].getNameNode().getText());
                chain.splice(0, 1);
                // If this is a custom method like `wideRatio`
            }
            else if (chain[0] &&
                chain[0].isKind(ts.SyntaxKind.CallExpression) &&
                this.customMethods[base.getText()] &&
                this.customMethods[base.getText()].check(chain[0])) {
                const callNode = chain[0];
                this.customMethods[base.getText()].fn(callNode);
                chain.splice(0, 1);
                // If this is an opcode
            }
            else if (chain[0] &&
                chain[0].isKind(ts.SyntaxKind.CallExpression) &&
                langspec_json_1.default.Ops.map((o) => o.Name).includes(this.opcodeAliases[base.getText()] ?? base.getText())) {
                this.processOpcode(chain[0]);
                chain.splice(0, 1);
                // If the base is a variable
            }
            else if (this.localVariables[base.getText()]) {
                const baseType = this.getTypeInfo(base.getType());
                const isStaticLength = baseType.kind === 'staticArray' &&
                    chain[0].isKind(ts.SyntaxKind.PropertyAccessExpression) &&
                    chain[0].getName() === 'length';
                const frame = this.localVariables[base.getText()];
                // If this is a static array length, don't push array to stack since its not used
                if (isStaticLength) {
                    this.lastType = baseType;
                }
                // else if this is an array reference, process the frame and get the accessors
                else if (frame && frame.index === undefined && !MULTI_OUTPUT_TYPES.includes(typeInfoToABIString(frame.type))) {
                    const frameFollow = this.processFrame(chain[0].getExpression(), chain[0].getExpression().getText(), false);
                    const { storageExpression } = frameFollow;
                    // If this is a box with a static array, don't load the value here and use box_extract/replace later
                    const isStaticBox = storageExpression &&
                        storageExpression.isKind(ts.SyntaxKind.PropertyAccessExpression) &&
                        getStorageName(storageExpression) &&
                        this.storageProps[getStorageName(storageExpression)] &&
                        this.storageProps[getStorageName(storageExpression)].type === 'box' &&
                        !this.isDynamicType(this.storageProps[getStorageName(storageExpression)].valueType) &&
                        !typeInfoToABIString(this.storageProps[getStorageName(storageExpression)].valueType).match('bool');
                    if (!isStaticBox) {
                        this.processFrame(chain[0].getExpression(), chain[0].getExpression().getText(), true);
                    }
                    else {
                        this.lastType = this.storageProps[getStorageName(storageExpression)].valueType;
                    }
                    frameFollow.accessors.forEach((e) => accessors.push(e));
                    // otherwise just load the value
                }
                else {
                    this.processNode(base);
                }
            }
        }
        // Check if this is a custom propertly like `zeroIndex`
        if (chain[0] && chain[0].isKind(ts.SyntaxKind.PropertyAccessExpression)) {
            const propName = chain[0].getNameNode().getText();
            if (this.customProperties[propName]?.check?.(chain[0])) {
                this.customProperties[propName].fn(chain[0]);
                chain.splice(0, 1);
            }
        }
        /** Saves the last accessor so it can be passed to processParentArrayAccess later */
        let lastAccessor;
        // Iterate over the remaining unprocessed nodes in the chain and remove them once processed
        const remainingChain = chain.filter((n, i) => {
            // Skip if this is the propertyAccessExpression for a callExpression
            // For example, skip `this.txn.sender.hasAsset` when `this.txn.sender.hasAsset()` will be next
            if (chain[i + 1] && chain[i + 1].isKind(ts.SyntaxKind.CallExpression))
                return false;
            this.addSourceComment(n);
            // If accessing a specific byte in a string/byteslice
            if (isBytes(this.lastType) && n.isKind(ts.SyntaxKind.ElementAccessExpression)) {
                this.processNode(n.getArgumentExpression());
                this.pushLines(n, 'int 1', 'extract3');
                this.lastType = { kind: 'base', type: 'byte' };
                return false;
            }
            // If accessing an array
            if (isArrayType(this.lastType) &&
                (n.isKind(ts.SyntaxKind.ElementAccessExpression) || n.isKind(ts.SyntaxKind.PropertyAccessExpression))) {
                // If this is a index into an array ie. `arr[0]`
                if (n.isKind(ts.SyntaxKind.ElementAccessExpression))
                    accessors.push(n.getArgumentExpression());
                // If this is a property in an object ie. `myObj.foo`
                if (n.isKind(ts.SyntaxKind.PropertyAccessExpression)) {
                    const name = n.getName();
                    const childType = this.getTypeInfo(n.getChildAtIndex(0).getType());
                    if (Object.keys(this.customProperties).includes(name)) {
                        const prevLastType = this.lastType;
                        this.lastType = childType;
                        const passCheck = this.customProperties[name].check(n);
                        this.lastType = prevLastType;
                        const hasNameAsProp = childType.kind === 'object' && childType.properties[name] !== undefined;
                        const isLengthOfStaticArray = childType.kind === 'staticArray' && name === 'length';
                        if (!hasNameAsProp && passCheck) {
                            if (!isLengthOfStaticArray) {
                                this.processParentArrayAccess(lastAccessor, accessors, storageBase || base);
                            }
                            else
                                this.lastType = childType;
                            this.customProperties[name].fn(n);
                            accessors.length = 0;
                            return false;
                        }
                    }
                    accessors.push(n.getNameNode().getText());
                }
                lastAccessor = n;
                const newValueValue = i === chain.length - 1 ? newValue : undefined;
                const accessedType = this.getStackTypeAfterFunction(() => {
                    this.processParentArrayAccess(lastAccessor, accessors.slice(), storageBase || base, newValueValue);
                });
                if (!isArrayType(accessedType)) {
                    this.processParentArrayAccess(lastAccessor, accessors, storageBase || base, newValueValue);
                    accessors.length = 0;
                }
                return false;
            }
            if (n.isKind(ts.SyntaxKind.CallExpression)) {
                const expr = n.getExpression();
                if (!expr.isKind(ts.SyntaxKind.PropertyAccessExpression))
                    throw Error(`Unsupported ${n.getKindName()}: ${n.getText()}`);
                const methodName = expr.getNameNode().getText();
                // If this is a custom method
                if (this.customMethods[methodName]?.check?.(n)) {
                    this.customMethods[methodName].fn(n);
                    accessors.length = 0;
                    return false;
                }
                // Otherwise assume it's an opcode method ie. `this.app.address.hasAsset(123)`
                const preArgsType = this.lastType;
                n.getArguments().forEach((a) => this.processNode(a));
                this.lastType = preArgsType;
                this.processOpcodeImmediate(n, this.lastType, methodName);
                return false;
            }
            // If this is a property access expression assume it's an opcode param
            if (n.isKind(ts.SyntaxKind.PropertyAccessExpression)) {
                if (MULTI_OUTPUT_TYPES.includes(typeInfoToABIString(this.lastType))) {
                    const parent = n.getExpressionIfKindOrThrow(ts.SyntaxKind.Identifier);
                    const parentName = parent.getText();
                    const frameName = this.processFrame(parent, parentName, false).name;
                    this.frameDig(n, `${frameName} ${n.getName()}`);
                    return false;
                }
                // Check if this is a custom propertly like `zeroIndex`
                if (n.isKind(ts.SyntaxKind.PropertyAccessExpression)) {
                    const propName = n.getNameNode().getText();
                    if (this.customProperties[propName]?.check?.(n)) {
                        this.customProperties[propName].fn(n);
                        return false;
                    }
                }
                if (chain[i + 1] && chain[i + 1].isKind(ts.SyntaxKind.CallExpression))
                    return false;
                this.processOpcodeImmediate(n, this.lastType, n.getNameNode().getText());
                return false;
            }
            const lastTypeStr = typeInfoToABIString(this.lastType);
            // Handle the case when an imediate array index is needed ie. txna ApplicationArgs i
            if (lastTypeStr.startsWith('ImmediateArray:')) {
                if (n.getArgumentExpression()?.isKind(ts.SyntaxKind.NumericLiteral)) {
                    this.push(n, `${this.teal[this.currentProgram].pop().teal} ${n.getArgumentExpression()?.getText()}`, {
                        kind: 'base',
                        type: lastTypeStr.replace('ImmediateArray: ', ''),
                    });
                }
                else if (n.getArgumentExpression()) {
                    const opcode = `${this.teal[this.currentProgram].at(-1).teal}`.split(' ')[0];
                    const field = `${this.teal[this.currentProgram].at(-1).teal}`.split(' ')[1];
                    this.teal[this.currentProgram].pop();
                    this.processNode(n.getArgumentExpression());
                    this.push(n, `${opcode}as ${field}`, {
                        kind: 'base',
                        type: lastTypeStr.replace('ImmediateArray: ', ''),
                    });
                }
                return false;
            }
            return true;
        });
        // Process the array access if there are array access elements
        if (accessors.length) {
            this.processParentArrayAccess(lastAccessor, accessors, storageBase || base, newValue);
        }
        if (remainingChain.length)
            throw Error(`LastType: ${typeInfoToABIString(this.lastType)} | Base (${base.getKindName()}): ${base.getText()} | Chain: ${chain.map((n) => n.getText())}`);
    }
    processSubroutine(fn) {
        const frameStart = this.teal[this.currentProgram].length;
        this.currentSubroutine = this.subroutines.find((s) => s.name === fn.getNameNode()?.getText());
        const sigParams = fn
            .getSignature()
            .getParameters()
            .map((p) => p.getDeclarations()[0].getText());
        const returnTypeString = fn.getReturnTypeNode()?.getText() || 'void';
        const headerComment = [`// ${fn.getName()}(${sigParams.join(', ')}): ${returnTypeString}`];
        if (this.currentSubroutine.desc !== '') {
            headerComment.push('//');
            const descLines = this.currentSubroutine.desc.split('\n');
            descLines.forEach((line, i) => {
                const newLine = line
                    .trim()
                    .replace(/^\/\*\*/, '')
                    .replace(/\*\/$/, '')
                    .replace(/^\*/, '');
                if (newLine.trim() !== '' || !(i === 0 || i === descLines.length - 1))
                    headerComment.push(`// ${newLine.trim()}`);
            });
        }
        while (headerComment.at(-1) === '// ')
            headerComment.pop();
        this.pushLines(fn, ...headerComment);
        this.pushVoid(fn, `${this.currentSubroutine.name}:`);
        const lastFrame = JSON.parse(JSON.stringify(this.localVariables));
        this.localVariables = {};
        this.pushLines(fn, `PENDING_PROTO: ${this.currentSubroutine.name}`);
        let argIndex = -1;
        const params = new Array(...fn.getParameters());
        params.forEach((p) => {
            if (p.getTypeNode() === undefined)
                throw new Error();
            const type = this.getTypeInfo(p.getTypeNode().getType());
            this.localVariables[p.getNameNode().getText()] = {
                index: argIndex,
                type,
                typeString: p.getTypeNode().getText(),
            };
            argIndex -= 1;
        });
        this.frameIndex = 0;
        this.processNode(fn.getBodyOrThrow());
        const currentTeal = this.teal[this.currentProgram];
        const returnBranch = `*${this.currentSubroutine.name}*return`;
        if (currentTeal.at(-1)?.teal === `b ${returnBranch}`) {
            currentTeal.pop();
        }
        if (currentTeal.map((t) => t.teal).includes(`b ${returnBranch}`)) {
            this.pushLines(this.currentSubroutine.node, `${returnBranch}:`);
        }
        if (returnTypeString !== 'void' && this.frameIndex > 0) {
            this.pushLines(this.currentSubroutine.node, '// set the subroutine return value', 'frame_bury 0');
            if (this.frameIndex > 1) {
                this.pushLines(this.currentSubroutine.node, '// pop all local variables from the stack', `popn ${this.frameIndex - 1}`);
            }
        }
        this.pushVoid(this.currentSubroutine.node, 'retsub');
        this.frameInfo[this.currentSubroutine.name] = {
            start: frameStart,
            end: this.teal[this.currentProgram].length,
            frame: {},
        };
        const currentFrame = this.localVariables;
        const currentFrameInfo = this.frameInfo[this.currentSubroutine.name];
        Object.keys(this.localVariables).forEach((name) => {
            currentFrameInfo.frame[currentFrame[name].index] = { name, type: currentFrame[name].type };
        });
        this.localVariables = lastFrame;
        this.frameSize[this.currentSubroutine.name] = this.frameIndex;
    }
    processClearState(fn) {
        if (this.clearStateCompiled)
            throw Error('duplicate clear state decorator defined');
        this.currentProgram = 'clear';
        if (fn.getParameters().length > 0)
            throw Error('clear state cannot have parameters');
        this.processNode(fn.getBodyOrThrow());
        this.pushLines(fn.getBodyOrThrow(), 'int 1', 'return');
        this.clearStateCompiled = true;
        this.currentProgram = 'approval';
    }
    overflowCheck(node, width) {
        if (this.disableOverflowChecks)
            return;
        this.pushLines(node, 'dup', 'bitlen', `int ${width}`, '<=');
        if (node.isKind(ts.SyntaxKind.MethodDeclaration)) {
            this.pushVoid(node, 'assert', `${node.getName()} return value overflowed ${width} bits`);
        }
        else
            this.pushVoid(node, 'assert', `${node.getText().replace(/\n/g, '\\n')} overflowed ${width} bits`);
    }
    processRoutableMethod(fn) {
        if (this.currentSubroutine.allows.call.includes('ClearState') || this.currentSubroutine.name === 'clearState') {
            this.processClearState(fn);
            return;
        }
        this.pushVoid(fn, `// ${this.getSignature(fn)}`);
        if (this.currentProgram !== 'lsig') {
            this.pushLines(fn, `*abi_route_${this.currentSubroutine.name}:`);
        }
        else {
            this.pushLines(fn, `*route_${this.currentSubroutine.name}:`);
        }
        const returnType = this.currentSubroutine.returns.type;
        const returnTypeStr = typeInfoToABIString(this.currentSubroutine.returns.type)
            .replace(/asset|application/, 'uint64')
            .replace('account', 'address');
        if (returnTypeStr !== 'void')
            this.pushLines(fn, '// The ABI return prefix', 'byte 0x151f7c75');
        const argCount = fn.getParameters().length;
        const args = [];
        let nonTxnArgCount = argCount - fn.getParameters().filter((p) => p.getTypeNode()?.getText().includes('Txn')).length + 1;
        let gtxnIndex = 0;
        new Array(...fn.getParameters()).reverse().forEach((p, i) => {
            let type = this.getTypeInfo(p.getTypeNode().getType());
            if (p.getTypeNode()?.getText() === 'Account') {
                type = { kind: 'base', type: 'account' };
            }
            const typeStr = typeInfoToABIString(type);
            this.pushVoid(p, `// ${p.getNameNode().getText()}: ${typeStr}`);
            if (!TXN_TYPES.includes(typeStr)) {
                if (this.currentProgram === 'lsig')
                    this.pushLines(p, `int ${(nonTxnArgCount -= 1) - 1}`, 'args');
                else
                    this.pushVoid(p, `txna ApplicationArgs ${(nonTxnArgCount -= 1)}`);
            }
            if (isRefType(type)) {
                if (this.currentProgram === 'lsig') {
                    if (['appreference', 'assetreference'].includes(typeStr))
                        this.pushVoid(p, 'btoi');
                }
                else {
                    this.pushVoid(p, 'btoi');
                    this.pushVoid(p, `txnas ${capitalizeFirstChar(typeStr)}s`);
                }
            }
            else if (TXN_TYPES.includes(typeStr)) {
                this.pushVoid(p, 'txn GroupIndex');
                this.pushVoid(p, `int ${(gtxnIndex += 1)}`);
                this.pushVoid(p, '-');
                if (typeStr !== 'txn') {
                    this.pushLines(p, 'dup', 'gtxns TypeEnum', `int ${typeStr}`, '==');
                    this.pushVoid(p, 'assert', `argument ${i} (${p.getNameNode().getText()}) for ${this.currentSubroutine.name} must be a ${typeStr} transaction`);
                }
            }
            else if (!this.isDynamicType(type) && typeStr !== 'uint64') {
                this.pushLines(p, 'dup', 'len', `int ${typeStr === 'bool' ? 1 : this.getTypeLength(type)}`, '==');
                this.pushVoid(p, 'assert', `argument ${i} (${p.getNameNode().getText()}) for ${this.currentSubroutine.name} must be a ${typeStr}`);
            }
            if (!isRefType(type))
                this.checkDecoding(p, type);
            args.push({
                name: p.getNameNode().getText(),
                type,
                desc: '',
            });
        });
        // Only add an ABI method if it allows any non-bare OnComplete calls
        const currentAllows = Object.values(this.currentSubroutine.allows).flat();
        if (currentAllows.length > 0) {
            this.abi.methods.push({
                name: this.currentSubroutine.name,
                readonly: this.currentSubroutine.readonly || undefined,
                args: args.reverse(),
                desc: '',
                returns: { type: returnType, desc: '' },
                events: this.currentSubroutine.events,
            });
        }
        this.pushVoid(fn, `// execute ${this.getSignature(this.currentSubroutine.node)}`);
        this.pushVoid(fn, `callsub ${this.currentSubroutine.name}`);
        if (returnTypeStr.match(/\d+$/) && !returnTypeStr.match(/^(uint|ufixed)64/)) {
            this.lastType = { kind: 'base', type: `unsafe ${returnTypeStr}` };
            this.checkEncoding(fn, this.lastType);
        }
        else
            this.checkEncoding(fn, returnType);
        if (!equalTypes(returnType, StackType.void))
            this.pushLines(fn, 'concat', 'log');
        this.pushLines(fn, 'int 1', 'return');
        this.processSubroutine(fn);
    }
    processOpcode(node) {
        const nodeText = node.getExpression().getText();
        const opcodeName = this.opcodeAliases[nodeText] ?? nodeText;
        if (opcodeName === 'assert') {
            const args = node.getArguments();
            this.processNode(args[0]);
            const errorMessage = args[1]?.getType().isStringLiteral()
                ? args[1].getType().getLiteralValueOrThrow().valueOf().toString()
                : undefined;
            this.pushVoid(node, 'assert', errorMessage);
            return;
        }
        if (opcodeName === 'sqrt') {
            this.processNode(node.getArguments()[0]);
            const type = this.lastType;
            const opcode = isNumeric(type) ? 'sqrt' : 'bsqrt';
            this.pushVoid(node, opcode);
            if (!isNumeric(type) && type.kind === 'base' && !type.type.startsWith('unsafe ')) {
                this.lastType = { kind: 'base', type: `unsafe ${type.type}` };
            }
            return;
        }
        if (this.currentProgram === 'lsig' && opcodeName === 'log') {
            throw Error('Logic signatures cannot log data');
        }
        const opSpec = langspec_json_1.default.Ops.find((o) => o.Name === opcodeName);
        let line = [opcodeName];
        const declaration = node.getExpression()?.getType()?.getCallSignatures()?.[0]?.getDeclaration();
        const argTypes = [];
        if (declaration?.isKind(ts.SyntaxKind.FunctionDeclaration)) {
            declaration.getParameters().forEach((p) => argTypes.push(p.getType()));
        }
        if (opSpec.Size === 1) {
            const preArgsType = this.lastType;
            node.getArguments().forEach((a, i) => {
                this.processNode(a);
                if (declaration)
                    typeComparison(this.lastType, this.getTypeInfo(argTypes[i]));
            });
            this.lastType = preArgsType;
        }
        else if (opSpec.Size === 0) {
            line = line.concat(node.getArguments().map((a) => a.getText()));
        }
        else {
            node
                .getArguments()
                .slice(opSpec.Size - 1)
                .forEach((a, i) => {
                this.processNode(a);
                if (declaration)
                    typeComparison(this.lastType, this.getTypeInfo(argTypes[i + opSpec.Size - 1]));
            });
            line = line.concat(node
                .getArguments()
                .slice(0, opSpec.Size - 1)
                .map((immediateArg) => {
                const immediateArgType = immediateArg.getType();
                if (immediateArgType.isStringLiteral()) {
                    return immediateArgType.getLiteralValueOrThrow().valueOf();
                }
                if (immediateArgType.isNumberLiteral()) {
                    return immediateArgType.getLiteralValueOrThrow().valueOf().toString();
                }
                throw Error(`Cannot process ${immediateArg.getText()} as immediate argument`);
            }));
        }
        let returnTypeStr = opSpec.Returns?.at(-1)?.replace(/\[\d*\]byte/, 'bytes') || 'void';
        if (opSpec.Name.endsWith('256'))
            returnTypeStr = 'byte[32]';
        let returnType;
        if (returnTypeStr.endsWith('[]')) {
            returnType = { kind: 'dynamicArray', base: { kind: 'base', type: returnTypeStr.replace('[]', '') } };
        }
        else if (returnTypeStr.match(/\[\d+\]$/)) {
            returnType = {
                kind: 'staticArray',
                length: Number(returnTypeStr.match(/\d+/)[0]),
                base: { kind: 'base', type: returnTypeStr.replace(/\[\d+\]$/, '') },
            };
        }
        else {
            returnType = { kind: 'base', type: returnTypeStr };
        }
        if (equalTypes(returnType, StackType.any))
            returnType = this.getTypeInfo(node.getType());
        this.push(node.getExpression(), line.join(' '), returnType);
        const returnTypeInfo = this.getTypeInfo(node.getReturnType());
        if (opcodeName === 'vrf_verify') {
            const parent = node.getParent();
            if (!parent?.isKind(ts.SyntaxKind.VariableDeclaration)) {
                throw Error(`${opcodeName} output must be assigned to a variable before usage`);
            }
            const name = parent.getName();
            const verified = `${name} verified`;
            const output = `${name} output`;
            this.initialFrameBury(node, verified, { kind: 'base', type: 'bool' }, `${verified}: bool`);
            this.initialFrameBury(node, output, StackType.bytes, `${output}: byte[]`);
            this.lastType = returnTypeInfo;
        }
        if (['mulw', 'addw', 'expw'].includes(opcodeName)) {
            const parent = node.getParent();
            if (!parent?.isKind(ts.SyntaxKind.VariableDeclaration)) {
                throw Error(`${opcodeName} output must be assigned to a variable before usage`);
            }
            const name = parent.getName();
            const low = `${name} low`;
            const high = `${name} high`;
            this.initialFrameBury(node, low, StackType.uint64, `${low}: uint64`);
            this.initialFrameBury(node, high, StackType.uint64, `${high}: uint64`);
            this.lastType = returnTypeInfo;
        }
        if (opcodeName === 'divmodw') {
            const parent = node.getParent();
            if (!parent?.isKind(ts.SyntaxKind.VariableDeclaration)) {
                throw Error(`${opcodeName} output must be assigned to a variable before usage`);
            }
            const name = parent.getName();
            const quotientLow = `${name} quotientLow`;
            const quotientHigh = `${name} quotientHigh`;
            const remainderHigh = `${name} remainderHigh`;
            const remainderLow = `${name} remainderLow`;
            this.initialFrameBury(node, remainderLow, StackType.uint64, `${remainderLow}: uint64`);
            this.initialFrameBury(node, remainderHigh, StackType.uint64, `${remainderHigh}: uint64`);
            this.initialFrameBury(node, quotientLow, StackType.uint64, `${quotientLow}: uint64`);
            this.initialFrameBury(node, quotientHigh, StackType.uint64, `${quotientHigh}: uint64`);
            this.lastType = returnTypeInfo;
        }
        if (returnTypeInfo.kind === 'base' && returnTypeInfo.type === 'ecdsa pubkey') {
            const parent = node.getParent();
            if (!parent?.isKind(ts.SyntaxKind.VariableDeclaration)) {
                throw Error(`${opcodeName} output must be assigned to a variable before usage`);
            }
            const name = parent.getName();
            const x = `${name} x`;
            const y = `${name} y`;
            this.initialFrameBury(node, y, StackType.bytes, `${y} component: byte[]`);
            this.initialFrameBury(node, x, StackType.bytes, `${x} component: byte[]`);
            this.lastType = returnTypeInfo;
        }
    }
    initialFrameBury(node, name, type, comment) {
        const defaultComment = `${name}: ${typeInfoToABIString(type)}`;
        // Save box key
        this.localVariables[name] = {
            index: this.frameIndex,
            type,
            typeString: typeInfoToABIString(type),
            comment,
        };
        this.pushVoid(node, `frame_bury ${this.frameIndex} // ${comment ?? defaultComment}`);
        this.frameIndex += 1;
    }
    frameBury(node, name) {
        const frame = this.localVariables[name];
        if (!frame)
            throw Error(`Unknown variable ${name}`);
        typeComparison(this.lastType, frame.type, true);
        const defaultComment = `${name}: ${typeInfoToABIString(this.lastType)}`;
        this.pushVoid(node, `frame_bury ${frame.index} // ${frame.comment ?? defaultComment}`);
    }
    frameDig(node, name) {
        const frame = this.localVariables[name];
        if (!frame)
            throw Error(`Unknown variable ${name}`);
        this.pushVoid(node, `frame_dig ${frame.index} // ${frame.comment ?? name}`);
        this.lastType = frame.type;
    }
    processTransaction(node, name, fields, argTypes, returnType, methodName) {
        const argTypeStrings = argTypes.map((t) => typeInfoToABIString(t));
        if (this.currentProgram === 'clear')
            throw Error('Inner transactions not allowed in clear state program');
        if (this.currentProgram === 'lsig')
            throw Error('Inner transaction not allowed in logic signatures');
        if (!fields.isKind(ts.SyntaxKind.ObjectLiteralExpression))
            throw new Error('Transaction fields must be an object literal');
        const method = name.replace('this.pendingGroup.', '').replace(/^(add|send|Inner)/, '');
        const send = name.startsWith('send');
        if (name.startsWith('add')) {
            this.innerTxnHasBegun = true;
        }
        else if (name.startsWith('send')) {
            this.innerTxnHasBegun = false;
        }
        let txnType = '';
        fields.getProperties().forEach((p) => {
            if (!p.isKind(ts.SyntaxKind.PropertyAssignment))
                throw Error();
            const key = p.getNameNode()?.getText();
            if (key === 'isFirstTxn') {
                this.innerTxnHasBegun = false;
                return;
            }
            if (key === 'methodArgs') {
                const init = p.getInitializer();
                if (!init?.isKind(ts.SyntaxKind.ArrayLiteralExpression))
                    throw new Error('methodArgs must be an array');
                init.getElements().forEach((e, i) => {
                    if (TXN_TYPES.includes(argTypeStrings[i]) || TXN_TYPES.includes(argTypeStrings[i].replace('generic ', ''))) {
                        let innerArgs = [];
                        let innerMethodReturnType = StackType.void;
                        const argType = argTypes[i];
                        if (argType.kind === 'method') {
                            innerArgs = argType.args;
                            innerMethodReturnType = argType.returns;
                        }
                        this.processTransaction(e, argTypeStrings[i], e, innerArgs, innerMethodReturnType);
                    }
                });
            }
        });
        /*
    declare type AssetFreezeTxn = Required<AssetFreezeParams>;
        */
        switch (method.replace('generic ', '')) {
            case 'pay':
            case 'Payment':
                txnType = TransactionType.PaymentTx;
                break;
            case 'axfer':
            case 'AssetTransfer':
                txnType = TransactionType.AssetTransferTx;
                break;
            case 'appl':
            case 'MethodCall':
            case 'AppCall':
                txnType = TransactionType.ApplicationCallTx;
                break;
            case 'acfg':
            case 'AssetCreation':
            case 'AssetConfig':
                txnType = TransactionType.AssetConfigTx;
                break;
            case 'afrz':
            case 'AssetFreeze':
                txnType = TransactionType.AssetFreezeTx;
                break;
            case 'keyreg':
            case 'OfflineKeyRegistration':
            case 'OnlineKeyRegistration':
                txnType = TransactionType.KeyRegistrationTx;
                break;
            default:
                throw new Error(`Invalid transaction call ${name}`);
        }
        this.pushVoid(node, this.innerTxnHasBegun ? 'itxn_next' : 'itxn_begin');
        if (this.innerTxnHasBegun === false)
            this.innerTxnHasBegun = true;
        this.pushVoid(node, `int ${txnType}`);
        this.pushVoid(node, 'itxn_field TypeEnum');
        const nameProp = fields
            .getProperties()
            .find((p) => p.isKind(ts.SyntaxKind.PropertyAssignment) && p.getNameNode()?.getText() === 'name');
        const argTypeStringsWithTxn = argTypeStrings.map((t) => (t.startsWith('generic ') ? 'txn' : t));
        if (nameProp && txnType === TransactionType.ApplicationCallTx) {
            if (!nameProp.isKind(ts.SyntaxKind.PropertyAssignment) ||
                !nameProp.getInitializer().isKind(ts.SyntaxKind.StringLiteral))
                throw new Error('Method call name key must be a string');
            this.pushVoid(nameProp, `method "${nameProp.getInitializer().getLiteralText()}(${argTypeStringsWithTxn.join(',')})${typeInfoToABIString(returnType, true)}"`);
            this.pushVoid(nameProp, 'itxn_field ApplicationArgs');
        }
        else if (methodName) {
            this.pushVoid(node, `method "${methodName}(${argTypeStringsWithTxn
                .join(',')
                // any[] is used for default lifecycle methods, which we want to remove
                .replace('any[]', '')})${typeInfoToABIString(returnType, true)}"`);
            this.pushVoid(node, 'itxn_field ApplicationArgs');
        }
        fields.getProperties().forEach((p) => {
            if (!p.isKind(ts.SyntaxKind.PropertyAssignment))
                throw Error();
            const key = p.getNameNode()?.getText();
            const init = p.getInitializer();
            if (key === undefined)
                throw new Error('Key must be defined');
            if (key === 'isFirstTxn')
                return;
            if (key === 'name' && txnType === TransactionType.ApplicationCallTx) {
                return;
            }
            this.addSourceComment(p, true);
            this.pushComments(p);
            if ((key === 'approvalProgram' || key === 'clearStateProgram') &&
                init?.isKind(ts.SyntaxKind.ArrayLiteralExpression)) {
                init.getElements().forEach((e) => {
                    this.processNode(e);
                    this.pushVoid(e, `itxn_field ${capitalizeFirstChar(key)}Pages`);
                });
            }
            else if (key === 'onCompletion') {
                if (!p.isKind(ts.SyntaxKind.PropertyAssignment) || !init?.isKind(ts.SyntaxKind.PropertyAccessExpression)) {
                    throw new Error('Must use OnCompletion enum');
                }
                const oc = init.getNameNode().getText();
                this.pushVoid(p.getInitializer(), `int ${ON_COMPLETES.indexOf(oc)} // ${oc}`);
                this.pushVoid(p, 'itxn_field OnCompletion');
            }
            else if (key === 'methodArgs') {
                let accountIndex = 1;
                let appIndex = 1;
                let assetIndex = 0;
                if (!p.isKind(ts.SyntaxKind.PropertyAssignment) || !init?.isKind(ts.SyntaxKind.ArrayLiteralExpression)) {
                    throw new Error('methodArgs must be an array');
                }
                init.getElements().forEach((e, i) => {
                    if (argTypeStrings[i] === 'account') {
                        this.processNode(e);
                        this.pushVoid(e, 'itxn_field Accounts');
                        this.pushVoid(e, `int ${accountIndex}`);
                        this.pushVoid(e, 'itob');
                        accountIndex += 1;
                    }
                    else if (argTypeStrings[i] === 'asset') {
                        this.processNode(e);
                        this.pushVoid(e, 'itxn_field Assets');
                        this.pushVoid(e, `int ${assetIndex}`);
                        this.pushVoid(e, 'itob');
                        assetIndex += 1;
                        // if it's an appl but NOT a method call
                    }
                    else if (argTypeStrings[i] === 'appl' && !e.isKind(ts.SyntaxKind.ObjectLiteralExpression)) {
                        this.processNode(e);
                        this.pushVoid(e, 'itxn_field Applications');
                        this.pushVoid(e, `int ${appIndex}`);
                        this.pushVoid(e, 'itob');
                        appIndex += 1;
                    }
                    else if (argTypeStrings[i] === 'uint64') {
                        this.processNode(e);
                        typeComparison(this.lastType, argTypes[i]);
                        this.pushVoid(e, 'itob');
                    }
                    else if (TXN_TYPES.includes(argTypeStrings[i]) ||
                        TXN_TYPES.includes(argTypeStrings[i].replace('generic ', ''))) {
                        return;
                    }
                    else {
                        const prevTypeHint = this.typeHint;
                        this.typeHint = argTypes[i];
                        this.processNode(e);
                        this.checkEncoding(e, argTypes[i]);
                        this.typeHint = prevTypeHint;
                    }
                    this.pushVoid(e, 'itxn_field ApplicationArgs');
                });
            }
            else if (p.isKind(ts.SyntaxKind.PropertyAssignment) && init?.isKind(ts.SyntaxKind.ArrayLiteralExpression)) {
                init.getElements().forEach((e) => {
                    this.processNode(e);
                    this.pushVoid(e, `itxn_field ${capitalizeFirstChar(key)}`);
                });
            }
            else if (p.isKind(ts.SyntaxKind.PropertyAssignment)) {
                this.processNode(p.getInitializer());
                this.pushVoid(p, `itxn_field ${capitalizeFirstChar(key)}`);
            }
        });
        if (!fields
            .getProperties()
            .map((p) => p.isKind(ts.SyntaxKind.PropertyAssignment) && p.getNameNode()?.getText())
            .includes('fee')) {
            this.pushLines(node, '// Fee field not set, defaulting to 0', 'int 0', 'itxn_field Fee');
        }
        if (send) {
            this.pushLines(node, '// Submit inner transaction', 'itxn_submit');
            if (name === 'sendMethodCall' && typeInfoToABIString(returnType) !== 'void') {
                this.pushLines(node, 'itxn NumLogs', 'int 1', '-', 'itxnas Logs', 'extract 4 0');
                this.checkDecoding(node, returnType);
                this.lastType = returnType;
            }
            else if (name === 'sendAssetCreation') {
                this.push(node, 'itxn CreatedAssetID', ForeignType.Asset);
            }
        }
    }
    /*
      Processes an immediate argument to TEAL opcodes
      For example, "this.txn.sender -> txn Sender"
    */
    processOpcodeImmediate(node, calleeType, name, checkArgs = false, thisTxn = false) {
        const type = calleeType;
        let typeStr = typeInfoToABIString(type);
        if (type.kind === 'base') {
            if (['assetid', 'assetreference'].includes(type.type))
                typeStr = 'asset';
            if (['appid', 'appreference'].includes(type.type))
                typeStr = 'application';
            if (['address', 'accountreference'].includes(type.type))
                typeStr = 'account';
        }
        if (TXN_TYPES.includes(typeStr) && !thisTxn) {
            typeStr = 'gtxns';
        }
        if (typeStr === 'account') {
            if (name === 'isOptedInToApp') {
                this.pushLines(node, 'app_opted_in');
                this.lastType = { kind: 'base', type: 'bool' };
                return;
            }
        }
        if (!['isInLedger', 'isOptedInToAsset'].includes(name)) {
            if (this.OP_PARAMS[typeStr] === undefined) {
                throw Error(`Unknown or unsupported method: ${node.getText()} for type ${typeStr}`);
            }
            const paramObj = this.OP_PARAMS[typeStr].find((p) => {
                let paramName = p.name.replace(/^Acct/, '').replace(/^Blk/, '');
                if (['asset', 'application', 'account', 'itxn'].includes(typeStr) && this.currentProgram === 'lsig') {
                    throw Error(`Cannot access ${capitalizeFirstChar(typeStr)} parameters in logic signature`);
                }
                if (typeStr === 'application')
                    paramName = paramName.replace(/^App/, '');
                if (typeStr === 'asset')
                    paramName = paramName.replace(/^Asset/, '');
                return paramName === capitalizeFirstChar(name);
            });
            if (typeStr === 'account' && name === 'voterBalance') {
                this.push(node, 'voter_params_get VoterBalance', StackType.uint64);
                return;
            }
            if (typeStr === 'account' && name === 'voterIncentiveEligible') {
                this.push(node, 'voter_params_get VoterIncentiveEligible', StackType.uint64);
                return;
            }
            if (!paramObj)
                throw new Error(`Unknown or unsupported method: ${node.getText()} for ${typeStr}`);
            if (!checkArgs || paramObj.args === 1) {
                paramObj.fn(node);
            }
            return;
        }
        switch (name) {
            case 'isInLedger':
                this.hasMaybeValue(node, 'acct_params_get AcctBalance');
                return;
            case 'isOptedInToAsset':
                if (!checkArgs) {
                    this.hasMaybeValue(node, 'asset_holding_get AssetBalance');
                }
                return;
            default:
                throw new Error(`Unknown method: ${type}.${name}`);
        }
    }
    async algodCompile() {
        if (this.currentProgram === 'lsig') {
            await this.algodCompileProgram('lsig');
            return;
        }
        await this.algodCompileProgram('approval');
        await this.algodCompileProgram('clear');
    }
    async algodCompileProgram(program) {
        let dynamicTemplateWarning = false;
        const body = this.teal[program]
            .map((t) => t.teal)
            .map((t) => {
            // Replace template variables
            if (t.startsWith('bytecblock') || t.startsWith('intcblock')) {
                const newArgs = t.split(' ').map((arg) => {
                    const tVar = Object.values(this.templateVars).find((v) => v.name === arg.replace(/^TMPL_/, ''));
                    if (tVar === undefined)
                        return arg;
                    if (this.isDynamicType(tVar.type) || isNumeric(tVar.type)) {
                        if (program === 'lsig' || (program === 'approval' && !dynamicTemplateWarning)) {
                            // eslint-disable-next-line no-console
                            console.warn(`WARNING: Due to dynamic template variable type for ${tVar.name} (${typeInfoToABIString(tVar.type)}) PC values will be offset from first opcode after constant blocks. This will be handled by algokit clients, but ARC56 has a minimal reference implementation available for scenarios where algokit is not being used: https://github.com/joe-p/ARCs/blob/extended_app_description/ARCs/arc-0056.md#calculating-cblock-offsets`);
                            this.hasDynamicTemplateVar = true;
                            dynamicTemplateWarning = true;
                        }
                        return isNumeric(tVar.type) ? '0' : '0x';
                    }
                    return `0x${'00'.repeat(this.getTypeLength(tVar.type))}`;
                });
                return newArgs.join(' ');
            }
            // Remove comments to avoid taking up space in the request body
            if (t.startsWith('//')) {
                return '';
            }
            return t.trim();
        })
            .join('\n');
        const response = await (0, node_fetch_1.default)(`${this.algodServer}:${this.algodPort}/v2/teal/compile?sourcemap=true`, {
            method: 'POST',
            headers: {
                'Content-Type': 'text/plain',
                'X-Algo-API-Token': this.algodToken,
            },
            body,
        });
        const json = await response.json();
        if (response.status !== 200) {
            if (json.message.includes('request body too large')) {
                this.teal[program] = this.teal[program].filter((t) => !t.teal.trim().startsWith('//'));
                // eslint-disable-next-line no-console
                console.warn(`The emitted TEAL for ${this.name}'s ${program} program was too large. Removing comments from TEAL and trying again...`);
                // For some reason without awaiting explicitly here ConnectionClosed will be thrown
                // eslint-disable-next-line no-return-await
                return await this.algodCompileProgram(program);
            }
            // eslint-disable-next-line no-console
            console.error(this.teal[program]
                .map((t) => t.teal)
                .map((l, i) => `${i + 1}: ${l}`)
                .join('\n'));
            throw new Error(`${response.statusText}: ${json.message}`);
        }
        if (!this.algodVersion) {
            const versionResponse = await (0, node_fetch_1.default)(`${this.algodServer}:${this.algodPort}/versions`, {
                method: 'GET',
                headers: {
                    'X-Algo-API-Token': this.algodToken,
                },
            });
            const versionJson = await versionResponse.json();
            this.algodVersion = {
                major: versionJson.build.major,
                minor: versionJson.build.minor,
                patch: versionJson.build.build_number,
                commitHash: versionJson.build.commit_hash,
            };
        }
        if (Object.keys(this.templateVars).length === 0) {
            this.compiledPrograms[program] = json.result;
        }
        this.estimatedProgramSize[program] = Buffer.from(json.result, 'base64').byteLength;
        if (program === 'clear')
            return json;
        const mapping = await getSourceMap(json.sourcemap.mappings);
        this.lineToPc = mapping.lineToPc;
        this.pcToLine = mapping.pcToLine;
        if (program === 'lsig') {
            const addrLine = this.teal.lsig.find((t) => t.teal.trim() === '// The address of this logic signature is');
            addrLine.teal += ` ${json.hash}`;
        }
        let lastCblockPc = 0;
        let lastCblockLine = 0;
        if (this.hasDynamicTemplateVar) {
            const bytecblockLine = this.teal[program].findIndex((t) => t.teal.trim().startsWith('bytecblock'));
            const intcblockLine = this.teal[program].findIndex((t) => t.teal.trim().startsWith('intcblock'));
            lastCblockLine = Math.max(bytecblockLine, intcblockLine);
            lastCblockPc = this.lineToPc[lastCblockLine].at(-1);
        }
        this.sourceInfo.forEach((sm) => {
            if (this.hasDynamicTemplateVar) {
                if (sm.teal - 1 <= lastCblockLine)
                    return;
                const pcs = this.lineToPc[sm.teal - 1];
                // PCs will be undefined if the line is blank or a comment
                if (pcs === undefined)
                    return;
                // eslint-disable-next-line no-param-reassign
                sm.pc = this.lineToPc[sm.teal - 1].map((pc) => pc - lastCblockPc);
                return;
            }
            // eslint-disable-next-line no-param-reassign
            sm.pc = this.lineToPc[sm.teal - 1];
        });
        return json;
    }
    addSourceComment(node, force, comment) {
        if (!force &&
            node.getStart() >= this.lastSourceCommentRange[0] &&
            node.getEnd() <= this.lastSourceCommentRange[1]) {
            return;
        }
        const nodePath = path_1.default.relative(this.cwd, node.getSourceFile().getFilePath());
        this.pushVoid(node, `// ${nodePath}:${node.getStartLineNumber()}`);
        const lines = (comment ?? node.getText()).split('\n').map((l) => `// ${l}`);
        this.pushLines(node, ...lines);
        this.lastSourceCommentRange = [node.getStart(), node.getEnd()];
    }
    arc56Description() {
        const objectToStructFields = (typeInfo) => {
            const fields = [];
            // eslint-disable-next-line no-restricted-syntax
            for (const [field, type] of Object.entries(typeInfo.properties)) {
                if (type.kind === 'object') {
                    fields.push({ name: field, type: objectToStructFields(type) });
                }
                else {
                    fields.push({ name: field, type: typeInfoToABIString(type) });
                }
            }
            return fields;
        };
        const state = {
            schema: {
                global: {
                    bytes: 0,
                    ints: 0,
                },
                local: {
                    bytes: 0,
                    ints: 0,
                },
            },
            keys: {
                global: {},
                local: {},
                box: {},
            },
            maps: {
                global: {},
                local: {},
                box: {},
            },
        };
        const sourceInfo = this.sourceInfo.filter((s) => s.pc !== undefined);
        const arc56 = {
            ...this.arc4Description(),
            arcs: [4, 56],
            structs: {},
            state,
            bareActions: { create: [], call: [] },
            // TODO: clear source mapping
            sourceInfo: {
                approval: {
                    // @ts-expect-error Undefined PCs are filtered out above
                    sourceInfo,
                    pcOffsetMethod: this.hasDynamicTemplateVar ? 'cblocks' : 'none',
                },
                clear: { sourceInfo: [], pcOffsetMethod: 'none' },
            },
            source: {
                approval: Buffer.from(this.teal.approval.map((t) => t.teal).join('\n')).toString('base64'),
                clear: Buffer.from(this.teal.clear.map((t) => t.teal).join('\n')).toString('base64'),
            },
        };
        Object.values(this.storageProps).forEach((sp) => {
            if (sp.key) {
                state.keys[sp.type][sp.name] = {
                    key: Buffer.from(sp.key).toString('base64'),
                    keyType: 'AVMBytes',
                    valueType: equalTypes(sp.valueType, StackType.bytes) ? 'AVMBytes' : typeInfoToABIString(sp.valueType),
                };
            }
            else {
                let keyType = equalTypes(sp.keyType, StackType.bytes) ? 'AVMBytes' : typeInfoToABIString(sp.keyType);
                let valueType = equalTypes(sp.valueType, StackType.bytes) ? 'AVMBytes' : typeInfoToABIString(sp.valueType);
                const typeArgs = sp.initNode.getTypeArguments();
                if (sp.valueType.kind === 'object') {
                    valueType = typeArgs[sp.key ? 0 : 1].getText();
                    arc56.structs[valueType] = objectToStructFields(sp.valueType);
                }
                if (sp.keyType.kind === 'object') {
                    keyType = typeArgs[0].getText();
                    arc56.structs[keyType] = objectToStructFields(sp.keyType);
                }
                state.maps[sp.type][sp.name] = {
                    keyType,
                    valueType,
                    prefix: sp.prefix ? Buffer.from(sp.prefix).toString('base64') : undefined,
                };
            }
            if (sp.type === 'global' || sp.type === 'local') {
                if (isNumeric(sp.valueType)) {
                    state.schema[sp.type].ints += sp.maxKeys || 1;
                }
                else {
                    state.schema[sp.type].bytes += sp.maxKeys || 1;
                }
            }
        });
        arc56.methods.forEach((m) => {
            const subroutine = this.subroutines.find((s) => s.name === m.name);
            const actions = subroutine.allows;
            // eslint-disable-next-line no-param-reassign
            m.actions = actions;
            if (subroutine.node.isKind(ts.SyntaxKind.MethodDeclaration)) {
                const returnTypeInfo = this.getTypeInfo(subroutine.node.getReturnType());
                if (returnTypeInfo.kind === 'object') {
                    const returnTypeNode = subroutine.node.getChildrenOfKind(ts.SyntaxKind.TypeReference)?.[0] || subroutine.node.getReturnType();
                    const structName = returnTypeNode?.getText();
                    // eslint-disable-next-line no-param-reassign
                    m.returns.struct = structName;
                    if (!arc56.structs[structName]) {
                        arc56.structs[structName] = objectToStructFields(returnTypeInfo);
                    }
                }
                subroutine.node.getParameters().forEach((p) => {
                    const arg = m.args.find((a) => a.name === p.getName());
                    const typeInfo = this.getTypeInfo(p.getType());
                    if (typeInfo.kind === 'object') {
                        const structName = (p.getChildrenOfKind(ts.SyntaxKind.TypeReference)?.[0] || p.getType()).getText();
                        arg.struct = structName;
                        if (!arc56.structs[structName]) {
                            arc56.structs[structName] = objectToStructFields(typeInfo);
                        }
                    }
                });
            }
        });
        Object.keys(this.templateVars).forEach((k) => {
            const typeInfo = this.templateVars[k].type;
            let type = typeInfoToABIString(typeInfo);
            if (typeInfo.kind === 'object') {
                const structName = this.templateVars[k].initNode.getTypeArguments()[0].getText();
                if (!arc56.structs[structName]) {
                    arc56.structs[structName] = objectToStructFields(typeInfo);
                }
                type = structName;
            }
            arc56.templateVariables || (arc56.templateVariables = {});
            arc56.templateVariables[k] = { type };
        });
        Object.keys(this.scratch).forEach((k) => {
            const { slot } = this.scratch[k];
            if (slot === undefined)
                return;
            const typeInfo = this.scratch[k].type;
            let type = typeInfoToABIString(typeInfo);
            if (typeInfo.kind === 'object') {
                const structName = this.scratch[k].initNode.getTypeArguments()[0].getText();
                if (!arc56.structs[structName]) {
                    arc56.structs[structName] = objectToStructFields(typeInfo);
                }
                type = structName;
            }
            arc56.scratchVariables || (arc56.scratchVariables = {});
            arc56.scratchVariables[k] = { type, slot };
        });
        if (this.compiledPrograms.approval && this.compiledPrograms.clear) {
            arc56.byteCode = {
                approval: this.compiledPrograms.approval,
                clear: this.compiledPrograms.clear,
            };
        }
        if (this.algodVersion) {
            arc56.compilerInfo = {
                compiler: 'algod',
                compilerVersion: this.algodVersion,
            };
        }
        return arc56;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    arc32Description() {
        const approval = Buffer.from(this.teal.approval.map((t) => t.teal).join('\n')).toString('base64');
        const clear = Buffer.from(this.teal.clear.map((t) => t.teal).join('\n')).toString('base64');
        const globalDeclared = {};
        const localDeclared = {};
        const state = {
            global: {
                num_byte_slices: 0,
                num_uints: 0,
            },
            local: {
                num_byte_slices: 0,
                num_uints: 0,
            },
        };
        // eslint-disable-next-line no-restricted-syntax
        for (const [k, v] of Object.entries(this.storageProps)) {
            switch (v.type) {
                case 'global':
                    if (isNumeric(v.valueType)) {
                        state.global.num_uints += v.maxKeys || 1;
                        if (v.key)
                            globalDeclared[k] = { type: 'uint64', key: v.key };
                    }
                    else {
                        if (v.key)
                            globalDeclared[k] = { type: 'bytes', key: v.key };
                        state.global.num_byte_slices += v.maxKeys || 1;
                    }
                    break;
                case 'local':
                    if (isNumeric(v.valueType)) {
                        state.local.num_uints += v.maxKeys || 1;
                        if (v.key)
                            localDeclared[k] = { type: 'uint64', key: v.key };
                    }
                    else {
                        state.local.num_byte_slices += v.maxKeys || 1;
                        if (v.key)
                            localDeclared[k] = { type: 'bytes', key: v.key };
                    }
                    break;
                default:
                    break;
            }
        }
        if (state.global.num_uints + state.global.num_byte_slices > 64) {
            throw new Error('over allocated global state');
        }
        if (state.local.num_uints + state.local.num_byte_slices > 16) {
            throw new Error('over allocated local state');
        }
        const hints = {};
        const arc32 = {
            hints,
            bare_call_config: {
                no_op: this.bareCallConfig.NoOp?.action || 'NEVER',
                opt_in: this.bareCallConfig.OptIn?.action || 'NEVER',
                close_out: this.bareCallConfig.CloseOut?.action || 'NEVER',
                update_application: this.bareCallConfig.UpdateApplication?.action || 'NEVER',
                delete_application: this.bareCallConfig.DeleteApplication?.action || 'NEVER',
            },
            schema: {
                local: { declared: localDeclared, reserved: {} },
                global: { declared: globalDeclared, reserved: {} },
            },
            state,
            source: { approval, clear },
            contract: this.arc4Description(),
        };
        this.abi.methods.forEach((m) => {
            const signature = `${m.name}(${m.args.map((a) => typeInfoToABIString(a.type)).join(',')})${typeInfoToABIString(m.returns.type)
                .replace(/asset/g, 'uint64')
                .replace(/application/g, 'uint64')
                .replace(/account/g, 'address')}`;
            hints[signature] = {
                call_config: {},
            };
            const subroutine = this.subroutines.find((s) => s.name === m.name);
            subroutine.allows.create.forEach((oc) => {
                const snakeOC = oc
                    .split(/\.?(?=[A-Z])/)
                    .join('_')
                    .toLowerCase();
                hints[signature].call_config[snakeOC] = 'CREATE';
            });
            subroutine.allows.call.forEach((oc) => {
                if (oc === 'ClearState')
                    return;
                const snakeOC = oc
                    .split(/\.?(?=[A-Z])/)
                    .join('_')
                    .toLowerCase();
                hints[signature].call_config[snakeOC] = 'CALL';
            });
        });
        return arc32;
    }
    prettyTeal(teal) {
        const output = [];
        let comments = [];
        let hitFirstLabel = false;
        let lastIsLabel = false;
        teal.forEach((t, i) => {
            const tealLine = t.teal;
            if (tealLine === '// No extra bytes needed for this subroutine')
                return;
            if (tealLine === '//#pragma mode logicsig') {
                output.push({ node: this.classNode, teal: tealLine });
                return;
            }
            if (tealLine.startsWith('//')) {
                if (comments.length === 0 && output.at(-1).teal !== '' && !lastIsLabel)
                    output.push({ node: this.classNode, teal: '' });
                comments.push(tealLine);
                return;
            }
            const isLabel = !tealLine.startsWith('byte ') && tealLine.split('//')[0].endsWith(':');
            if (isLabel && output.at(-1).teal !== '')
                output.push({ node: this.classNode, teal: '' });
            hitFirstLabel = hitFirstLabel || isLabel;
            if (isLabel || tealLine.startsWith('#') || !hitFirstLabel) {
                comments.forEach((c) => output.push({ node: t.node, teal: c }));
                comments = [];
                output.push({ node: t.node, teal: tealLine });
                lastIsLabel = isLabel;
            }
            else {
                comments.forEach((c) => output.push({ node: t.node, teal: `\t${c.replace(/\n/g, '\n\t')}` }));
                comments = [];
                output.push({ node: t.node, teal: `\t${tealLine}`, errorMessage: t.errorMessage });
                lastIsLabel = false;
            }
        });
        return output;
    }
}
exports.default = Compiler;
Compiler.diagsRan = [''];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvbGliL2NvbXBpbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxzQ0FBc0M7QUFDdEMsZ0NBQWdDO0FBQ2hDLHlDQUF5QztBQUN6QyxtQ0FBbUM7QUFDbkMsNERBQStCO0FBQy9CLHlDQUEyQjtBQUMzQix3REFBMEM7QUFFMUMsNkNBQStCO0FBQy9CLHFDQUFxQztBQUNyQyx5Q0FBdUM7QUFDdkMsZ0RBQXdCO0FBQ3hCLDRFQUErQztBQUMvQyx3Q0FBcUM7QUFDckMseUNBQTBDO0FBRzFDLE1BQU0sa0JBQWtCLEdBQUcsQ0FBQyxlQUFlLEVBQUUsZ0JBQWdCLEVBQUUsbUJBQW1CLEVBQUUsY0FBYyxDQUFDLENBQUM7QUFLcEcsTUFBTSxZQUFZLEdBQTBGO0lBQzFHLE1BQU07SUFDTixPQUFPO0lBQ1AsVUFBVTtJQUNWLFlBQVk7SUFDWixtQkFBbUI7SUFDbkIsbUJBQW1CO0NBQ3BCLENBQUM7QUF5RkYsS0FBSyxVQUFVLFlBQVksQ0FBQyxXQUFtQjtJQUM3QyxNQUFNLE1BQU0sR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQVMsRUFBRSxFQUFFO1FBQ3RELE1BQU0sT0FBTyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDOUIsSUFBSSxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUM7WUFBRSxPQUFPLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMxQyxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDLENBQUMsQ0FBQztJQUVILElBQUksUUFBUSxHQUFHLENBQUMsQ0FBQztJQUVqQixNQUFNLFFBQVEsR0FHVjtRQUNGLFFBQVEsRUFBRSxFQUFFO1FBQ1osUUFBUSxFQUFFLEVBQUU7S0FDYixDQUFDO0lBRUYsZ0RBQWdEO0lBQ2hELEtBQUssTUFBTSxDQUFDLEVBQUUsRUFBRSxTQUFTLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxFQUFFLEVBQUU7UUFDOUMscUVBQXFFO1FBQ3JFLHVCQUF1QjtRQUN2QixJQUFJLFNBQVMsS0FBSyxTQUFTLEVBQUU7WUFDM0IsUUFBUSxJQUFJLFNBQVMsQ0FBQztTQUN2QjtRQUVELElBQUksQ0FBQyxDQUFDLFFBQVEsSUFBSSxRQUFRLENBQUMsUUFBUSxDQUFDO1lBQUUsUUFBUSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUM7UUFFdkUsUUFBUSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFckMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUM7S0FDbEM7SUFDRCxPQUFPLFFBQVEsQ0FBQztBQUNsQixDQUFDO0FBRUQsU0FBUyxtQkFBbUIsQ0FBQyxRQUFrQixFQUFFLGNBQXVCLEtBQUs7SUFDM0UsSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLE1BQU0sRUFBRTtRQUM1QixJQUFJLFdBQVcsSUFBSSxDQUFDLGNBQWMsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDN0UsT0FBTyxRQUFRLENBQUM7U0FDakI7UUFFRCxJQUFJLFdBQVcsSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLGtCQUFrQixFQUFFO1lBQ3ZELE9BQU8sU0FBUyxDQUFDO1NBQ2xCO1FBRUQsT0FBTyxRQUFRLENBQUMsSUFBSTthQUNqQixPQUFPLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQzthQUMxQixPQUFPLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQzthQUM1QixPQUFPLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQzthQUMxQixPQUFPLENBQUMsb0JBQW9CLEVBQUUsU0FBUyxDQUFDO2FBQ3hDLE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRSxhQUFhLENBQUM7YUFDeEMsT0FBTyxDQUFDLGtCQUFrQixFQUFFLE9BQU8sQ0FBQyxDQUFDO0tBQ3pDO0lBRUQsSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLE9BQU8sRUFBRTtRQUM3QixPQUFPLElBQUksUUFBUSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLG1CQUFtQixDQUFDLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO0tBQzNGO0lBRUQsSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLGNBQWMsRUFBRTtRQUNwQyxPQUFPLEdBQUcsbUJBQW1CLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsSUFBSSxDQUFDO0tBQy9EO0lBRUQsSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLGFBQWEsRUFBRTtRQUNuQyxPQUFPLEdBQUcsbUJBQW1CLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsSUFBSSxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUM7S0FDakY7SUFFRCxJQUFJLFFBQVEsQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO1FBQzlCLE9BQU8sSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUM7YUFDMUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUM7YUFDL0MsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7S0FDakI7SUFFRCxJQUFJLFFBQVEsQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO1FBQzlCLE9BQU8sTUFBTSxDQUFDO0tBQ2Y7SUFFRCxNQUFNLEtBQUssRUFBRSxDQUFDO0FBQ2hCLENBQUM7QUFFRCxTQUFTLFVBQVUsQ0FBQyxDQUFXLEVBQUUsQ0FBVyxFQUFFLGVBQXdCLEtBQUs7SUFDekUsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLE1BQU0sSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLFdBQVcsRUFBRTtRQUMvQyxPQUFPO1FBQ0wsZ0RBQWdEO1FBQ2hELE9BQU8sQ0FBQyxDQUFDLENBQUM7WUFDVixnREFBZ0Q7WUFDaEQsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLGFBQWEsSUFBSSxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzdDLGdEQUFnRDtZQUNoRCxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssY0FBYyxJQUFJLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDOUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLE1BQU0sSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLFNBQVMsQ0FBQyxDQUM1QyxDQUFDO0tBQ0g7SUFFRCxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssTUFBTSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssU0FBUyxFQUFFO1FBQzdDLE9BQU87UUFDTCxnREFBZ0Q7UUFDaEQsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUNiLENBQUM7S0FDSDtJQUVELElBQUksWUFBWSxFQUFFO1FBQ2hCLE9BQU8sbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsS0FBSyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0tBQ3hHO0lBQ0QsT0FBTyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsS0FBSyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMzRCxDQUFDO0FBRUQsd0RBQXdEO0FBQ3hELGdEQUFnRDtBQUNoRCxNQUFNLFlBQWEsU0FBUSxLQUFtQjtJQWdCNUMsWUFBWSxJQUFjLEVBQUUsVUFBa0I7UUFDNUMsS0FBSyxFQUFFLENBQUM7UUFWVixpQkFBWSxHQUFXLENBQUMsQ0FBQztRQVl2QixJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVE7WUFBRSxPQUFPO1FBRXJDLElBQUksQ0FBQyxFQUFFLEdBQUcsWUFBWSxDQUFDLFNBQVMsQ0FBQztRQUNqQyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztRQUU3QixZQUFZLENBQUMsU0FBUyxJQUFJLENBQUMsQ0FBQztRQUU1QixJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssYUFBYSxFQUFFO1lBQy9CLElBQUksQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDO1lBQzFCLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztTQUNqQzthQUFNLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxjQUFjLEVBQUU7WUFDdkMsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7U0FDNUI7YUFBTSxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO1lBQzFELElBQUksQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDO1NBQzFCO0lBQ0gsQ0FBQztJQUVELEdBQUcsQ0FBQyxHQUFHLFFBQXdCO1FBQzdCLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFlLEVBQUUsRUFBRTtZQUNuQyxDQUFDLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztRQUNsQixDQUFDLENBQUMsQ0FBQztRQUNILE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDO0lBQ2hDLENBQUM7O0FBNUJNLHNCQUFTLEdBQUcsQ0FBQyxDQUFDO0FBK0J2QixTQUFTLGNBQWMsQ0FBQyxJQUFxRDtJQUMzRSxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsd0JBQXdCLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUMxRSxNQUFNLFFBQVEsR0FBRyxRQUFRLEVBQUUsZUFBZSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUMsQ0FBQztJQUVuRixPQUFPLFFBQVEsRUFBRSxPQUFPLEVBQUUsQ0FBQztBQUM3QixDQUFDO0FBRUQsU0FBUyxrQkFBa0IsQ0FBQyxJQUFtQjtJQUM3QyxJQUFJLElBQUksWUFBWSxLQUFLLENBQUMsWUFBWSxFQUFFO1FBQ3RDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztLQUNsQjtJQUNELElBQUksSUFBSSxZQUFZLEtBQUssQ0FBQyxZQUFZLEVBQUU7UUFDdEMsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUNELElBQUksSUFBSSxZQUFZLEtBQUssQ0FBQyxZQUFZLEVBQUU7UUFDdEMsT0FBTyxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxHQUFHLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQztLQUNyRTtJQUNELHdDQUF3QztJQUN4QyxPQUFPLEVBQUUsQ0FBQztBQUNaLENBQUM7QUFFRCxTQUFTLGFBQWEsQ0FBQyxPQUFzQjtJQUMzQyxJQUFJLE1BQU0sR0FBVyxFQUFFLENBQUM7SUFDeEIsSUFBSSxPQUFPLEVBQUU7UUFDWCxnREFBZ0Q7UUFDaEQsS0FBSyxNQUFNLFNBQVMsSUFBSSxPQUFPLENBQUMsYUFBYSxFQUFFLEVBQUU7WUFDL0MsTUFBTSxJQUFJLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQ3pDO0tBQ0Y7SUFDRCxPQUFPLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQztBQUN2QixDQUFDO0FBRUQsU0FBUyxrQkFBa0IsQ0FBQyxHQUFXO0lBQ3JDLElBQUksR0FBRyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUN2QixNQUFNLE9BQU8sR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsRUFBRSxjQUFjLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRTlGLE1BQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUErQixDQUFDO1FBRXRFLE9BQU8sU0FBUyxDQUFDLElBQUksQ0FBQztLQUN2QjtJQUVELE1BQU0sT0FBTyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztJQUM5RSxPQUFRLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUErQixDQUFDLFVBQVUsQ0FBQztBQUN6RSxDQUFDO0FBRUQsU0FBUyxtQkFBbUIsQ0FBQyxHQUFXO0lBQ3RDLE9BQU8sR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztBQUN6RCxDQUFDO0FBRUQsa0RBQWtEO0FBQ2xELE1BQU0sU0FBUyxHQUFHO0lBQ2hCLElBQUksRUFBRSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBYztJQUNoRCxNQUFNLEVBQUUsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQWM7SUFDcEQsS0FBSyxFQUFFLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFjO0lBQ2xELEdBQUcsRUFBRSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBYztDQUMvQyxDQUFDO0FBRUYsNkNBQTZDO0FBQzdDLHFDQUFxQztBQUNyQyxJQUFLLGVBUUo7QUFSRCxXQUFLLGVBQWU7SUFDbEIsb0NBQWlCLENBQUE7SUFDakIsK0NBQTRCLENBQUE7SUFDNUIseUNBQXNCLENBQUE7SUFDdEIsNENBQXlCLENBQUE7SUFDekIseUNBQXNCLENBQUE7SUFDdEIsNkNBQTBCLENBQUE7SUFDMUIsd0NBQXFCLENBQUE7QUFDdkIsQ0FBQyxFQVJJLGVBQWUsS0FBZixlQUFlLFFBUW5CO0FBRUQsTUFBTSxXQUFXLEdBQUc7SUFDbEIsS0FBSyxFQUFFLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFjO0lBQ3BELE9BQU8sRUFBRSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBYztJQUN0RCxXQUFXLEVBQUUsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQWM7Q0FDekQsQ0FBQztBQUVGLE1BQU0sU0FBUyxHQUFHLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFFNUUsTUFBTSxXQUFXLEdBQUc7SUFDbEIsU0FBUztJQUNULFNBQVM7SUFDVCxZQUFZO0lBQ1osZUFBZTtJQUNmLGVBQWU7SUFDZixhQUFhO0lBQ2IsYUFBYTtJQUNiLHVCQUF1QjtJQUN2Qix3QkFBd0I7Q0FDekIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUUxQyxNQUFNLGNBQWMsR0FBRyxVQUFVLENBQUM7QUFDbEMsTUFBTSxVQUFVLEdBQUcsVUFBVSxDQUFDO0FBRTlCLE1BQU0sV0FBVyxHQUFnQztJQUMvQyxTQUFTO0lBQ1Qsb0JBQW9CLEVBQUUsT0FBTztJQUM3QixNQUFNO0lBQ04sU0FBUyxFQUFFLFNBQVM7SUFDcEIsYUFBYSxFQUFFLE9BQU87SUFDdEIsV0FBVyxFQUFFLFNBQVM7SUFDdEIsV0FBVyxFQUFFLFNBQVM7SUFDdEIsY0FBYyxFQUFFLFNBQVM7SUFDekIsb0JBQW9CLEVBQUUsT0FBTztJQUM3QixlQUFlLEVBQUUsdUJBQXVCO0lBQ3hDLFlBQVksRUFBRSx1QkFBdUI7SUFDckMsTUFBTSxFQUFFLHlCQUF5QjtJQUNqQyxRQUFRLEVBQUUseUJBQXlCO0NBQ3BDLENBQUM7QUFvQ0Ysc0RBQXNEO0FBQ3RELFNBQVMsU0FBUyxDQUFDLENBQVc7SUFDNUIsT0FBTyxDQUFDLENBQUMsSUFBSSxLQUFLLE1BQU0sSUFBSSxDQUFDLFFBQVEsRUFBRSxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUM5RSxDQUFDO0FBRUQsU0FBUyxPQUFPLENBQUMsQ0FBVztJQUMxQixPQUFPLENBQUMsQ0FBQyxJQUFJLEtBQUssTUFBTSxJQUFJLENBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNyRixDQUFDO0FBRUQsU0FBUyxTQUFTLENBQUMsQ0FBVztJQUM1QixPQUFPLENBQUMsQ0FBQyxJQUFJLEtBQUssTUFBTSxJQUFJLENBQUMsa0JBQWtCLEVBQUUsZ0JBQWdCLEVBQUUsY0FBYyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN0RyxDQUFDO0FBRUQsU0FBUyxjQUFjLENBQUMsU0FBbUI7SUFDekMsSUFBSSxTQUFTLENBQUMsSUFBSSxLQUFLLFFBQVE7UUFBRSxNQUFNLEtBQUssRUFBRSxDQUFDO0lBRS9DLE9BQU8sU0FBUyxDQUFDLFVBQVUsQ0FBQztBQUM5QixDQUFDO0FBRUQsU0FBUyxXQUFXLENBQUMsSUFBYztJQUNqQyxPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssTUFBTSxDQUFDO0FBQzlCLENBQUM7QUFFRCxTQUFTLGNBQWMsQ0FBQyxTQUFtQixFQUFFLFlBQXNCLEVBQUUsZUFBd0IsS0FBSztJQUNoRyxJQUFJLFVBQVUsQ0FBQyxZQUFZLEVBQUUsU0FBUyxDQUFDLEdBQUcsQ0FBQztRQUFFLE9BQU87SUFDcEQsSUFBSSxVQUFVLENBQUMsU0FBUyxFQUFFLFlBQVksRUFBRSxZQUFZLENBQUM7UUFBRSxPQUFPO0lBQzlELElBQUksU0FBUyxDQUFDLElBQUksS0FBSyxNQUFNLElBQUksWUFBWSxDQUFDLElBQUksS0FBSyxNQUFNLEVBQUU7UUFDN0QsSUFBSSxZQUFZLENBQUMsSUFBSSxLQUFLLEtBQUssSUFBSSxTQUFTLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUM7WUFBRSxPQUFPO1FBQzlFLE1BQU0sU0FBUyxHQUFHO1lBQ2hCLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQztZQUN0QixDQUFDLE9BQU8sRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0sQ0FBQztTQUN0QyxDQUFDO1FBRUYsSUFBSSxZQUFZLEdBQUcsS0FBSyxDQUFDO1FBRXpCLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtZQUN0QixJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUMvRCxZQUFZLEdBQUcsSUFBSSxDQUFDO2FBQ3JCO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLFlBQVk7WUFBRSxPQUFPO0tBQzFCO0lBRUQsTUFBTSxLQUFLLENBQUMsc0JBQXNCLG1CQUFtQixDQUFDLFNBQVMsQ0FBQyxhQUFhLG1CQUFtQixDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNwSCxDQUFDO0FBRUQsU0FBUyxhQUFhLENBQUMsSUFBYztJQUNuQyxNQUFNLE9BQU8sR0FBRyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUUxQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUFFLE9BQU8sS0FBSyxDQUFDO0lBQ2xGLE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDL0MsSUFBSSxPQUFPLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQztRQUFFLE9BQU8sSUFBSSxDQUFDO0lBRWhELE9BQU8sS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUNwQixDQUFDO0FBRUQsTUFBTSxlQUFlLEdBQUc7SUFDdEIsU0FBUyxFQUFFLG1CQUFtQjtJQUM5QixZQUFZLEVBQUUsc0JBQXNCO0lBQ3BDLGFBQWEsRUFBRSx1QkFBdUI7SUFDdEMsVUFBVSxFQUFFLG9CQUFvQjtJQUNoQyxpQkFBaUIsRUFBRSw0QkFBNEI7SUFDL0MsZ0JBQWdCLEVBQUUsMEJBQTBCO0lBQzVDLHNCQUFzQixFQUFFLGlDQUFpQztJQUN6RCxjQUFjLEVBQUUsd0JBQXdCO0lBQ3hDLFdBQVcsRUFBRSxxQkFBcUI7SUFDbEMsZ0JBQWdCLEVBQUUsMkJBQTJCO0lBQzdDLGVBQWUsRUFBRSx5QkFBeUI7Q0FDM0MsQ0FBQztBQVFGLGdCQUFnQjtBQUNoQixNQUFxQixRQUFRO0lBa1QzQixnRUFBZ0U7SUFDeEQsYUFBYSxDQUFDLElBQWEsRUFBRSxJQUFjO1FBQ2pELElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxNQUFNLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxNQUFNLEVBQUU7WUFDaEQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1NBQ3pDO2FBQU0sSUFBSSxJQUFJLENBQUMsMEJBQTBCLENBQUMsSUFBSSxDQUFDLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ2pFLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLGFBQWEsQ0FBQyxDQUFDO1NBQ3BDO2FBQU0sSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksYUFBYSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ2pELElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQzdCO0lBQ0gsQ0FBQztJQUVPLGVBQWUsQ0FBQyxJQUFhLEVBQUUsV0FBc0I7UUFDM0QsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsZUFBZSxFQUFFLElBQUksV0FBVyxFQUFFO1lBQ25ELElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxJQUFJLEVBQUUsV0FBVyxDQUFDLENBQUM7U0FDdkQ7YUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFO1lBQ3RELElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDMUM7YUFBTTtZQUNMLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDeEI7UUFFRCxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUMsRUFBRTtZQUM1QyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFLEtBQUssRUFBRSxTQUFTLGVBQWUsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDO1NBQzVGO0lBQ0gsQ0FBQztJQUVELCtEQUErRDtJQUN2RCxtQkFBbUIsQ0FBQyxFQUMxQixJQUFJLEVBQ0osTUFBTSxFQUNOLGVBQWUsRUFDZixtQkFBbUIsRUFDbkIsUUFBUSxHQWVUO1FBQ0MsTUFBTSxJQUFJLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBRSxDQUFDO1FBQ25DLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQywrQkFBK0IsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ2pGLE1BQU0sZUFBZSxHQUFHLFFBQVEsQ0FBQyxzQkFBc0IsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDLENBQUM7UUFDaEcsTUFBTSxtQkFBbUIsR0FBRyxlQUFlLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLENBQUM7UUFFMUYsTUFBTSxZQUFZLEdBQUcsQ0FBQyxtQkFBbUIsSUFBSSxlQUFlLENBQUMsQ0FBQyxzQkFBc0IsQ0FDbEYsRUFBRSxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsQ0FDdkMsQ0FBQztRQUNGLE1BQU0sWUFBWSxHQUFHLFlBQVksQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUVoRixNQUFNLElBQUksR0FBYyxFQUFFLENBQUM7UUFDM0IsSUFBSSxPQUFnQixDQUFDO1FBRXJCLHlGQUF5RjtRQUN6Rix3RkFBd0Y7UUFDeEYsSUFBSSxZQUFZLEtBQUssU0FBUyxFQUFFO1lBQzlCLFlBQVksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMxRDtRQUVELDZDQUE2QztRQUM3QyxJQUFJLEdBQUcsWUFBWSxDQUFDO1FBRXBCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUVsQyx1REFBdUQ7UUFDdkQsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLEVBQUU7WUFDN0MsT0FBTyxHQUFHLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN6RTtRQUVELE1BQU0sRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFdkYsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDO1FBRXpCLGtFQUFrRTtRQUNsRSxJQUFJLG1CQUFtQixJQUFJLFdBQVcsS0FBSyxPQUFPLEVBQUU7WUFDbEQsSUFBSSxDQUFDLFFBQVEsQ0FDWCxJQUFJLENBQUMsYUFBYSxFQUFFLEVBQ3BCLGFBQWEsSUFBSSxDQUFDLGNBQWMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLEtBQUssT0FBTyxtQkFBbUIsRUFBRSxDQUN4RixDQUFDO1lBRUYsOERBQThEO1NBQy9EO2FBQU0sSUFBSSxXQUFXLEtBQUssT0FBTyxFQUFFO1lBQ2xDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDO2dCQUFFLE1BQU0sS0FBSyxFQUFFLENBQUM7WUFDOUQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMxQztRQUVELDRFQUE0RTtRQUM1RSx1REFBdUQ7UUFDdkQsSUFBSSxNQUFNLEtBQUssUUFBUSxJQUFJLENBQUMsV0FBVyxLQUFLLFFBQVEsSUFBSSxXQUFXLEtBQUssT0FBTyxDQUFDLEVBQUU7WUFDaEYsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLEVBQUUscUJBQXFCLENBQUMsQ0FBQztTQUM1RDtRQUVELDhFQUE4RTtRQUM5RSxJQUFJLEdBQUcsRUFBRTtZQUNQLE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzdDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxFQUFFLFVBQVUsR0FBRyxRQUFRLEdBQUcsR0FBRyxDQUFDLENBQUM7WUFFakUsK0JBQStCO1NBQ2hDO2FBQU0sSUFBSSxlQUFlLEVBQUU7WUFDMUIsSUFBSSxDQUFDLFFBQVEsQ0FDWCxJQUFJLENBQUMsYUFBYSxFQUFFLEVBQ3BCLGFBQWEsSUFBSSxDQUFDLGNBQWMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxLQUFLLE9BQU8sZUFBZSxFQUFFLENBQ2hGLENBQUM7WUFFRix3Q0FBd0M7U0FDekM7YUFBTTtZQUNMLElBQUksTUFBTSxFQUFFO2dCQUNWLE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUNoRCxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQVEsRUFBRSxVQUFVLEdBQUcsUUFBUSxNQUFNLEdBQUcsQ0FBQyxDQUFDO2FBQ3pEO1lBQ0QsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztZQUNuQyxJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQztZQUN4QixJQUFJLENBQUMsV0FBVyxDQUFDLE9BQVEsQ0FBQyxDQUFDO1lBQzNCLElBQUksQ0FBQyxRQUFRLEdBQUcsWUFBWSxDQUFDO1lBRTdCLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDekMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQzdDO1lBRUQsSUFBSSxNQUFNO2dCQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1NBQy9DO1FBRUQsUUFBUSxNQUFNLEVBQUU7WUFDZCxLQUFLLEtBQUs7Z0JBQ1IsSUFBSSxXQUFXLEtBQUssUUFBUSxFQUFFO29CQUM1QixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsRUFBRSxnQkFBZ0IsRUFBRSxTQUFTLENBQUMsQ0FBQztpQkFDOUQ7cUJBQU0sSUFBSSxXQUFXLEtBQUssT0FBTyxFQUFFO29CQUNsQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsRUFBRSxlQUFlLEVBQUUsU0FBUyxDQUFDLENBQUM7aUJBQzdEO3FCQUFNLElBQUksV0FBVyxLQUFLLEtBQUssRUFBRTtvQkFDaEMsSUFBSSxDQUFDLGdCQUFnQixDQUNuQixJQUFJLENBQUMsYUFBYSxFQUFFLEVBQ3BCLFNBQVMsRUFDVCxTQUFTLEVBQ1QsNkJBQTZCLElBQUk7eUJBQzlCLE9BQU8sRUFBRTt5QkFDVCxLQUFLLENBQUMsSUFBSSxDQUFDO3lCQUNYLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO3lCQUNwQixJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FDZixDQUFDO2lCQUNIO2dCQUVELElBQUksQ0FBQyxXQUFXLEtBQUssS0FBSyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRTtvQkFDL0YsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7aUJBQ3JDO2dCQUVELE1BQU07WUFFUixLQUFLLEtBQUssQ0FBQyxDQUFDO2dCQUNWLElBQUksV0FBVyxLQUFLLEtBQUssSUFBSSxXQUFXLEVBQUU7b0JBQ3hDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUM7aUJBQy9EO2dCQUVELElBQUksUUFBUSxFQUFFO29CQUNaLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7b0JBQ25DLElBQUksQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDO29CQUMxQixJQUFJLENBQUMsZUFBZSxDQUFDLFFBQVEsQ0FBQyxDQUFDO29CQUMvQixJQUFJLENBQUMsUUFBUSxHQUFHLFlBQVksQ0FBQztvQkFFN0IsNEJBQTRCO29CQUM1Qiw0QkFBNEI7b0JBQzVCLElBQUksQ0FBQyxXQUFXLEtBQUssS0FBSyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRTt3QkFDL0YsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO3FCQUM3QztvQkFFRCxjQUFjLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQztpQkFDMUM7cUJBQU07b0JBQ0wsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUssTUFBTSxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQztvQkFDM0YsSUFBSSxRQUFRLEVBQUU7d0JBQ1osSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO3FCQUN6QztvQkFFRCxNQUFNLE9BQU8sR0FBRyxXQUFXLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLFdBQVcsS0FBSyxPQUFPLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO29CQUNoRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQztvQkFFN0MsSUFBSSxDQUFDLFdBQVcsS0FBSyxLQUFLLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLEVBQUUsU0FBUyxDQUFDLEtBQUssQ0FBQyxFQUFFO3dCQUMvRixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztxQkFDckM7aUJBQ0Y7Z0JBRUQsTUFBTSxTQUFTLEdBQ2IsV0FBVyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLFdBQVcsS0FBSyxPQUFPLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO2dCQUN0RyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsRUFBRSxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUM7Z0JBQ3RELE1BQU07YUFDUDtZQUVELEtBQUssUUFBUSxDQUFDLENBQUM7Z0JBQ2IsTUFBTSxZQUFZLEdBQ2hCLFdBQVcsS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxXQUFXLEtBQUssT0FBTyxDQUFDLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO2dCQUM1RyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsRUFBRSxZQUFZLENBQUMsQ0FBQztnQkFDdkQsTUFBTTthQUNQO1lBRUQsS0FBSyxRQUFRLENBQUMsQ0FBQztnQkFDYixNQUFNLFlBQVksR0FDaEIsV0FBVyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLFdBQVcsS0FBSyxPQUFPLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO2dCQUN0RyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsRUFBRSxZQUFZLENBQUMsQ0FBQztnQkFDbEQsTUFBTTthQUNQO1lBRUQsS0FBSyxRQUFRO2dCQUNYLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUM7b0JBQUUsTUFBTSxLQUFLLENBQUMsdUNBQXVDLE9BQU8sRUFBRSxDQUFDLENBQUM7Z0JBRTNHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzFCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxFQUFFLFlBQVksQ0FBQyxDQUFDO2dCQUNsRCxNQUFNO1lBRVIsS0FBSyxRQUFRO2dCQUNYLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUM7b0JBQUUsTUFBTSxLQUFLLENBQUMsdUNBQXVDLE9BQU8sRUFBRSxDQUFDLENBQUM7Z0JBRTNHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzFCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzFCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzFCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxFQUFFLFlBQVksQ0FBQyxDQUFDO2dCQUNsRCxNQUFNO1lBRVIsS0FBSyxRQUFRO2dCQUNYLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFO29CQUNYLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQzNCO3FCQUFNLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsRUFBRTtvQkFDeEMsTUFBTSxLQUFLLENBQ1Qsb0VBQW9FLG1CQUFtQixDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQ3RHLENBQUM7aUJBQ0g7O29CQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBRW5FLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxFQUFFLFlBQVksRUFBRSxLQUFLLENBQUMsQ0FBQztnQkFDMUQsTUFBTTtZQUVSLEtBQUssU0FBUztnQkFDWixJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUU7b0JBQ3RCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQzFCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQzNCO3FCQUFNO29CQUNMLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDO2lCQUNoRDtnQkFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsRUFBRSxhQUFhLEVBQUUsU0FBUyxDQUFDLENBQUM7Z0JBQzFELE1BQU07WUFFUixLQUFLLFNBQVM7Z0JBQ1osSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFO29CQUN0QixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUMxQixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUMzQjtxQkFBTTtvQkFDTCxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsRUFBRSxTQUFTLENBQUMsQ0FBQztpQkFDaEQ7Z0JBQ0QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLEVBQUUsYUFBYSxDQUFDLENBQUM7Z0JBQ25ELE1BQU07WUFFUixLQUFLLE1BQU07Z0JBQ1QsSUFBSSxDQUFDLGdCQUFnQixDQUNuQixJQUFJLENBQUMsYUFBYSxFQUFFLEVBQ3BCLFNBQVMsRUFDVCxTQUFTLENBQUMsTUFBTSxFQUNoQiw2QkFBNkIsSUFBSTtxQkFDOUIsT0FBTyxFQUFFO3FCQUNULEtBQUssQ0FBQyxJQUFJLENBQUM7cUJBQ1gsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7cUJBQ3BCLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUNmLENBQUM7Z0JBQ0YsTUFBTTtZQUNSO2dCQUNFLE1BQU0sSUFBSSxLQUFLLEVBQUUsQ0FBQztTQUNyQjtJQUNILENBQUM7SUEwQk8sV0FBVyxDQUFDLElBQXlCO1FBQzNDLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxLQUFLLGNBQWM7WUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsZUFBZSxFQUFFLENBQUM7UUFDdEYsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLEtBQUssZUFBZTtZQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxnQkFBZ0IsRUFBRSxDQUFDO1FBQ3hGLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxLQUFLLGlCQUFpQjtZQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxtQkFBbUIsRUFBRSxDQUFDO1FBQzdGLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxLQUFLLGFBQWE7WUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsY0FBYyxFQUFFLENBQUM7UUFDcEYsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFO1lBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxDQUFDO1FBQ3BFLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRTtZQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsQ0FBQztRQUNwRSxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLENBQUM7UUFFekQsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLEtBQUssU0FBUyxFQUFFO1lBQ2hDLE1BQU0sS0FBSyxDQUNULDBQQUEwUCxDQUMzUCxDQUFDO1NBQ0g7UUFFRCxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUUsS0FBSyxhQUFhLEVBQUU7WUFDcEMsTUFBTSxLQUFLLENBQ1QsNlBBQTZQLENBQzlQLENBQUM7U0FDSDtRQUVELElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxLQUFLLE9BQU8sRUFBRTtZQUM5QixNQUFNLEtBQUssQ0FDVCwwUEFBMFAsQ0FDM1AsQ0FBQztTQUNIO1FBRUQsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxFQUFFO1lBQzFDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNuRSxJQUFJLFFBQVEsQ0FBQyxJQUFJLEtBQUssTUFBTTtnQkFBRSxNQUFNLEtBQUssQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDO1lBQzlFLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxXQUFXLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDO1NBQzNEO1FBRUQsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLEtBQUssS0FBSztZQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsQ0FBQztRQUNuRSxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUUsS0FBSyx5QkFBeUI7WUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLENBQUM7UUFDdkYsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLEtBQUssK0JBQStCO1lBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxDQUFDO1FBQy9GLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxLQUFLLFlBQVk7WUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLENBQUM7UUFDM0UsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLEtBQUssd0JBQXdCO1lBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxDQUFDO1FBQ3pGLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxLQUFLLDZCQUE2QjtZQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQztRQUM1RixJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUUsS0FBSyw2QkFBNkI7WUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLENBQUM7UUFFNUYsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXRELE1BQU0sVUFBVSxHQUFHLENBQUMsZUFBZSxFQUFFLE9BQU8sRUFBRSxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQzthQUM5RCxXQUFXLEVBQUU7YUFDYixPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQzthQUNqQixPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQzthQUNqQixPQUFPLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQzthQUN0QixPQUFPLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBRXhCLElBQUksVUFBVSxLQUFLLE1BQU07WUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLENBQUM7UUFFakUsTUFBTSxRQUFRLEdBQUc7WUFDZixhQUFhLEVBQUUsS0FBSztZQUNwQixhQUFhLEVBQUUsS0FBSztZQUNwQixTQUFTLEVBQUUsTUFBTTtZQUNqQixtQkFBbUIsRUFBRSxPQUFPO1lBQzVCLGlCQUFpQixFQUFFLE1BQU07WUFDekIsaUJBQWlCLEVBQUUsTUFBTTtZQUN6QixpQkFBaUIsRUFBRSxNQUFNO1lBQ3pCLGtCQUFrQixFQUFFLFFBQVE7WUFDNUIsZ0JBQWdCLEVBQUUsTUFBTTtTQUNJLENBQUM7UUFFL0IsSUFBSSxRQUFRLENBQUMsVUFBVSxDQUFDO1lBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDO1FBQzlFLElBQUksVUFBVSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsRUFBRTtZQUN2QyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQztZQUM5QyxJQUFJLElBQUksR0FBZSxFQUFFLENBQUM7WUFDMUIsTUFBTSxPQUFPLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQztZQUMvQixJQUFJLElBQXdCLENBQUM7WUFFN0IsSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUU7Z0JBQ3pCLElBQUksR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUN2RTtpQkFBTTtnQkFDTCxNQUFNLEdBQUcsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDL0MsSUFBSSxHQUFJLEdBQUcsQ0FBQyxjQUFjLEVBQTJCLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBRWhFLElBQUksR0FBRyxHQUFHLENBQUMsYUFBYSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUM7YUFDbkc7WUFFRCxPQUFPO2dCQUNMLElBQUksRUFBRSxRQUFRO2dCQUNkLElBQUk7Z0JBQ0osT0FBTzthQUNSLENBQUM7U0FDSDtRQUNELElBQUksVUFBVSxLQUFLLFlBQVk7WUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLENBQUM7UUFDdkUsSUFBSSxVQUFVLEtBQUssU0FBUztZQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsYUFBYSxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLEVBQUUsQ0FBQztRQUMvRyxJQUFJLFVBQVUsS0FBSyxTQUFTO1lBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxhQUFhLEVBQUUsTUFBTSxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsRUFBRSxDQUFDO1FBRS9HLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtZQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQztRQUV2RixJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUUsRUFBRTtZQUNsQixNQUFNLFFBQVEsR0FBYTtnQkFDekIsSUFBSSxFQUFFLE9BQU87Z0JBQ2IsUUFBUSxFQUFFLEVBQUU7YUFDYixDQUFDO1lBRUYsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3BDLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM5QyxDQUFDLENBQUMsQ0FBQztZQUVILE9BQU8sUUFBUSxDQUFDO1NBQ2pCO1FBRUQsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUU7WUFDbEIsT0FBTztnQkFDTCxJQUFJLEVBQUUsY0FBYztnQkFDcEIsSUFBSSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLG1CQUFtQixFQUFHLENBQUM7YUFDcEQsQ0FBQztTQUNIO1FBRUQsSUFBSSxDQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUUsU0FBUyxFQUFFLGdCQUFnQixFQUFFLGNBQWMsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUM5RyxPQUFPO2dCQUNMLElBQUksRUFBRSxNQUFNO2dCQUNaLElBQUksRUFBRSxVQUFVO2FBQ2pCLENBQUM7U0FDSDtRQUVELElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFFO1lBQ25CLE1BQU0sUUFBUSxHQUFhLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxVQUFVLEVBQUUsRUFBRSxFQUFFLENBQUM7WUFDOUQsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO2dCQUNqQyxDQUFDLENBQUMsZUFBZSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7b0JBQ2hDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsaUJBQWlCLENBQUM7d0JBQUUsTUFBTSxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDLFdBQVcsRUFBRSxFQUFFLENBQUMsQ0FBQztvQkFDcEcsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUcsQ0FBQyxDQUFDO2dCQUNwRSxDQUFDLENBQUMsQ0FBQztZQUNMLENBQUMsQ0FBQyxDQUFDO1lBRUgsT0FBTyxRQUFRLENBQUM7U0FDakI7UUFFRCxJQUFJLGVBQWUsRUFBRSxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsSUFBSSxlQUFlLEVBQUUsT0FBTyxFQUFFLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxFQUFFO1lBQ2hILE1BQU0sUUFBUSxHQUFHLGVBQWUsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBRXBELE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztZQUV2RCxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDO2dCQUFFLE1BQU0sS0FBSyxDQUFDLCtDQUErQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQzlHLE9BQU87Z0JBQ0wsSUFBSSxFQUFFLGFBQWE7Z0JBQ25CLE1BQU07Z0JBQ04sSUFBSSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO2FBQzlDLENBQUM7U0FDSDtRQUVELElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsRUFBRTtZQUM1QyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQztZQUM5QyxNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7WUFDN0MsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztnQkFBRSxNQUFNLEtBQUssQ0FBQyw2Q0FBNkMsQ0FBQyxDQUFDO1lBRXJGLE9BQU87Z0JBQ0wsSUFBSSxFQUFFLGFBQWE7Z0JBQ25CLE1BQU07Z0JBQ04sSUFBSSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3BDLENBQUM7U0FDSDtRQUVELElBQ0UsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLFFBQVEsRUFBRTtZQUNuQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsUUFBUSxFQUFFO1lBQ25DLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDZixJQUFJLENBQUMsUUFBUSxFQUFFLEVBQ2Y7WUFDQSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsVUFBVSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLEVBQUUsQ0FBQztTQUN2RTtRQUVELElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRSxFQUFFO1lBQzFCLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsQ0FBQztTQUN6QztRQUVELElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRSxFQUFFO1lBQzFCLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsQ0FBQztTQUN6QztRQUVELElBQUksSUFBSSxDQUFDLEtBQUssRUFBRSxFQUFFO1lBQ2hCLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsQ0FBQztTQUN0QztRQUVELElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxVQUFVLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLEVBQUU7WUFDdEUsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxDQUFDO1NBQzNDO1FBRUQsSUFBSSxVQUFVLEtBQUsscUJBQXFCLEVBQUU7WUFDeEMsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxDQUFDO1NBQ3hDO1FBRUQsSUFBSSxVQUFVLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLEVBQUU7WUFDdkMsT0FBTztnQkFDTCxJQUFJLEVBQUUsYUFBYTtnQkFDbkIsSUFBSSxFQUFFLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFO2dCQUNwQyxNQUFNLEVBQUUsTUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2FBQ3RELENBQUM7U0FDSDtRQUVELElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFO1lBQ2xCLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDNUQsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO2dCQUNqQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLEVBQUU7b0JBQy9DLE1BQU0sS0FBSyxDQUFDLHVDQUF1QyxDQUFDLENBQUM7aUJBQ3REO1lBQ0gsQ0FBQyxDQUFDLENBQUM7WUFFSCxPQUFPLFNBQVMsQ0FBQztTQUNsQjtRQUVELE1BQU0sS0FBSyxDQUFDLHVCQUF1QixJQUFJLENBQUMsT0FBTyxFQUFFLEtBQUssVUFBVSxHQUFHLENBQUMsQ0FBQztJQUN2RSxDQUFDO0lBRU8sa0JBQWtCLENBQUMsSUFBeUI7UUFDbEQsTUFBTSxlQUFlLEdBQUcsQ0FBQyxDQUFrQyxFQUFFLEVBQUU7WUFDN0QsTUFBTSxVQUFVLEdBQUcsY0FBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsYUFBYSxFQUFFLENBQUMsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7WUFDMUUsT0FBTyxDQUNMLENBQUMsRUFBRSxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxvQkFBb0IsQ0FBQztnQkFDN0MsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7Z0JBQ3JDLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQ3BDLENBQUM7UUFDSixDQUFDLENBQUM7UUFFRixJQUFJLGVBQWUsQ0FBQztRQUVwQixNQUFNLGdCQUFnQixHQUFHLElBQUksQ0FBQyxjQUFjLEVBQUUsRUFBRSxlQUFlLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQTRCLENBQUM7UUFFcEcsSUFBSSxlQUFlLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtZQUNyQyxlQUFlLEdBQUcsZ0JBQWdCLEVBQUUsV0FBVyxFQUFFLENBQUM7U0FDbkQ7UUFFRCxpREFBaUQ7UUFDakQsT0FBTyxJQUFJLEVBQUU7WUFDWCxJQUFJLGVBQWUsS0FBSyxTQUFTO2dCQUFFLE1BQU07WUFDekMsTUFBTSxXQUFXLEdBQUcsZUFBZSxDQUFDLFNBQVMsRUFBRSxFQUFFLGVBQWUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBNEIsQ0FBQztZQUVyRyxJQUFJLGVBQWUsQ0FBQyxXQUFXLENBQUMsRUFBRTtnQkFDaEMsZUFBZSxHQUFHLFdBQVcsQ0FBQyxXQUFXLEVBQUUsQ0FBQzthQUM3Qzs7Z0JBQU0sTUFBTTtTQUNkO1FBRUQsT0FBTyxlQUFlLENBQUM7SUFDekIsQ0FBQztJQUVPLHdCQUF3QixDQUFDLElBQWEsRUFBRSxPQUF3QjtRQUN0RSxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ3hCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQzdCLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDOUI7YUFBTTtZQUNMLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDN0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM3QixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztTQUM3QjtRQUVELE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDN0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUVwQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Y0EwQkU7WUFFRixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxXQUFXLEVBQUUsT0FBTyxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDN0YsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBNERELGVBQWU7UUFDYiw4REFBOEQ7UUFDOUQsTUFBTSxPQUFPLEdBQUcsRUFBVyxDQUFDO1FBRTVCLE1BQU0sWUFBWSxHQUFHLENBQUMsQ0FBUSxFQUFFLEVBQUU7WUFDaEMsTUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7Z0JBQzlCLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSTtnQkFDWixJQUFJLEVBQUUsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUM7Z0JBQ3ZDLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTO2FBQ2xDLENBQUMsQ0FBQyxDQUFDO1lBRUosT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQzlDLENBQUMsQ0FBQztRQUVGLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO1lBQzdCLE1BQU0sSUFBSSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dCQUM5QixJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUk7Z0JBQ1osSUFBSSxFQUFFLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7Z0JBQ2pDLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTO2FBQ2xDLENBQUMsQ0FBQyxDQUFDO1lBRUosTUFBTSxNQUFNLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUVqRSxPQUFPLENBQUMsSUFBSSxDQUFDO2dCQUNYLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSTtnQkFDWixJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUztnQkFDakMsUUFBUSxFQUFFLENBQUMsQ0FBQyxRQUFRO2dCQUNwQixJQUFJO2dCQUNKLE9BQU8sRUFBRTtvQkFDUCxJQUFJLEVBQUUsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO29CQUMvQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTO2lCQUNsRDtnQkFDRCxNQUFNLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxTQUFTO2FBQzNDLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBRTVELE9BQU8sRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUMzRyxDQUFDO0lBRU8sU0FBUyxDQUFDLElBQXVCLEVBQUUsSUFBYTtRQUN0RCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDeEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx1QkFBdUIsQ0FBQztZQUN6RCxNQUFNLElBQUksS0FBSyxDQUFDLDRDQUE0QyxDQUFDLENBQUM7UUFFaEUsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsTUFBTSxDQUFDO1FBRTVELElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFekMsNERBQTREO1FBQzVELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQzthQUMzQyxLQUFLLENBQUMsYUFBYSxDQUFDO2FBQ3BCLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQzthQUNsQixNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBRXRDLDhGQUE4RjtRQUM5RixNQUFNLGNBQWMsR0FBWSxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztRQUVuRCxJQUFJLGNBQWMsRUFBRTtZQUNsQixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxTQUFTLGVBQWUsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDO1NBQ2hFOztZQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRTVDLE1BQU0sU0FBUyxHQUFHLENBQUMsU0FBa0IsRUFBRSxLQUFhLEVBQUUsRUFBRTtZQUN0RCxJQUFJLGNBQWMsRUFBRTtnQkFDbEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsUUFBUSxlQUFlLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQzthQUNwRTtpQkFBTSxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsS0FBSyxVQUFVLEVBQUU7Z0JBQzFELElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDMUM7WUFFRCxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLEtBQUssVUFBVSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQztZQUNoRixJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxHQUFHLEtBQUssSUFBSSxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDckUsQ0FBQyxDQUFDO1FBRUYsOEZBQThGO1FBQzlGLElBQUksYUFBYSxHQUFHLEtBQUssQ0FBQztRQUMxQixJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUMzRCxNQUFNLEVBQUUsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ3BHLElBQUksSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLEVBQUU7Z0JBQ3hGLGFBQWEsR0FBRyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQzthQUM5RTtTQUNGO1FBRUQsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBRWpELElBQ0UsSUFBSSxLQUFLLFNBQVM7WUFDbEIsQ0FBQyxhQUFhO1lBQ2QsQ0FBQyxJQUFJLENBQUMsY0FBYyxLQUFLLE1BQU0sSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLEtBQUssVUFBVSxDQUFDLEVBQ25GO1lBQ0EsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsYUFBYSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBQ3pDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7WUFDNUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsT0FBTyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBQ25DLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQzFCLElBQUksQ0FBQyxRQUFRLENBQ1gsSUFBSSxFQUNKLFFBQVEsRUFDUixvQ0FBb0MsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUMxRyxDQUFDO1NBQ0g7UUFFRCxNQUFNLG9CQUFvQixHQUFHLENBQzNCLGNBQXFDLEVBQ3JDLE9BQW9DLEVBQ3BDLEtBQWEsRUFDYixFQUFFO1lBQ0YsTUFBTSxTQUFTLEdBQUcsY0FBYyxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBRXpELElBQUksQ0FBQyxZQUFZLEVBQUUsZUFBZSxDQUFDLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxFQUFFO2dCQUN2RCxNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsY0FBYyxFQUFFLENBQUM7Z0JBQ2pELElBQUksQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsc0JBQXNCLENBQUM7b0JBQUUsTUFBTSxLQUFLLENBQUMsd0JBQXdCLENBQUMsQ0FBQztnQkFDbkcsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLEVBQUUsRUFBRTtvQkFDM0MsU0FBUyxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztvQkFDMUIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDcEIsTUFBTSxFQUFFLEdBQUcsU0FBUyxLQUFLLFlBQVksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7b0JBQ3BELElBQUksQ0FBQyxTQUFTLENBQUMsY0FBYyxFQUFFLEVBQUUsQ0FBQyxDQUFDO29CQUNuQyxJQUFJLE1BQU07d0JBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBQ25ELENBQUMsQ0FBQyxDQUFDO2dCQUVILElBQUksQ0FBQyxRQUFRLENBQ1gsY0FBYyxFQUNkLFFBQVEsRUFDUixvQ0FBb0MsSUFBSSxDQUFDLFNBQVMsQ0FBQztvQkFDakQsR0FBRyxFQUFFLEVBQUUsT0FBTyxFQUFFO29CQUNoQixLQUFLO29CQUNMLFNBQVM7b0JBQ1QsUUFBUSxFQUFFLFFBQVEsQ0FBQyxPQUFPLEVBQUU7aUJBQzdCLENBQUMsRUFBRSxDQUNMLENBQUM7Z0JBQ0YsT0FBTzthQUNSO1lBRUQsTUFBTSxnQkFBZ0IsR0FBMkI7Z0JBQy9DLFdBQVcsRUFBRSxHQUFHO2dCQUNoQixrQkFBa0IsRUFBRSxJQUFJO2dCQUN4QixRQUFRLEVBQUUsR0FBRztnQkFDYixlQUFlLEVBQUUsSUFBSTtnQkFDckIsR0FBRyxFQUFFLElBQUk7YUFDVixDQUFDO1lBRUYsTUFBTSxFQUFFLEdBQUcsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUM7WUFFdkMsSUFBSSxFQUFFLEtBQUssU0FBUztnQkFBRSxNQUFNLEtBQUssRUFBRSxDQUFDO1lBQ3BDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDMUIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxjQUFjLENBQUMsY0FBYyxFQUFHLENBQUMsQ0FBQztZQUNuRCxJQUFJLENBQUMsU0FBUyxDQUFDLGNBQWMsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUNuQyxJQUFJLENBQUMsUUFBUSxDQUNYLGNBQWMsRUFDZCxRQUFRLEVBQ1Isb0NBQW9DLElBQUksQ0FBQyxTQUFTLENBQUM7Z0JBQ2pELEdBQUcsRUFBRSxPQUFPO2dCQUNaLEtBQUs7Z0JBQ0wsU0FBUztnQkFDVCxRQUFRLEVBQUUsRUFBRSxHQUFHLGNBQWMsQ0FBQyxjQUFjLEVBQUcsQ0FBQyxPQUFPLEVBQUU7YUFDMUQsQ0FBQyxFQUFFLENBQ0wsQ0FBQztRQUNKLENBQUMsQ0FBQztRQUVGLFFBQVEsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDOUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQztnQkFBRSxNQUFNLElBQUksS0FBSyxFQUFFLENBQUM7WUFDekUsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBRTlDLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLGFBQWEsS0FBSyxFQUFFLENBQUMsQ0FBQztZQUU3QyxNQUFNLElBQUksR0FBRyxPQUFPLENBQUMsY0FBYyxFQUFFLENBQUM7WUFDdEMsSUFBSSxJQUFJLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsdUJBQXVCLENBQUMsRUFBRTtnQkFDdkQsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsRUFBRSxFQUFFO29CQUN6QyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGtCQUFrQixDQUFDO3dCQUFFLE1BQU0sSUFBSSxLQUFLLEVBQUUsQ0FBQztvQkFDM0UsTUFBTSxXQUFXLEdBQUcsU0FBUyxDQUFDLGNBQWMsRUFBRSxDQUFDO29CQUUvQyxJQUFJLFNBQVMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUU7d0JBQ3RDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLGFBQWEsS0FBSyxJQUFJLFNBQVMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7d0JBQ3RFLElBQUksV0FBVyxFQUFFLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHVCQUF1QixDQUFDLEVBQUU7NEJBQzlELFdBQVcsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxjQUFjLEVBQUUsRUFBRTtnQ0FDckQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQztvQ0FBRSxNQUFNLElBQUksS0FBSyxFQUFFLENBQUM7Z0NBRWhGLG9CQUFvQixDQUFDLGNBQWMsRUFBRSxPQUFPLEVBQUUsR0FBRyxLQUFLLElBQUksU0FBUyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQzs0QkFDbkYsQ0FBQyxDQUFDLENBQUM7eUJBQ0o7NkJBQU07NEJBQ0wsU0FBUyxDQUFDLFNBQVMsRUFBRSxHQUFHLEtBQUssSUFBSSxTQUFTLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDOzRCQUN4RCxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxjQUFjLEVBQUcsQ0FBQyxDQUFDOzRCQUM5QyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQzs0QkFDaEMsSUFBSSxDQUFDLFFBQVEsQ0FDWCxTQUFTLEVBQ1QsUUFBUSxFQUNSLG9DQUFvQyxJQUFJLENBQUMsU0FBUyxDQUFDO2dDQUNqRCxHQUFHLEVBQUUsT0FBTztnQ0FDWixLQUFLO2dDQUNMLEtBQUssRUFBRSxTQUFTLENBQUMsT0FBTyxFQUFFO2dDQUMxQixRQUFRLEVBQUUsU0FBUyxDQUFDLGNBQWMsRUFBRyxDQUFDLE9BQU8sRUFBRTs2QkFDaEQsQ0FBQyxFQUFFLENBQ0wsQ0FBQzt5QkFDSDtxQkFDRjs7d0JBQU0sb0JBQW9CLENBQUMsU0FBUyxFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztnQkFDekQsQ0FBQyxDQUFDLENBQUM7Z0JBQ0gsT0FBTzthQUNSO1lBRUQsU0FBUyxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztZQUMxQixJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxjQUFjLEVBQUcsQ0FBQyxDQUFDO1lBQzVDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQzlCLElBQUksQ0FBQyxRQUFRLENBQ1gsT0FBTyxFQUNQLFFBQVEsRUFDUixvQ0FBb0MsSUFBSSxDQUFDLFNBQVMsQ0FBQztnQkFDakQsR0FBRyxFQUFFLE9BQU87Z0JBQ1osS0FBSztnQkFDTCxRQUFRLEVBQUUsT0FBTyxDQUFDLGNBQWMsRUFBRyxDQUFDLE9BQU8sRUFBRTthQUM5QyxDQUFDLEVBQUUsQ0FDTCxDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRU8sV0FBVyxDQUNqQixJQUFhLEVBQ2IsU0FBa0IsRUFDbEIsS0FBYyxFQUNkLFNBQWlCLEVBQ2pCLE1BQTJCO1FBRTNCLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUV2RCxxREFBcUQ7UUFDckQsSUFBSSxTQUFTLENBQUMsSUFBSSxLQUFLLGFBQWE7WUFBRSxNQUFNLEtBQUssRUFBRSxDQUFDO1FBQ3BELElBQUksbUJBQW1CLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLE1BQU0sRUFBRTtZQUNsRCxNQUFNLEtBQUssQ0FBQywwREFBMEQsQ0FBQyxDQUFDO1NBQ3pFO1FBQ0QsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQztZQUFFLE1BQU0sS0FBSyxDQUFDLHNDQUFzQyxDQUFDLENBQUM7UUFDdkYsTUFBTSxRQUFRLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQztRQUNoQyxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRWhELE1BQU0sU0FBUyxHQUFHLEdBQUcsTUFBTSxLQUFLLElBQUksQ0FBQyxlQUFlLEVBQUUsRUFBRSxDQUFDO1FBRXpELElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFNUIsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFFLENBQUMsSUFBSSxDQUFDO1FBRWpFLHNFQUFzRTtRQUN0RSxJQUFJLFlBQVksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsR0FBRyxJQUFJLEVBQUU7WUFDbEYsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxrQkFBa0I7WUFDeEQsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxjQUFjO1lBRXBELGVBQWU7WUFDZixJQUFJLENBQUMsZ0JBQWdCLENBQ25CLElBQUksRUFDSixHQUFHLFNBQVMsV0FBVyxFQUN2QixTQUFTLENBQUMsS0FBSyxFQUNmLCtEQUErRCxDQUNoRSxDQUFDO1lBRUYsY0FBYztZQUNkLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztZQUVwQyxJQUFJLENBQUMsZ0JBQWdCLENBQ25CLElBQUksRUFDSixHQUFHLFNBQVMsVUFBVSxFQUN0QixTQUFTLENBQUMsTUFBTSxFQUNoQixvREFBb0QsQ0FDckQsQ0FBQztZQUVGLGtCQUFrQjtZQUNsQixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztZQUMxQixJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLEdBQUcsU0FBUyxjQUFjLEVBQUUsU0FBUyxDQUFDLE1BQU0sRUFBRSxnQ0FBZ0MsQ0FBQyxDQUFDO1lBRTVHLDJCQUEyQjtZQUMzQixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxHQUFHLFNBQVMsV0FBVyxDQUFDLENBQUM7WUFDN0MsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsR0FBRyxTQUFTLFVBQVUsQ0FBQyxDQUFDO1lBRTVDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLE9BQU8sVUFBVSxFQUFFLEVBQUUsYUFBYSxDQUFDLENBQUM7WUFFekQsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7WUFDekIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFFbkMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUM7U0FDbEQ7YUFBTTtZQUNMLHNCQUFzQjtZQUN0QixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztZQUM1QixJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLEdBQUcsU0FBUyxRQUFRLEVBQUUsU0FBUyxFQUFFLHlDQUF5QyxDQUFDLENBQUM7WUFDeEcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsYUFBYSxVQUFVLEVBQUUsQ0FBQyxDQUFDO1lBRS9DLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBRW5DLDJCQUEyQjtZQUMzQixJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxRQUFRLENBQUMsQ0FBQztZQUVqRCxrQkFBa0I7WUFDbEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDOUIsSUFBSSxDQUFDLGdCQUFnQixDQUNuQixJQUFJLEVBQ0osR0FBRyxTQUFTLFVBQVUsRUFDdEIsU0FBUyxDQUFDLE1BQU0sRUFDaEIsb0RBQW9ELENBQ3JELENBQUM7U0FDSDtRQUNELE1BQU0sS0FBSyxHQUFHLElBQUksTUFBTSxJQUFJLElBQUksQ0FBQyxHQUFHLE1BQU0sT0FBTyxDQUFDLEVBQUUsQ0FBQztRQUNyRCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUM7UUFDbEMsSUFBSSxDQUFDLEdBQUcsTUFBTSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFNUIsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUM7UUFDbEQsSUFBSSxDQUFDLG1CQUFtQixHQUFHLEtBQUssQ0FBQztRQUNqQyxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO1FBQ3RDLElBQUksTUFBTSxLQUFLLE9BQU87WUFBRSxJQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztRQUNqRCxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxXQUFXLEdBQUcsWUFBWSxDQUFDO1FBQ2hDLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxnQkFBZ0IsQ0FBQztRQUU1QyxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsU0FBUyxRQUFRLENBQUMsRUFBRSxLQUFLLENBQUM7UUFFcEUsd0JBQXdCO1FBQ3hCLElBQUksTUFBTSxLQUFLLE9BQU87WUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxHQUFHLEtBQUssWUFBWSxDQUFDLENBQUM7UUFDbEUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsbURBQW1ELENBQUMsQ0FBQztRQUMxRSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxHQUFHLFNBQVMsVUFBVSxDQUFDLENBQUM7UUFDNUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsT0FBTyxVQUFVLEVBQUUsRUFBRSxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFdEQsSUFBSSxVQUFVLEtBQUssU0FBUyxFQUFFO1lBQzVCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLE9BQU8sU0FBUyxDQUFDLE1BQU0sR0FBRyxVQUFVLDRCQUE0QixDQUFDLENBQUM7U0FDdkY7YUFBTTtZQUNMLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEdBQUcsU0FBUyxjQUFjLENBQUMsQ0FBQztTQUNqRDtRQUVELElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxNQUFNLEtBQUssTUFBTSxDQUFDLENBQUM7UUFDN0MsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxTQUFTLFVBQVUsQ0FBQyxDQUFDO1FBRTdDLElBQUksVUFBVSxLQUFLLFNBQVMsRUFBRTtZQUM1QixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxHQUFHLFNBQVMsUUFBUSxDQUFDLENBQUM7WUFDMUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsR0FBRyxTQUFTLFVBQVUsQ0FBQyxDQUFDO1lBQzVDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLE9BQU8sVUFBVSxFQUFFLEVBQUUsU0FBUyxDQUFDLENBQUM7U0FDdEQ7YUFBTTtZQUNMLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEdBQUcsU0FBUyxXQUFXLENBQUMsQ0FBQztZQUM3QyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxHQUFHLFNBQVMsVUFBVSxDQUFDLENBQUM7WUFDNUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsT0FBTyxVQUFVLEVBQUUsRUFBRSxhQUFhLENBQUMsQ0FBQztTQUMxRDtRQUVELElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO1FBRXpCLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBRW5DLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBRWhDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLEtBQUssS0FBSyxFQUFFLEVBQUUsR0FBRyxLQUFLLE9BQU8sQ0FBQyxDQUFDO0lBQ3RELENBQUM7SUFrZ0JELFlBQVksT0FBd0I7UUFud0Q1Qix1QkFBa0IsR0FBNkIsRUFBRSxDQUFDO1FBSWxELFlBQU8sR0FBdUYsRUFBRSxDQUFDO1FBRWpHLG1CQUFjLEdBQWtDLFVBQVUsQ0FBQztRQUVuRSxTQUFJLEdBSUE7WUFDRixRQUFRLEVBQUUsRUFBRTtZQUNaLEtBQUssRUFBRSxFQUFFO1lBQ1QsSUFBSSxFQUFFLEVBQUU7U0FDVCxDQUFDO1FBRUYsa0JBQWEsR0FBVyxFQUFFLENBQUM7UUFFM0IsdUJBQWtCLEdBQVcsRUFBRSxDQUFDO1FBRXhCLGNBQVMsR0FXYixFQUFFLENBQUM7UUFJQyxnQkFBVyxHQUlmLEVBQUUsTUFBTSxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQztRQUl2QyxlQUFVLEdBS0osRUFBRSxDQUFDO1FBRUQsZUFBVSxHQUFXLENBQUMsQ0FBQztRQUV2QixjQUFTLEdBQXFDLEVBQUUsQ0FBQztRQUVqRCxnQkFBVyxHQUFpQixFQUFFLENBQUM7UUFFL0IsdUJBQWtCLEdBQVksS0FBSyxDQUFDO1FBRXBDLFlBQU8sR0FBVyxDQUFDLENBQUMsQ0FBQztRQUVyQixpQkFBWSxHQUFXLENBQUMsQ0FBQztRQUV6QixlQUFVLEdBQVcsQ0FBQyxDQUFDO1FBRXZCLGlCQUFZLEdBQVcsQ0FBQyxDQUFDO1FBRXpCLGFBQVEsR0FBVyxDQUFDLENBQUM7UUFJckIsc0JBQWlCLEdBQWMsRUFBRSxDQUFDO1FBRWxDLG1CQUFjLEdBK0VsQixFQUFFLENBQUM7UUFJQyxtQkFBYyxHQU9sQixFQUFFLENBQUM7UUFFUCxRQUFHLEdBSUM7WUFDRixJQUFJLEVBQUUsRUFBRTtZQUNSLElBQUksRUFBRSxFQUFFO1lBQ1IsT0FBTyxFQUFFLEVBQUU7U0FDWixDQUFDO1FBRU0saUJBQVksR0FBbUMsRUFBRSxDQUFDO1FBRWxELGFBQVEsR0FBYSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxDQUFDO1FBSTVELGFBQVEsR0FBOEIsRUFBRSxDQUFDO1FBRXpDLGFBQVEsR0FBZ0MsRUFBRSxDQUFDO1FBRW5DLDJCQUFzQixHQUFxQixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFcEQsYUFBUSxHQUFhLEVBQUUsQ0FBQztRQUlmLGNBQVMsR0FFdEI7WUFDRixPQUFPLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLG1CQUFtQixDQUFDLENBQUM7WUFDdkcsV0FBVyxFQUFFO2dCQUNYLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGdCQUFnQixDQUFDO2dCQUMzQztvQkFDRSxJQUFJLEVBQUUsbUJBQW1CO29CQUN6QixJQUFJLEVBQUUsS0FBSztvQkFDWCxJQUFJLEVBQUUsQ0FBQztvQkFDUCxFQUFFLEVBQUUsQ0FBQyxJQUFhLEVBQUUsRUFBRTt3QkFDcEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztvQkFDaEQsQ0FBQztpQkFDRjtnQkFDRDtvQkFDRSxJQUFJLEVBQUUsa0JBQWtCO29CQUN4QixJQUFJLEVBQUUsS0FBSztvQkFDWCxJQUFJLEVBQUUsQ0FBQztvQkFDUCxFQUFFLEVBQUUsQ0FBQyxJQUFhLEVBQUUsRUFBRTt3QkFDcEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLFNBQVMsQ0FBQyxDQUFDO3dCQUN4QyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO29CQUMvQyxDQUFDO2lCQUNGO2dCQUNEO29CQUNFLElBQUksRUFBRSxhQUFhO29CQUNuQixJQUFJLEVBQUUsS0FBSztvQkFDWCxJQUFJLEVBQUUsQ0FBQztvQkFDUCxFQUFFLEVBQUUsQ0FBQyxJQUFhLEVBQUUsRUFBRTt3QkFDcEIsSUFBSSxDQUFDLGdCQUFnQixDQUNuQixJQUFJLEVBQ0osbUJBQW1CLEVBQ25CLFNBQVMsQ0FBQyxHQUFHLEVBQ2Isc0NBQXNDLElBQUk7NkJBQ3ZDLE9BQU8sRUFBRTs2QkFDVCxLQUFLLENBQUMsSUFBSSxDQUFDOzZCQUNYLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDOzZCQUNwQixJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FDZixDQUFDO29CQUNKLENBQUM7aUJBQ0Y7Z0JBQ0Q7b0JBQ0UsSUFBSSxFQUFFLFlBQVk7b0JBQ2xCLElBQUksRUFBRSxLQUFLO29CQUNYLElBQUksRUFBRSxDQUFDO29CQUNQLEVBQUUsRUFBRSxDQUFDLElBQWEsRUFBRSxFQUFFO3dCQUNwQixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7d0JBQ3hDLElBQUksQ0FBQyxnQkFBZ0IsQ0FDbkIsSUFBSSxFQUNKLGtCQUFrQixFQUNsQixTQUFTLENBQUMsR0FBRyxFQUNiLHFDQUFxQyxJQUFJOzZCQUN0QyxPQUFPLEVBQUU7NkJBQ1QsS0FBSyxDQUFDLElBQUksQ0FBQzs2QkFDWCxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQzs2QkFDcEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQ2YsQ0FBQztvQkFDSixDQUFDO2lCQUNGO2FBQ0Y7WUFDRCxHQUFHLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQztZQUNsQyxNQUFNLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQztZQUN4QyxJQUFJLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sQ0FBQztZQUNwQyxLQUFLLEVBQUU7Z0JBQ0wsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDO2dCQUNsQztvQkFDRSxJQUFJLEVBQUUsYUFBYTtvQkFDbkIsSUFBSSxFQUFFLEtBQUs7b0JBQ1gsSUFBSSxFQUFFLENBQUM7b0JBQ1AsRUFBRSxFQUFFLENBQUMsSUFBYSxFQUFFLEVBQUU7d0JBQ3BCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQzVDLENBQUM7aUJBQ0Y7YUFDRjtZQUNELEtBQUssRUFBRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsa0JBQWtCLENBQUM7WUFDakQsS0FBSyxFQUFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUM7WUFDdEMsS0FBSyxFQUFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUM7U0FDdkMsQ0FBQztRQUVGLG1CQUFjLEdBQUcsRUFBRSxDQUFDO1FBRXBCLGlCQUFZLEdBQWtGLEVBQUUsQ0FBQztRQVFqRyxpQkFBWSxHQUFXLENBQUMsQ0FBQztRQUV6QixlQUFVLEdBQVcsQ0FBQyxDQUFDO1FBSXZCLHFCQUFnQixHQUFZLEtBQUssQ0FBQztRQUVsQyxxQkFBZ0IsR0FBNEQsRUFBRSxDQUFDO1FBUy9FLDBCQUFxQixHQUFZLEtBQUssQ0FBQztRQUV2Qzs7O1dBR0c7UUFDSCx5QkFBb0IsR0FBNEQsRUFBRSxDQUFDO1FBaVIzRSxhQUFRLEdBQVcsQ0FBQyxDQUFDO1FBRXJCLFlBQU8sR0FBVyxDQUFDLENBQUM7UUFJcEIsY0FBUyxHQUFXLENBQUMsQ0FBQztRQTZTdEIscUJBQWdCLEdBS3BCO1lBQ0YsRUFBRSxFQUFFO2dCQUNGLEtBQUssRUFBRSxDQUFDLElBQWlDLEVBQUUsRUFBRSxDQUMzQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyxNQUFNLElBQUksQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO2dCQUNwRixFQUFFLEVBQUUsQ0FBQyxJQUFpQyxFQUFFLEVBQUU7b0JBQ3hDLElBQUksQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQztnQkFDbkMsQ0FBQzthQUNGO1lBQ0QsU0FBUyxFQUFFO2dCQUNULEtBQUssRUFBRSxDQUFDLElBQWlDLEVBQUUsRUFBRSxDQUFDLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQzNHLEVBQUUsRUFBRSxDQUFDLElBQWlDLEVBQUUsRUFBRTtvQkFDeEMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDM0UsQ0FBQzthQUNGO1lBQ0QsV0FBVyxFQUFFO2dCQUNYLEtBQUssRUFBRSxDQUFDLElBQWlDLEVBQUUsRUFBRSxDQUFDLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQzdHLEVBQUUsRUFBRSxDQUFDLElBQWlDLEVBQUUsRUFBRTtvQkFDeEMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLEVBQUUsb0JBQW9CLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUN4RixDQUFDO2FBQ0Y7WUFDRCxNQUFNLEVBQUU7Z0JBQ04sS0FBSyxFQUFFLENBQUMsSUFBaUMsRUFBRSxFQUFFO29CQUMzQyxPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUssY0FBYyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxLQUFLLGFBQWEsQ0FBQztnQkFDakgsQ0FBQztnQkFDRCxFQUFFLEVBQUUsQ0FBQyxDQUE4QixFQUFFLEVBQUU7b0JBQ3JDLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUssYUFBYSxFQUFFO3dCQUN4QyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsRUFBRSxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLEVBQUUsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO3dCQUM1RSxPQUFPO3FCQUNSO29CQUVELElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRTt3QkFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLEVBQUUsS0FBSyxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQzt3QkFDcEQsT0FBTztxQkFDUjtvQkFFRCxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxLQUFLLGNBQWMsSUFBSSxJQUFJLENBQUMsMEJBQTBCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFO3dCQUMzRixJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsRUFBRSxLQUFLLEVBQUUsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQzt3QkFDN0YsSUFBSSxDQUFDLFFBQVEsR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDO3dCQUNqQyxPQUFPO3FCQUNSO29CQUVELDBEQUEwRDtvQkFDMUQsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyxjQUFjLEVBQUU7d0JBQ3pDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxFQUFFLE9BQU8sRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO3dCQUMzRCxJQUFJLENBQUMsUUFBUSxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUM7d0JBQ2pDLE9BQU87cUJBQ1I7b0JBRUQsTUFBTSxLQUFLLENBQUMsd0NBQXdDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQzVGLENBQUM7YUFDRjtTQUNGLENBQUM7UUF3Vk0sMEJBQXFCLEdBS3pCO1lBQ0YsR0FBRyxFQUFFO2dCQUNILEtBQUssRUFBRSxDQUFDLElBQXVCLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUM7Z0JBQ3pGLEVBQUUsRUFBRSxDQUFDLElBQXVCLEVBQUUsRUFBRTtvQkFDOUIsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDN0MsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBRXJDLElBQUksT0FBTyxFQUFFO3dCQUNYLElBQUksR0FBRzs0QkFBRSxNQUFNLEtBQUssQ0FBQyxnRUFBZ0UsQ0FBQyxDQUFDO3dCQUN2RixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO3dCQUNqRCxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDOzRCQUFFLE1BQU0sS0FBSyxDQUFDLHVEQUF1RCxDQUFDLENBQUM7d0JBQ25HLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQzt3QkFDckUsT0FBTztxQkFDUjtvQkFFRCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBRTVDLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsRUFBRTt3QkFDNUIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQzt3QkFDdEIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztxQkFDMUM7eUJBQU07d0JBQ0wsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO3FCQUN0RTtnQkFDSCxDQUFDO2FBQ0Y7WUFDRCxPQUFPLEVBQUU7Z0JBQ1AsS0FBSyxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQztnQkFDekYsRUFBRSxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFO29CQUM5QixJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7d0JBQ2hDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQ3BCLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxtQkFBbUIsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO29CQUN4RixDQUFDLENBQUMsQ0FBQztnQkFDTCxDQUFDO2FBQ0Y7WUFDRCxLQUFLLEVBQUU7Z0JBQ0wsS0FBSyxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQztnQkFDekYsRUFBRSxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFO29CQUM5QixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUM3QyxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBRW5DLElBQUksT0FBTyxJQUFJLENBQUMsR0FBRyxFQUFFO3dCQUNuQixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO3dCQUNyRCxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLEVBQUU7NEJBQ2hDLE1BQU0sS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7eUJBQ3hEO3dCQUNELElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFVBQVUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQzt3QkFDakYsT0FBTztxQkFDUjtvQkFFRCxJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQU8sRUFBRTt3QkFDbkIsTUFBTSxVQUFVLEdBQWE7NEJBQzNCLElBQUksRUFBRSxhQUFhOzRCQUNuQixJQUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUU7NEJBQ3BDLE1BQU0sRUFBRSxRQUFRLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxFQUFFLEVBQUUsQ0FBQzt5QkFDcEMsQ0FBQzt3QkFFRixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQzt3QkFFbEYsSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDOzRCQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxVQUFVLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7NkJBQ3pFOzRCQUNILElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7NEJBQ3RCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7eUJBQzNDO3dCQUNELE9BQU87cUJBQ1I7b0JBRUQsTUFBTSxLQUFLLENBQUMsa0VBQWtFLENBQUMsQ0FBQztnQkFDbEYsQ0FBQzthQUNGO1lBQ0QsSUFBSSxFQUFFO2dCQUNKLEtBQUssRUFBRSxDQUFDLElBQXVCLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUM7Z0JBQ3pGLEVBQUUsRUFBRSxDQUFDLElBQXVCLEVBQUUsRUFBRTtvQkFDOUIsNERBQTREO29CQUM1RCwwQ0FBMEM7b0JBQzFDLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztvQkFDakMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUM7d0JBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQywwQ0FBMEMsQ0FBQyxDQUFDO29CQUM5RyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxRQUFRLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLEVBQUUsRUFBRSxFQUFFLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDOUUsQ0FBQzthQUNGO1lBQ0QsTUFBTSxFQUFFO2dCQUNOLEtBQUssRUFBRSxDQUFDLElBQXVCLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUM7Z0JBQ3pGLEVBQUUsRUFBRSxDQUFDLElBQXVCLEVBQUUsRUFBRTtvQkFDOUIsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO29CQUNqQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQzt3QkFBRSxNQUFNLElBQUksS0FBSyxDQUFDLDRDQUE0QyxDQUFDLENBQUM7b0JBQ2hILElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLFdBQVcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsRUFBRSxHQUFHLEVBQUUsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUM5RSxDQUFDO2FBQ0Y7WUFDRCxNQUFNLEVBQUU7Z0JBQ04sS0FBSyxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQztnQkFDekYsRUFBRSxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFO29CQUM5QixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7b0JBQ2pDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQzFCLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7b0JBQ2hDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQzFCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQzFCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQztnQkFDdkMsQ0FBQzthQUNGO1lBQ0QsTUFBTSxFQUFFO2dCQUNOLEtBQUssRUFBRSxDQUFDLElBQXVCLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUM7Z0JBQ3pGLEVBQUUsRUFBRSxDQUFDLElBQXVCLEVBQUUsRUFBRTtvQkFDOUIsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO29CQUNqQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUMxQixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUMxQixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUM5QyxDQUFDO2FBQ0Y7U0FDRixDQUFDO1FBRU0sa0JBQWEsR0FLakI7WUFDRixHQUFHLElBQUksQ0FBQyxxQkFBcUI7WUFDN0Isa0JBQWtCO1lBQ2xCLFNBQVMsRUFBRTtnQkFDVCxLQUFLLEVBQUUsQ0FBQyxJQUF1QixFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQztnQkFDMUQsRUFBRSxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFO29CQUM5QixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUN6QyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUN6QyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxZQUFZLEVBQUUsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUNqRCxDQUFDO2FBQ0Y7WUFDRCxvQkFBb0IsRUFBRTtnQkFDcEIsS0FBSyxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQztnQkFDekYsRUFBRSxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFO29CQUM5QixJQUFJLENBQUMsU0FBUyxDQUNaLElBQUksRUFDSixZQUFZLEVBQ1osVUFBVSxFQUNWLHFCQUFxQixFQUNyQixPQUFPLEVBQ1AsZ0JBQWdCLEVBQ2hCLDRDQUE0QyxFQUM1QyxLQUFLLEVBQ0wsNEJBQTRCLEVBQzVCLDhCQUE4QixFQUM5Qix1QkFBdUIsRUFDdkIseUJBQXlCLEVBQ3pCLGFBQWEsQ0FDZCxDQUFDO2dCQUNKLENBQUM7YUFDRjtZQUNELGlCQUFpQjtZQUNqQixLQUFLLEVBQUU7Z0JBQ0wsS0FBSyxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQztnQkFDekYsRUFBRSxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFO29CQUM5QixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUMzQyxDQUFDO2FBQ0Y7WUFDRCxRQUFRLEVBQUU7Z0JBQ1IsS0FBSyxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQztnQkFDekYsRUFBRSxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFO29CQUM5QixJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxNQUFNLEtBQUssQ0FBQzt3QkFBRSxNQUFNLElBQUksS0FBSyxFQUFFLENBQUM7b0JBQ3hELElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ3pDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztvQkFDMUQsSUFBSSxDQUFDLFFBQVEsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDO2dCQUNsQyxDQUFDO2FBQ0Y7WUFDRCxPQUFPLEVBQUU7Z0JBQ1AsS0FBSyxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQztnQkFDekYsRUFBRSxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFO29CQUM5QixJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxNQUFNLEtBQUssQ0FBQzt3QkFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7b0JBQ2pHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ3pDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztvQkFDMUQsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDO3dCQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsd0NBQXdDLENBQUMsQ0FBQztvQkFDdkcsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxDQUFDO2dCQUNqRCxDQUFDO2FBQ0Y7WUFDRCxTQUFTLEVBQUU7Z0JBQ1QsS0FBSyxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQztnQkFDekYsRUFBRSxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFO29CQUM5QixJQUFJLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFLE1BQU0sS0FBSyxDQUFDO3dCQUFFLE1BQU0sS0FBSyxDQUFDLGdEQUFnRCxDQUFDLENBQUM7b0JBQ3pHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ3pDLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUMzQyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7b0JBQ3BELElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZTt3QkFDdkIsc0NBQXNDO3dCQUN0QyxPQUFPLENBQUMsSUFBSSxDQUFDLG9GQUFvRixDQUFDLENBQUM7Z0JBQ3ZHLENBQUM7YUFDRjtZQUNELFNBQVMsRUFBRTtnQkFDVCxLQUFLLEVBQUUsQ0FBQyxJQUF1QixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDO2dCQUN6RixFQUFFLEVBQUUsQ0FBQyxJQUF1QixFQUFFLEVBQUU7b0JBQzlCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztvQkFDakMsSUFDRSxJQUFJLENBQUMsTUFBTSxLQUFLLENBQUM7d0JBQ2pCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHNCQUFzQixDQUFDO3dCQUNyRCxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxzQkFBc0IsQ0FBQzt3QkFFckQsTUFBTSxJQUFJLEtBQUssRUFBRSxDQUFDO29CQUVwQixJQUFJLENBQUMsd0JBQXdCLENBQUMsSUFBSSxFQUFFLElBQUksS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQztvQkFDekUsSUFBSSxDQUFDLHdCQUF3QixDQUFDLElBQUksRUFBRSxJQUFJLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUM7b0JBRXpFLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQztvQkFDM0QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLGtCQUFrQixDQUFDLENBQUM7b0JBRWxELElBQUksQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQztnQkFDbkMsQ0FBQzthQUNGO1lBQ0QsR0FBRyxFQUFFO2dCQUNILEtBQUssRUFBRSxDQUFDLElBQXVCLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUM7Z0JBQ3pGLEVBQUUsRUFBRSxDQUFDLElBQXVCLEVBQUUsRUFBRTtvQkFDOUIsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO29CQUNqQyxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQzt3QkFBRSxNQUFNLElBQUksS0FBSyxFQUFFLENBQUM7b0JBQ3pDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztvQkFDbkMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLEVBQUU7d0JBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO29CQUV4RixJQUFJLENBQUMsSUFBSSxDQUNQLElBQUksQ0FBQyxDQUFDLENBQUMsRUFDUCxVQUFVLFFBQVEsQ0FBQyxzQkFBc0IsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFDM0UsU0FBUyxDQUFDLEtBQUssQ0FDaEIsQ0FBQztnQkFDSixDQUFDO2FBQ0Y7WUFDRCxTQUFTLEVBQUU7Z0JBQ1QsS0FBSyxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQztnQkFDekYsRUFBRSxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFO29CQUM5QixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUN6QyxJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLENBQUM7Z0JBQ25ELENBQUM7YUFDRjtZQUNELFNBQVMsRUFBRTtnQkFDVCxLQUFLLEVBQUUsQ0FBQyxJQUF1QixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDO2dCQUN6RixFQUFFLEVBQUUsQ0FBQyxJQUF1QixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQzthQUN0RDtZQUNELFlBQVksRUFBRTtnQkFDWixLQUFLLEVBQUUsQ0FBQyxJQUF1QixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDO2dCQUN6RixFQUFFLEVBQUUsQ0FBQyxJQUF1QixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxlQUFlLENBQUMsU0FBUyxDQUFDO2FBQ2pGO1lBQ0QsZ0JBQWdCLEVBQUU7Z0JBQ2hCLEtBQUssRUFBRSxDQUFDLElBQXVCLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUM7Z0JBQ3pGLEVBQUUsRUFBRSxDQUFDLElBQXVCLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLGVBQWUsQ0FBQyxpQkFBaUIsQ0FBQzthQUN6RjtZQUNELHNCQUFzQixFQUFFO2dCQUN0QixLQUFLLEVBQUUsQ0FBQyxJQUF1QixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDO2dCQUN6RixFQUFFLEVBQUUsQ0FBQyxJQUF1QixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxlQUFlLENBQUMsZUFBZSxDQUFDO2FBQ3ZGO1lBQ0Qsb0JBQW9CLEVBQUU7Z0JBQ3BCLEtBQUssRUFBRSxDQUFDLElBQXVCLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUM7Z0JBQ3pGLEVBQUUsRUFBRSxDQUFDLElBQXVCLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLGVBQWUsQ0FBQyxhQUFhLENBQUM7YUFDckY7WUFDRCxlQUFlLEVBQUU7Z0JBQ2YsS0FBSyxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQztnQkFDekYsRUFBRSxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsZUFBZSxDQUFDLGlCQUFpQixDQUFDO2FBQ3pGO1lBQ0QsZ0JBQWdCO1lBQ2hCLElBQUksRUFBRTtnQkFDSixLQUFLLEVBQUUsQ0FBQyxJQUF1QixFQUFFLEVBQUUsQ0FDakMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDO29CQUNuRSxXQUFXLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFFLElBQUksQ0FBQyxhQUFhLEVBQWtDLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQztnQkFDL0csRUFBRSxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFO29CQUM5QixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7b0JBQ2xDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUM7d0JBQUUsTUFBTSxLQUFLLEVBQUUsQ0FBQztvQkFFeEUsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyxjQUFjO3dCQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztvQkFDN0YsSUFBSSxDQUFDLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO3dCQUNqRCxNQUFNLElBQUksS0FBSyxDQUFDLCtDQUErQyxDQUFDLENBQUM7b0JBQ25FLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ3pDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztvQkFDMUQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7b0JBRTlCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUM7Z0JBQ3pDLENBQUM7YUFDRjtZQUNELEdBQUcsRUFBRTtnQkFDSCxLQUFLLEVBQUUsQ0FBQyxJQUF1QixFQUFFLEVBQUUsQ0FDakMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDO29CQUNuRSxXQUFXLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFFLElBQUksQ0FBQyxhQUFhLEVBQWtDLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQztnQkFDL0csRUFBRSxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFO29CQUM5QixJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDO3dCQUFFLE1BQU0sS0FBSyxFQUFFLENBQUM7b0JBQ3hGLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUssY0FBYzt3QkFBRSxNQUFNLElBQUksS0FBSyxDQUFDLGlDQUFpQyxDQUFDLENBQUM7b0JBQzlGLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQzt3QkFBRSxNQUFNLElBQUksS0FBSyxDQUFDLGdEQUFnRCxDQUFDLENBQUM7b0JBRTlHLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO29CQUV0QyxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7b0JBQzFELElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsT0FBTyxVQUFVLEVBQUUsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQztvQkFFMUcsZ0VBQWdFO29CQUNoRSxJQUFJLElBQUksQ0FBQyxZQUFZLEtBQUssSUFBSSxFQUFFO3dCQUM5QixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLE9BQU8sVUFBVSxFQUFFLENBQUMsQ0FBQzt3QkFFeEUsSUFBSSxDQUFDLFdBQVcsQ0FBRSxJQUFJLENBQUMsYUFBYSxFQUFrQyxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUM7d0JBRXhGLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsTUFBTSxDQUFDLENBQUM7cUJBQ3JFO29CQUVELElBQUksQ0FBQyxXQUFXLENBQUUsSUFBSSxDQUFDLGFBQWEsRUFBa0MsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDO29CQUV4RixJQUFJLElBQUksQ0FBQyxZQUFZLEtBQUssSUFBSTt3QkFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQztvQkFFckUsSUFBSSxDQUFDLFFBQVEsR0FBRyxVQUFVLENBQUM7Z0JBQzdCLENBQUM7YUFDRjtZQUNELE1BQU0sRUFBRTtnQkFDTixLQUFLLEVBQUUsQ0FBQyxJQUF1QixFQUFFLEVBQUUsQ0FDakMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDO29CQUNuRSxXQUFXLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFFLElBQUksQ0FBQyxhQUFhLEVBQWtDLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQztnQkFDL0csRUFBRSxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFO29CQUM5QixJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDO3dCQUFFLE1BQU0sS0FBSyxFQUFFLENBQUM7b0JBRXhGLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUssY0FBYyxFQUFFO3dCQUN6QyxNQUFNLElBQUksS0FBSyxDQUFDLHNDQUFzQyxJQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQztxQkFDekU7b0JBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUU7d0JBQ25ELE1BQU0sSUFBSSxLQUFLLENBQUMsZ0RBQWdELENBQUMsQ0FBQztxQkFDbkU7b0JBQ0QsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUM7b0JBRXZDLDBEQUEwRDtvQkFDMUQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFFekMsOEJBQThCO29CQUM5QixzRUFBc0U7b0JBQ3RFLHFFQUFxRTtvQkFDckUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDekMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxFQUFFLFNBQVMsZUFBZSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7b0JBRTVHLDhFQUE4RTtvQkFDOUUsd0ZBQXdGO29CQUN4RixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUN6QyxJQUFJLENBQUMsU0FBUyxDQUNaLElBQUksRUFDSixPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLEVBQUUsRUFDeEMsR0FBRyxFQUNILE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsRUFBRSxFQUN4QyxHQUFHLEVBQ0gsU0FBUyxlQUFlLENBQUMsZ0JBQWdCLEVBQUUsQ0FDNUMsQ0FBQztvQkFFRixxQkFBcUI7b0JBQ3JCLElBQUksQ0FBQyxXQUFXLENBQUUsSUFBSSxDQUFDLGFBQWEsRUFBa0MsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDO29CQUN4RixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsUUFBUSxlQUFlLENBQUMsV0FBVyxFQUFFLEVBQUUsWUFBWSxDQUFDLENBQUM7b0JBRW5GLHNCQUFzQjtvQkFDdEIsSUFBSSxDQUFDLFdBQVcsQ0FBRSxJQUFJLENBQUMsYUFBYSxFQUFrQyxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUM7b0JBQ3hGLElBQUksQ0FBQyxTQUFTLENBQ1osSUFBSTtvQkFDSixVQUFVO29CQUNWLEtBQUssRUFDTCxLQUFLO29CQUNMLDRCQUE0QjtvQkFDNUIsUUFBUSxlQUFlLENBQUMsV0FBVyxFQUFFLEVBQ3JDLFFBQVEsZUFBZSxDQUFDLGdCQUFnQixFQUFFLEVBQzFDLEdBQUcsRUFDSCxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLEVBQUUsRUFDeEMsR0FBRyxFQUNILE1BQU07b0JBQ04sc0JBQXNCO29CQUN0QixZQUFZO29CQUNaLG9CQUFvQjtvQkFDcEIsUUFBUSxDQUNULENBQUM7b0JBRUYsSUFBSSxJQUFJLENBQUMsWUFBWSxLQUFLLElBQUksRUFBRTt3QkFDOUIsaUZBQWlGO3dCQUVqRixJQUFJLENBQUMsV0FBVyxDQUFFLElBQUksQ0FBQyxhQUFhLEVBQWtDLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQzt3QkFDeEYsSUFBSSxDQUFDLFNBQVMsQ0FDWixJQUFJLEVBQ0osUUFBUSxlQUFlLENBQUMsV0FBVyxFQUFFO3dCQUNyQywrREFBK0Q7d0JBQy9ELFFBQVEsZUFBZSxDQUFDLGdCQUFnQixFQUFFLEVBQzFDLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsRUFBRSxFQUN4QyxHQUFHLEVBQ0gsVUFBVSxFQUNWLE1BQU0sQ0FDUCxDQUFDO3FCQUNIO29CQUVELElBQUksQ0FBQyxXQUFXLENBQUUsSUFBSSxDQUFDLGFBQWEsRUFBa0MsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDO29CQUN4RixJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsSUFBSSxFQUFFLGNBQWMsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLENBQUM7Z0JBQzlELENBQUM7YUFDRjtZQUNELE9BQU8sRUFBRTtnQkFDUCxLQUFLLEVBQUUsQ0FBQyxJQUF1QixFQUFFLEVBQUUsQ0FDakMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDO29CQUNuRSxXQUFXLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFFLElBQUksQ0FBQyxhQUFhLEVBQWtDLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQztnQkFDL0csRUFBRSxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFO29CQUM5QixJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO29CQUVsRCxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBRWxDLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDO3dCQUFFLE1BQU0sS0FBSyxFQUFFLENBQUM7b0JBQzNELE1BQU0sTUFBTSxHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUM7b0JBRTVHLElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDO3dCQUFFLE1BQU0sS0FBSyxDQUFDLGdFQUFnRSxDQUFDLENBQUM7b0JBRXZHLE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztvQkFFdEMsTUFBTSxJQUFJLEdBQUksSUFBSSxDQUFDLGFBQWEsRUFBa0MsQ0FBQyxhQUFhLEVBQUUsQ0FBQztvQkFDbkYsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQztnQkFDbkcsQ0FBQzthQUNGO1lBQ0Qsa0JBQWtCO1lBQ2xCLFNBQVMsRUFBRTtnQkFDVCxLQUFLLEVBQUUsQ0FBQyxJQUF1QixFQUFFLEVBQUUsQ0FDakMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDO29CQUNsRSxJQUFJLENBQUMsYUFBYSxFQUFrQyxDQUFDLGFBQWEsRUFBRSxDQUFDLE9BQU8sRUFBRSxLQUFLLFNBQVM7Z0JBQy9GLEVBQUUsRUFBRSxDQUFDLElBQXVCLEVBQUUsRUFBRTtvQkFDOUIsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsQ0FBQzt3QkFBRSxNQUFNLEtBQUssRUFBRSxDQUFDO29CQUV4RixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUN6QyxJQUFJLENBQUMsUUFBUSxHQUFHLFdBQVcsQ0FBQyxPQUFPLENBQUM7Z0JBQ3RDLENBQUM7YUFDRjtZQUNELFdBQVcsRUFBRTtnQkFDWCxLQUFLLEVBQUUsQ0FBQyxJQUF1QixFQUFFLEVBQUUsQ0FDakMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDO29CQUNsRSxJQUFJLENBQUMsYUFBYSxFQUFrQyxDQUFDLGFBQWEsRUFBRSxDQUFDLE9BQU8sRUFBRSxLQUFLLFNBQVM7Z0JBQy9GLEVBQUUsRUFBRSxDQUFDLElBQXVCLEVBQUUsRUFBRTtvQkFDOUIsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsQ0FBQzt3QkFBRSxNQUFNLEtBQUssRUFBRSxDQUFDO29CQUV4RixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7b0JBQzlDLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFO3dCQUFFLE1BQU0sS0FBSyxDQUFDLGtEQUFrRCxDQUFDLENBQUM7b0JBRTdGLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFFBQVEsSUFBSSxDQUFDLHNCQUFzQixFQUFFLEVBQUUsRUFBRSxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQ2hGLENBQUM7YUFDRjtZQUNELGlDQUFpQztZQUNqQyxVQUFVLEVBQUU7Z0JBQ1YsS0FBSyxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFLENBQ2pDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsQ0FBQztvQkFDbkUsQ0FBRSxJQUFJLENBQUMsYUFBYSxFQUFrQyxDQUFDLGFBQWEsRUFBRSxDQUFDLE9BQU8sRUFBRSxLQUFLLFNBQVM7d0JBQzNGLElBQUksQ0FBQyxhQUFhLEVBQWtDLENBQUMsYUFBYSxFQUFFLENBQUMsT0FBTyxFQUFFLEtBQUssT0FBTyxDQUFDO2dCQUNoRyxFQUFFLEVBQUUsQ0FBQyxJQUF1QixFQUFFLEVBQUU7b0JBQzlCLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUM7d0JBQUUsTUFBTSxLQUFLLEVBQUUsQ0FBQztvQkFFeEYsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDekMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUM3QixJQUFJLENBQUMsYUFBYSxFQUFrQyxDQUFDLGFBQWEsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUNoRixDQUFDO2dCQUNKLENBQUM7YUFDRjtZQUNELGlCQUFpQjtZQUNqQixJQUFJLEVBQUU7Z0JBQ0osS0FBSyxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQztnQkFDekYsRUFBRSxFQUFFLENBQUMsSUFBdUIsRUFBRSxFQUFFO29CQUM5QixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7b0JBQ2pDLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxDQUFDO3dCQUFFLE1BQU0sSUFBSSxLQUFLLEVBQUUsQ0FBQztvQkFDekMsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO29CQUNuQyxJQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsRUFBRTt3QkFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHNDQUFzQyxDQUFDLENBQUM7b0JBRXpGLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBRTlDLElBQUksUUFBUSxLQUFLLFNBQVMsRUFBRTt3QkFDMUIsTUFBTSxLQUFLLENBQUMscURBQXFELENBQUMsQ0FBQztxQkFDcEU7b0JBRUQsTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztvQkFDL0MsTUFBTSxRQUFRLEdBQUcsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxPQUFPLEtBQUssRUFBRSxFQUFjLENBQUM7b0JBQ3BFLE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsc0JBQXNCLEVBQVksQ0FBQyxDQUFDO29CQUVsRSxNQUFNLFFBQVEsR0FBRyxFQUFFLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQztvQkFFMUMsSUFBSSxLQUFLLEdBQUcsUUFBUSxFQUFFO3dCQUNwQixNQUFNLEtBQUssQ0FBQyxTQUFTLEtBQUsseUJBQXlCLEtBQUssa0JBQWtCLFFBQVEsRUFBRSxDQUFDLENBQUM7cUJBQ3ZGO29CQUVELElBQUksS0FBSyxLQUFLLEVBQUUsSUFBSSxhQUFhLENBQUMsUUFBUSxDQUFDO3dCQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sS0FBSyxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7O3dCQUNsRixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxVQUFVLEtBQUssQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztnQkFDMUYsQ0FBQzthQUNGO1lBQ0QsUUFBUSxFQUFFO2dCQUNSLEtBQUssRUFBRSxDQUFDLElBQXVCLEVBQUUsRUFBRTtvQkFDakMsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyxNQUFNLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztnQkFDakYsQ0FBQztnQkFDRCxFQUFFLEVBQUUsQ0FBQyxJQUF1QixFQUFFLEVBQUU7b0JBQzlCLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUssTUFBTTt3QkFBRSxNQUFNLEtBQUssRUFBRSxDQUFDO29CQUVqRCxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFO3dCQUNoRCxNQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO3dCQUNoRSxJQUFJLEtBQUssR0FBRyxFQUFFOzRCQUFFLE1BQU0sS0FBSyxDQUFDLG1EQUFtRCxDQUFDLENBQUM7d0JBQ2pGLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO3FCQUM3QjtvQkFFRCxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxlQUFlLENBQUMsQ0FBQztvQkFDckMsSUFBSSxDQUFDLFFBQVEsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDO2dCQUNsQyxDQUFDO2FBQ0Y7U0FDRixDQUFDO1FBY00sV0FBTSxHQUEwQixFQUFFLENBQUM7UUEwbkRuQyx3QkFBbUIsR0FBdUM7WUFDaEUsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDO2dCQUNiLGNBQWM7Z0JBQ2QsV0FBVztnQkFDWCw2Q0FBNkM7Z0JBQzdDLDJCQUEyQjtnQkFDM0IsT0FBTztnQkFDUCxVQUFVO2dCQUNWLFFBQVE7Z0JBQ1IsRUFBRTtnQkFDRixRQUFRO2dCQUNSLFdBQVc7Z0JBQ1gsMkJBQTJCO2dCQUMzQixPQUFPO2dCQUNQLElBQUk7Z0JBQ0osaUJBQWlCO2dCQUNqQixXQUFXO2dCQUNYLFFBQVE7Z0JBQ1IsZUFBZTtnQkFDZiwyQkFBMkI7Z0JBQzNCLFFBQVE7Z0JBQ1IsR0FBRztnQkFDSCxPQUFPO2dCQUNQLEdBQUc7Z0JBQ0gsd0JBQXdCO2dCQUN4QiwyQkFBMkI7Z0JBQzNCLFFBQVE7Z0JBQ1IsR0FBRztnQkFDSCxlQUFlO2dCQUNmLHFCQUFxQjtnQkFDckIsc0JBQXNCO2dCQUN0QixlQUFlO2dCQUNmLG9CQUFvQjtnQkFDcEIsMkJBQTJCO2dCQUMzQixRQUFRO2dCQUNSLEdBQUc7Z0JBQ0gscUJBQXFCO2dCQUNyQixRQUFRO2dCQUNSLFFBQVE7YUFDVDtZQUNELCtCQUErQixFQUFFLEdBQUcsRUFBRTtnQkFDcEMsTUFBTSxTQUFTLEdBQUcsa0JBQWtCLENBQUM7Z0JBQ3JDLE1BQU0sU0FBUyxHQUFHLGtCQUFrQixDQUFDO2dCQUNyQyxNQUFNLFVBQVUsR0FBRyxtQkFBbUIsQ0FBQztnQkFDdkMsTUFBTSxPQUFPLEdBQUcsZUFBZSxDQUFDO2dCQUVoQyxPQUFPO29CQUNMLGdDQUFnQztvQkFDaEMsV0FBVztvQkFDWCxhQUFhLFNBQVMsRUFBRTtvQkFDeEIsYUFBYSxPQUFPLEVBQUU7b0JBQ3RCLFFBQVE7b0JBRVIsYUFBYSxTQUFTLEVBQUU7b0JBQ3hCLGFBQWEsVUFBVSxFQUFFO29CQUN6QixRQUFRO2lCQUNULENBQUM7WUFDSixDQUFDO1lBQ0QsZ0NBQWdDLEVBQUUsR0FBRyxFQUFFO2dCQUNyQyxNQUFNLFNBQVMsR0FBRyxrQkFBa0IsQ0FBQztnQkFDckMsTUFBTSxTQUFTLEdBQUcsa0JBQWtCLENBQUM7Z0JBQ3JDLE1BQU0sVUFBVSxHQUFHLG1CQUFtQixDQUFDO2dCQUN2QyxNQUFNLE9BQU8sR0FBRyxlQUFlLENBQUM7Z0JBRWhDLE9BQU87b0JBQ0wsaUNBQWlDO29CQUNqQyxXQUFXO29CQUNYLGFBQWEsU0FBUyxFQUFFO29CQUN4QixhQUFhLFVBQVUsRUFBRTtvQkFDekIsUUFBUTtvQkFDUixjQUFjLFNBQVMsRUFBRTtvQkFDekIsYUFBYSxPQUFPLEVBQUU7b0JBQ3RCLEtBQUs7b0JBQ0wsS0FBSztvQkFDTCxhQUFhLFVBQVUsRUFBRTtvQkFDekIsTUFBTTtvQkFDTixHQUFHO29CQUNILE1BQU07b0JBQ04sYUFBYTtvQkFDYixjQUFjLFVBQVUsRUFBRTtvQkFDMUIsYUFBYSxTQUFTLEVBQUU7b0JBQ3hCLE1BQU07b0JBQ04sUUFBUTtvQkFDUixjQUFjLFNBQVMsRUFBRTtvQkFFekIsYUFBYSxTQUFTLEVBQUU7b0JBQ3hCLGFBQWEsU0FBUyxFQUFFO29CQUN4QixhQUFhLFVBQVUsRUFBRTtvQkFDekIsUUFBUTtpQkFDVCxDQUFDO1lBQ0osQ0FBQztZQUNELHdCQUF3QjtZQUN4QixhQUFhO1lBQ2Isc0JBQXNCLEVBQUUsR0FBRyxFQUFFLENBQUM7Z0JBQzVCLHVCQUF1QjtnQkFDdkIsV0FBVztnQkFDWCxtQ0FBbUM7Z0JBQ25DLFFBQVEsZUFBZSxDQUFDLFNBQVMsRUFBRTtnQkFDbkMsc0NBQXNDO2dCQUN0QyxnREFBZ0Q7Z0JBRWhELFFBQVEsZUFBZSxDQUFDLHNCQUFzQixFQUFFO2dCQUNoRCw4QkFBOEI7Z0JBQzlCLCtCQUErQjtnQkFDL0Isc0JBQXNCO2dCQUV0Qiw0QkFBNEI7Z0JBQzVCLE1BQU07Z0JBQ04scUNBQXFDO2dCQUVyQyxxQkFBcUI7Z0JBRXJCLDBCQUEwQjtnQkFDMUIsa0NBQWtDO2dCQUNsQyxRQUFRLGVBQWUsQ0FBQyxTQUFTLEVBQUU7Z0JBQ25DLE1BQU07Z0JBQ04sd0JBQXdCO2dCQUN4QixNQUFNO2dCQUNOLDJCQUEyQjtnQkFDM0IsU0FBUyxlQUFlLENBQUMsU0FBUyxFQUFFO2dCQUNwQyxRQUFRO2FBQ1Q7WUFDRCx3QkFBd0IsRUFBRSxHQUFHLEVBQUUsQ0FBQztnQkFDOUIseUJBQXlCO2dCQUN6Qix5QkFBeUI7Z0JBQ3pCLFFBQVEsZUFBZSxDQUFDLFVBQVUsRUFBRTtnQkFDcEMsOEJBQThCO2dCQUM5QixRQUFRLGVBQWUsQ0FBQyxhQUFhLEVBQUU7Z0JBQ3ZDLEdBQUc7Z0JBRUgseUJBQXlCO2dCQUN6QixRQUFRLGVBQWUsQ0FBQyxVQUFVLEVBQUU7Z0JBQ3BDLDhCQUE4QjtnQkFDOUIsUUFBUSxlQUFlLENBQUMsYUFBYSxFQUFFO2dCQUN2QyxPQUFPO2dCQUNQLFNBQVMsZUFBZSxDQUFDLHNCQUFzQixFQUFFO2dCQUNqRCxtQkFBbUI7Z0JBRW5CLHNCQUFzQjtnQkFDdEIsUUFBUSxlQUFlLENBQUMsYUFBYSxFQUFFO2dCQUN2QyxRQUFRLGVBQWUsQ0FBQyxVQUFVLEVBQUU7Z0JBQ3BDLDhCQUE4QjtnQkFDOUIsT0FBTztnQkFDUCxTQUFTLGVBQWUsQ0FBQyxzQkFBc0IsRUFBRTtnQkFFakQsa0JBQWtCO2dCQUNsQiw0QkFBNEI7Z0JBQzVCLFNBQVMsZUFBZSxDQUFDLGdCQUFnQixFQUFFO2dCQUMzQyxRQUFRO2FBQ1Q7U0FDRixDQUFDO1FBd3JCRixhQUFRLEdBQUcsRUFBRSxDQUFDO1FBK2xFTixrQkFBYSxHQUEyQjtZQUM5QyxhQUFhLEVBQUUsZ0JBQWdCO1lBQy9CLGFBQWEsRUFBRSxnQkFBZ0I7WUFDL0IsYUFBYSxFQUFFLGdCQUFnQjtZQUMvQixpQkFBaUIsRUFBRSxvQkFBb0I7WUFDdkMsYUFBYSxFQUFFLGVBQWU7WUFDOUIsU0FBUyxFQUFFLFlBQVk7WUFDdkIsV0FBVyxFQUFFLGVBQWU7WUFDNUIsY0FBYyxFQUFFLGtCQUFrQjtZQUNsQyxnQkFBZ0IsRUFBRSxxQkFBcUI7WUFDdkMsZUFBZSxFQUFFLG1CQUFtQjtZQUNwQyxPQUFPLEVBQUUsV0FBVztZQUNwQixLQUFLLEVBQUUsUUFBUTtZQUNmLFlBQVksRUFBRSxlQUFlO1lBQzdCLE9BQU8sRUFBRSxVQUFVO1lBQ25CLFdBQVcsRUFBRSxjQUFjO1lBQzNCLGlCQUFpQixFQUFFLHFCQUFxQjtZQUN4QyxjQUFjLEVBQUUsa0JBQWtCO1lBQ2xDLFdBQVcsRUFBRSxjQUFjO1NBQzVCLENBQUM7UUFqakpBLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQztRQUMvQixJQUFJLENBQUMsZUFBZSxHQUFHLE9BQU8sQ0FBQyxlQUFlLElBQUksS0FBSyxDQUFDO1FBQ3hELElBQUksQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFDLFdBQVcsSUFBSSxrQkFBa0IsQ0FBQztRQUM3RCxJQUFJLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDO1FBQzNDLElBQUksQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDLFVBQVUsSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3ZELElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQztRQUMvQixJQUFJLENBQUMscUJBQXFCLEdBQUcsT0FBTyxDQUFDLHFCQUFxQixJQUFJLEtBQUssQ0FBQztRQUNwRSxJQUFJLENBQUMsaUJBQWlCLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixJQUFJLEtBQUssQ0FBQztRQUM1RCxJQUFJLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQyxTQUFTLElBQUksS0FBSyxDQUFDO1FBRTVDLElBQUksQ0FBQyxNQUFNLEdBQUcsY0FBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLElBQUksU0FBUyxDQUFDLENBQUM7UUFDcEUsSUFBSSxDQUFDLFFBQVEsR0FBRyxjQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsSUFBSSxjQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFDeEcsSUFBSSxDQUFDLEdBQUcsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDO1FBRXZCLElBQUksQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQztRQUM5QixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUUsQ0FBQztJQUM5RCxDQUFDO0lBRUQsTUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUEyQztRQUMzRCxNQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsT0FBTzthQUM5QixhQUFhLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBRTthQUMvQixhQUFhLEVBQUU7YUFDZixNQUFNLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO2FBQzdELEdBQUcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLEVBQUU7WUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQztnQkFBRSxNQUFNLEtBQUssRUFBRSxDQUFDO1lBQ2hFLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUUzQyxNQUFNLFFBQVEsR0FBRyxJQUFJLFFBQVEsQ0FBQyxFQUFFLEdBQUcsT0FBTyxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBQy9ELE1BQU0sUUFBUSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ3pCLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUztnQkFBRSxNQUFNLFFBQVEsQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUV0RCxPQUFPLFFBQVEsQ0FBQztRQUNsQixDQUFDLENBQUMsQ0FBQztRQUVMLE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFFRCxpQkFBaUIsQ0FBQyxFQUFVO1FBQzFCLE1BQU0sTUFBTSxHQUFHLHVCQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsQ0FBQztRQUN2RCxJQUFJLE1BQU0sS0FBSyxTQUFTLEVBQUU7WUFDeEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxjQUFjLEVBQUUsRUFBRSxDQUFDLENBQUM7U0FDckM7UUFFRCxPQUFPLE1BQU0sQ0FBQyxPQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3BDLElBQUksRUFBRSxDQUFDO1lBQ1AsTUFBTSxJQUFJLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxZQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FBQztZQUV6RixNQUFNLFFBQVEsR0FBRyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFjLENBQUM7WUFFcEQsSUFBSSxDQUFDLEtBQUssRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxFQUFFO2dCQUNyRSxFQUFFLEdBQUcsQ0FBQyxJQUFhLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxJQUFJLEdBQUcsRUFBRSxFQUFFLFFBQVEsQ0FBQyxDQUFDO2FBQ25FO2lCQUFNO2dCQUNMLEVBQUUsR0FBRyxDQUFDLElBQWEsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLElBQUksR0FBRyxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7YUFDNUU7WUFDRCxPQUFPO2dCQUNMLElBQUksRUFBRSxHQUFHO2dCQUNULElBQUksRUFBRSxNQUFNLENBQUMsSUFBSSxFQUFFLE1BQU0sSUFBSSxDQUFDO2dCQUM5QixFQUFFO2FBQ0gsQ0FBQztRQUNKLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVPLGFBQWEsQ0FBQyxJQUFjO1FBQ2xDLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxjQUFjO1lBQUUsT0FBTyxJQUFJLENBQUM7UUFFOUMsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLE9BQU8sRUFBRTtZQUN6QixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3ZFO1FBRUQsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLGFBQWEsRUFBRTtZQUMvQixPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3RDO1FBRUQsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBRTtZQUMxQixPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztpQkFDbEMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUNqQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDbkI7UUFFRCxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssTUFBTSxFQUFFO1lBQ3hCLE9BQU8sSUFBSSxDQUFDLElBQUksS0FBSyxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxRQUFRLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxRQUFRLENBQUM7U0FDbEY7UUFFRCxNQUFNLEtBQUssRUFBRSxDQUFDO0lBQ2hCLENBQUM7SUFFTyxhQUFhLENBQUMsU0FBbUI7UUFDdkMsSUFBSSxTQUFTLENBQUMsSUFBSSxLQUFLLGFBQWEsRUFBRTtZQUNwQyxJQUFJLFVBQVUsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRTtnQkFDOUQsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDeEM7WUFFRCxPQUFPLFNBQVMsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDOUQ7UUFFRCxJQUFJLFNBQVMsQ0FBQyxJQUFJLEtBQUssT0FBTyxFQUFFO1lBQzlCLElBQUksV0FBVyxHQUFHLENBQUMsQ0FBQztZQUNwQixJQUFJLGdCQUFnQixHQUFHLENBQUMsQ0FBQztZQUV6QixTQUFTLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO2dCQUMvQixJQUFJLFVBQVUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFO29CQUNqRCxnQkFBZ0IsSUFBSSxDQUFDLENBQUM7aUJBQ3ZCO3FCQUFNO29CQUNMLElBQUksZ0JBQWdCLEdBQUcsQ0FBQyxFQUFFO3dCQUN4QixXQUFXLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxDQUFDLENBQUMsQ0FBQztxQkFDaEQ7b0JBRUQsV0FBVyxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBRXJDLGdCQUFnQixHQUFHLENBQUMsQ0FBQztpQkFDdEI7WUFDSCxDQUFDLENBQUMsQ0FBQztZQUVILDZEQUE2RDtZQUM3RCxJQUFJLGdCQUFnQixHQUFHLENBQUMsRUFBRTtnQkFDeEIsV0FBVyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDaEQ7WUFFRCxPQUFPLFdBQVcsQ0FBQztTQUNwQjtRQUVELElBQUksU0FBUyxDQUFDLElBQUksS0FBSyxRQUFRLEVBQUU7WUFDL0IsSUFBSSxXQUFXLEdBQUcsQ0FBQyxDQUFDO1lBQ3BCLElBQUksZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDO1lBRXpCLE1BQU0sQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO2dCQUNoRCxJQUFJLFVBQVUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFO29CQUNqRCxnQkFBZ0IsSUFBSSxDQUFDLENBQUM7aUJBQ3ZCO3FCQUFNO29CQUNMLElBQUksZ0JBQWdCLEdBQUcsQ0FBQyxFQUFFO3dCQUN4QixXQUFXLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxDQUFDLENBQUMsQ0FBQztxQkFDaEQ7b0JBRUQsV0FBVyxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBRXJDLGdCQUFnQixHQUFHLENBQUMsQ0FBQztpQkFDdEI7WUFDSCxDQUFDLENBQUMsQ0FBQztZQUVILE9BQU8sV0FBVyxDQUFDO1NBQ3BCO1FBRUQsSUFBSSxTQUFTLENBQUMsSUFBSSxLQUFLLE1BQU0sRUFBRTtZQUM3QixNQUFNLEVBQUUsSUFBSSxFQUFFLEdBQUcsU0FBUyxDQUFDO1lBRTNCLElBQUksa0JBQWtCLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUNyQyxxQkFBcUI7Z0JBQ3JCLE1BQU0sS0FBSyxDQUNULDJHQUEyRyxDQUM1RyxDQUFDO2FBQ0g7WUFFRCxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxFQUFFO2dCQUM1RSxPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNoRDtZQUVELFFBQVEsSUFBSSxFQUFFO2dCQUNaLEtBQUssTUFBTTtvQkFDVCxPQUFPLENBQUMsQ0FBQztnQkFDWCxLQUFLLFNBQVMsQ0FBQztnQkFDZixLQUFLLE9BQU87b0JBQ1YsT0FBTyxDQUFDLENBQUM7Z0JBQ1gsS0FBSyxNQUFNLENBQUM7Z0JBQ1osS0FBSyxRQUFRLENBQUM7Z0JBQ2QsS0FBSyxPQUFPO29CQUNWLE9BQU8sQ0FBQyxDQUFDO2dCQUNYLEtBQUssU0FBUyxDQUFDO2dCQUNmLEtBQUssU0FBUztvQkFDWixPQUFPLEVBQUUsQ0FBQztnQkFDWjtvQkFDRSxNQUFNLElBQUksS0FBSyxDQUFDLGdCQUFnQixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO2FBQ3BFO1NBQ0Y7UUFFRCxNQUFNLEtBQUssQ0FBQyw0RkFBNEYsQ0FBQyxDQUFDO0lBQzVHLENBQUM7SUFFTyxZQUFZLENBQUMsSUFBbUI7UUFNdEMsTUFBTSxxQkFBcUIsR0FBMEIsRUFBRSxDQUFDO1FBRXhELElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO1lBQ3RDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGdCQUFnQixDQUFDO2dCQUFFLHFCQUFxQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM5RSxDQUFDLENBQUMsQ0FBQztRQUVILElBQUkscUJBQXFCLENBQUMsTUFBTSxLQUFLLENBQUM7WUFBRSxPQUFPLFNBQVMsQ0FBQztRQUN6RCxJQUFJLHFCQUFxQixDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDcEMsTUFBTSxLQUFLLENBQ1QseUNBQXlDLElBQUksQ0FBQyxPQUFPLEVBQUUsdUZBQXVGLENBQy9JLENBQUM7U0FDSDtRQUVELE1BQU0sV0FBVyxHQUFHLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRTdDLE1BQU0sVUFBVSxHQUFHLGNBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLGFBQWEsRUFBRSxDQUFDLFdBQVcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBRXBGLElBQUksVUFBVSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksVUFBVSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDOUUsSUFBSSxXQUFXLENBQUMsT0FBTyxFQUFFLEtBQUssY0FBYyxFQUFFO2dCQUM1QyxPQUFPO29CQUNMLFdBQVc7b0JBQ1gsSUFBSSxFQUFFLFVBQVU7aUJBQ2pCLENBQUM7YUFDSDtZQUVELElBQUksV0FBVyxDQUFDLE9BQU8sRUFBRSxLQUFLLFVBQVUsRUFBRTtnQkFDeEMsT0FBTztvQkFDTCxXQUFXO29CQUNYLElBQUksRUFBRSxNQUFNO2lCQUNiLENBQUM7YUFDSDtZQUVELE9BQU87Z0JBQ0wsV0FBVztnQkFDWCxJQUFJLEVBQUUsTUFBTTthQUNiLENBQUM7U0FDSDtRQUVELE1BQU0sVUFBVSxHQUFHLFdBQVcsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBRXpGLElBQ0UsVUFBVSxDQUFDLE9BQU8sRUFBRSxLQUFLLGNBQWM7WUFDdkMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsRUFBRSxJQUFJLEtBQUssVUFBVSxDQUFDO1lBQ25HLFVBQVUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxVQUFVLENBQUMsR0FBRyxjQUFjLFVBQVUsQ0FBQyxFQUM1RDtZQUNBLE9BQU87Z0JBQ0wsV0FBVztnQkFDWCxJQUFJLEVBQUUsVUFBVTthQUNqQixDQUFDO1NBQ0g7UUFFRCxJQUNFLFVBQVUsQ0FBQyxPQUFPLEVBQUUsS0FBSyxVQUFVO1lBQ25DLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLEVBQUUsSUFBSSxLQUFLLE1BQU0sQ0FBQztZQUMvRixVQUFVLENBQUMsT0FBTyxFQUFFLENBQUMsVUFBVSxDQUFDLEdBQUcsVUFBVSxVQUFVLENBQUMsRUFDeEQ7WUFDQSxPQUFPO2dCQUNMLFdBQVc7Z0JBQ1gsSUFBSSxFQUFFLE1BQU07YUFDYixDQUFDO1NBQ0g7UUFFRCxPQUFPO1lBQ0wsV0FBVztZQUNYLElBQUksRUFBRSxNQUFNO1NBQ2IsQ0FBQztJQUNKLENBQUM7SUFFTyxLQUFLLENBQUMsZUFBZSxDQUFDLEtBQWlCO1FBQzdDLE1BQU0sZUFBZSxHQUFHO1lBQ3RCLFNBQVMsRUFBRSxJQUFJLENBQUMsU0FBUztZQUN6QixXQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVc7WUFDN0IsVUFBVSxFQUFFLElBQUksQ0FBQyxVQUFVO1lBQzNCLGVBQWUsRUFBRSxJQUFJLENBQUMsZUFBZTtZQUNyQyxxQkFBcUIsRUFBRSxJQUFJLENBQUMscUJBQXFCO1lBQ2pELGlCQUFpQixFQUFFLElBQUksQ0FBQyxpQkFBaUI7WUFDekMsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPO1lBQ3JCLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRztZQUNiLFNBQVMsRUFBRSxJQUFJLENBQUMsU0FBUztTQUMxQixDQUFDO1FBRUYsT0FBTyxDQUNMLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FDZixLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNwQixNQUFNLFFBQVEsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDO1lBRXhCLElBQUksUUFBUSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsRUFBRTtnQkFDbEMsT0FBTyxFQUFFLElBQUksRUFBRSxtQkFBbUIsSUFBSSxDQUFDLGNBQWMsRUFBRSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7YUFDekU7WUFFRCxJQUFJLFFBQVEsQ0FBQyxVQUFVLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtnQkFDekMsTUFBTSxTQUFTLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDekMsTUFBTSxTQUFTLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUUzRSxNQUFNLEVBQUUsV0FBVyxFQUFFLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUUsQ0FBQztnQkFFdEQsTUFBTSxPQUFPLEdBQUcsV0FBVyxDQUFDLGFBQWEsRUFBRSxFQUFFLFdBQVcsRUFBRSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUM7Z0JBQzNFLE1BQU0sQ0FBQyxHQUFHLElBQUksUUFBUSxDQUFDLEVBQUUsR0FBRyxlQUFlLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUM7Z0JBQ25FLE1BQU0sQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUNsQixJQUFJLFFBQVEsQ0FBQyxVQUFVLENBQUMsMkJBQTJCLENBQUMsRUFBRTtvQkFDcEQsT0FBTyxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztpQkFDckY7Z0JBQ0QsSUFBSSxRQUFRLENBQUMsVUFBVSxDQUFDLDZCQUE2QixDQUFDLEVBQUU7b0JBQ3RELE9BQU8sRUFBRSxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLGVBQWUsRUFBRSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7aUJBQzNGO2dCQUNELElBQUksUUFBUSxDQUFDLFVBQVUsQ0FBQywwQkFBMEIsQ0FBQyxFQUFFO29CQUNuRCxPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDLGdCQUFnQixFQUFFLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO2lCQUNwRjtnQkFDRCxJQUFJLFFBQVEsQ0FBQyxVQUFVLENBQUMsNEJBQTRCLENBQUMsRUFBRTtvQkFDckQsT0FBTyxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsZUFBZSxFQUFFLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztpQkFDMUY7YUFDRjtZQUVELElBQUksUUFBUSxDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLFNBQVMsRUFBRTtnQkFDeEUsTUFBTSxTQUFTLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDekMsTUFBTSxTQUFTLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUUzRSxNQUFNLEVBQUUsV0FBVyxFQUFFLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUUsQ0FBQztnQkFFdEQsTUFBTSxPQUFPLEdBQUcsV0FBVyxDQUFDLGFBQWEsRUFBRSxFQUFFLFdBQVcsRUFBRSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUM7Z0JBRTNFLE1BQU0sQ0FBQyxHQUFHLElBQUksUUFBUSxDQUFDLEVBQUUsR0FBRyxlQUFlLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUM7Z0JBQ25FLE1BQU0sQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUVsQixJQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFO29CQUMzQyxNQUFNLGVBQWUsR0FBRyxNQUFNLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztvQkFDNUQsT0FBTyxFQUFFLElBQUksRUFBRSxRQUFRLGVBQWUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO2lCQUMvRDtnQkFFRCxNQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUUsQ0FBQyxXQUFXLEVBQW1DLENBQUM7Z0JBQ3hHLE1BQU0sZUFBZSxHQUFHLE1BQU0sQ0FBQyxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUM1RCxtQ0FBbUM7Z0JBQ25DLE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ2hGLE9BQU8sRUFBRSxJQUFJLEVBQUUsVUFBVSxTQUFTLEVBQUUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO2FBQ3REO1lBRUQsTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN0QyxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxNQUFNLENBQUMsQ0FBQztZQUVuRSxJQUFJLFFBQVEsQ0FBQyxVQUFVLENBQUMsZUFBZSxDQUFDLEVBQUU7Z0JBQ3hDLElBQUksVUFBVSxLQUFLLFNBQVM7b0JBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxjQUFjLE1BQU0sWUFBWSxDQUFDLENBQUM7Z0JBRWhGLE1BQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQztnQkFFcEIsUUFBUSxDQUFDLElBQUksQ0FDWCxTQUFTLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxJQUFJLFVBQVUsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQ2pHLENBQUM7Z0JBRUYsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQztvQkFDeEIsUUFBUSxDQUFDLElBQUksQ0FDWCxrRkFBa0YsRUFDbEYsU0FBUyxDQUNWLENBQUM7Z0JBQ0osSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUM7b0JBQUUsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztnQkFFcEYsT0FBTyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7b0JBQ3hCLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUM7Z0JBQ25DLENBQUMsQ0FBQyxDQUFDO2FBQ0o7WUFFRCxNQUFNLEVBQUUsWUFBWSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBRTNCLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLFlBQVksRUFBRSxDQUFDO1FBQ3hELENBQUMsQ0FBQyxDQUNILENBQ0YsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNYLENBQUM7SUFFTyx3QkFBd0I7UUFDOUIsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXJDLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUUsQ0FBQztRQUM3RCxNQUFNLEtBQUssR0FBRyxVQUFVLENBQUMscUJBQXFCLEVBQUUsQ0FBQztRQUVqRCxJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ3BCLE1BQU0sS0FBSyxDQUFDLGtDQUFrQyxJQUFJLENBQUMsT0FBTyxDQUFDLG9DQUFvQyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUMzRztJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsaUJBQWlCLENBQUMsT0FBMEQ7UUFDMUUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO1lBQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDO2dCQUFFLE1BQU0sS0FBSyxDQUFDLGdDQUFnQyxDQUFDLENBQUM7WUFDekcsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQzNDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztZQUN0QyxJQUFJLFFBQVEsS0FBSyxTQUFTO2dCQUFFLE1BQU0sS0FBSyxDQUFDLGdEQUFnRCxJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBRWhHLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxFQUFFLE9BQU8sRUFBRTtnQkFDcEQsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFHLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQ3ZELENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDO1lBRW5CLE1BQU0sR0FBRyxHQUFHO2dCQUNWLElBQUk7Z0JBQ0osTUFBTSxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFO2dCQUNoQyxNQUFNLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUU7Z0JBQ2hDLElBQUksRUFBRSxFQUFFO2dCQUNSLElBQUksRUFBRSxFQUFFO2dCQUNSLE9BQU8sRUFBRSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRTtnQkFDdkMsSUFBSTtnQkFDSixNQUFNLEVBQUUsRUFBRTthQUNHLENBQUM7WUFFaEIsSUFBSSxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtnQkFDekQsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztnQkFFekMsSUFBSSxDQUFDLENBQUMsV0FBVyxFQUFFLEVBQUUsT0FBTyxFQUFFLEtBQUssU0FBUyxFQUFFO29CQUM1QyxJQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsQ0FBQztpQkFDMUM7Z0JBRUQsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7b0JBQ1osSUFBSSxFQUFFLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLEVBQUU7b0JBQy9CLElBQUk7b0JBQ0osSUFBSSxFQUFFLEVBQUU7aUJBQ1QsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDLENBQUM7WUFFSCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUM3QixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7T0FFRztJQUNILGtCQUFrQixDQUNoQixjQUF1QixFQUN2QixXQUFtQyxFQUNuQyxhQUF1QztRQUV2QyxNQUFNLE9BQU8sR0FBRztZQUNkLFNBQVMsRUFBRSxJQUFJLENBQUMsU0FBUztZQUN6QixXQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVc7WUFDN0IsVUFBVSxFQUFFLElBQUksQ0FBQyxVQUFVO1lBQzNCLGVBQWUsRUFBRSxJQUFJLENBQUMsZUFBZTtZQUNyQyxxQkFBcUIsRUFBRSxJQUFJLENBQUMscUJBQXFCO1lBQ2pELGlCQUFpQixFQUFFLElBQUksQ0FBQyxpQkFBaUI7WUFDekMsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPO1lBQ3JCLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRztTQUNkLENBQUM7UUFFRixNQUFNLE1BQU0sR0FBRyxjQUFjLENBQUMsU0FBUyxFQUFFLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxjQUFjLENBQUMsU0FBUyxFQUFHLENBQUM7UUFFN0YsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLGVBQWUsRUFBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBRSxDQUFDLGFBQWEsRUFBRSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBRWhGLE1BQU0sYUFBYSxHQUFHLElBQUksUUFBUSxDQUFDLEVBQUUsR0FBRyxPQUFPLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3pGLE1BQU0sZUFBZSxHQUFHLGFBQWEsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBRXpELFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxlQUFlLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDakQsYUFBYSxDQUFDLElBQUksQ0FBQyxHQUFHLGVBQWUsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxnQkFBZ0I7UUFJZCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO1lBQzlELElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsZ0JBQWdCLENBQUM7Z0JBQUUsT0FBTyxLQUFLLENBQUM7WUFFL0QsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLEtBQUssSUFBSSxDQUFDLElBQUk7Z0JBQUUsT0FBTyxJQUFJLENBQUM7WUFFOUMsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDLENBQW9DLENBQUM7UUFFdEMsSUFBSSxTQUFTLEtBQUssU0FBUztZQUFFLE1BQU0sS0FBSyxDQUFDLFNBQVMsSUFBSSxDQUFDLElBQUksWUFBWSxDQUFDLENBQUM7UUFFekUsTUFBTSxlQUFlLEdBQUcsU0FBUyxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFDdkQsSUFBSSxlQUFlLEtBQUssU0FBUyxFQUFFO1lBQ2pDLE1BQU0sS0FBSyxDQUFDLFlBQVksSUFBSSxDQUFDLElBQUksK0VBQStFLENBQUMsQ0FBQztTQUNuSDtRQUVELE1BQU0sV0FBVyxHQUEyQixFQUFFLENBQUM7UUFDL0MsTUFBTSxhQUFhLEdBQTZCLEVBQUUsQ0FBQztRQUVuRCxNQUFNLGNBQWMsR0FBRyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxFQUFFLENBQUM7UUFFNUUsSUFBSSxjQUFjLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLEVBQUU7WUFDdkQsTUFBTSxTQUFTLEdBQUcsY0FBYyxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBQ2pELElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUM7Z0JBQUUsTUFBTSxLQUFLLEVBQUUsQ0FBQztZQUU3RSxJQUFJLENBQUMsY0FBYyxFQUFFLFVBQVUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQUUsTUFBTSxLQUFLLEVBQUUsQ0FBQztZQUU5RSxjQUFjLENBQUMsWUFBWSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7Z0JBQzFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLEVBQUUsV0FBVyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1lBQ3pELENBQUMsQ0FBQyxDQUFDO1NBQ0o7YUFBTSxJQUFJLGNBQWMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUMxRCxNQUFNLFVBQVUsR0FBRyxjQUFjLENBQUMsT0FBTyxFQUFFLENBQUM7WUFFNUMsSUFBSSxDQUFDLENBQUMsY0FBYyxFQUFFLFVBQVUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRTtnQkFDdEQsSUFBSSxDQUFDLGtCQUFrQixDQUFDLGNBQWMsRUFBRSxXQUFXLEVBQUUsYUFBYSxDQUFDLENBQUM7YUFDckU7U0FDRjtRQUVELFNBQVMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtZQUMzQixJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQztnQkFBRSxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ25FLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLG1CQUFtQixDQUFDO2dCQUFFLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekUsQ0FBQyxDQUFDLENBQUM7UUFFSCxNQUFNLFdBQVcsR0FBRyxDQUFDLENBQVUsRUFBRSxDQUFTLEVBQUUsR0FBYyxFQUFFLEVBQUU7WUFDNUQsT0FBTyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM5QixDQUFDLENBQUM7UUFFRixPQUFPLEVBQUUsV0FBVyxFQUFFLFdBQVcsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLEVBQUUsYUFBYSxFQUFFLGFBQWEsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQztJQUM1RyxDQUFDO0lBRU8sY0FBYyxDQUFDLElBQWE7UUFDbEMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsZ0NBQWdDLENBQUMsQ0FBQztRQUV2RCxJQUFJLElBQUksQ0FBQyxjQUFjLEtBQUssTUFBTSxFQUFFO1lBQ2xDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLHlCQUF5QixDQUFDLENBQUM7U0FDakQ7UUFFRCxJQUFJLENBQUMsU0FBUyxDQUNaLElBQUksRUFDSixFQUFFLEVBQ0YsNkNBQTZDLGlCQUFPLEVBQUUsRUFDdEQscURBQXFELEVBQ3JELEVBQUUsQ0FDSCxDQUFDO1FBRUYsSUFBSSxJQUFJLENBQUMsY0FBYyxLQUFLLFVBQVUsRUFBRTtZQUN0QyxNQUFNLFlBQVksR0FDaEIsMEdBQTBHLENBQUM7WUFFN0csTUFBTSxVQUFVLEdBQ2Qsd0dBQXdHLENBQUM7WUFFM0csSUFBSSxDQUFDLFNBQVMsQ0FDWixJQUFJLEVBQ0osbUZBQW1GLEVBQ25GLEVBQUUsRUFDRixnRUFBZ0UsRUFDaEUsb0lBQW9JLEVBQ3BJLHlHQUF5RyxFQUN6RyxtRkFBbUYsRUFDbkYsaUlBQWlJLEVBQ2pJLG1CQUFtQixFQUNuQixHQUFHLEVBQ0gsT0FBTyxFQUNQLEdBQUcsRUFDSCxrQkFBa0IsRUFDbEIsR0FBRyxFQUNILFVBQVUsVUFBVSxJQUFJLFlBQVksRUFBRSxFQUN0QyxtQkFBbUIsQ0FDcEIsQ0FBQztZQUVGLElBQUksQ0FBQyxRQUFRLENBQ1gsSUFBSSxFQUNKLEtBQUssRUFDTCwwSEFBMEgsQ0FDM0gsQ0FBQztZQUVGLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsZ0NBQWdDLEVBQUUsQ0FBQyxDQUFDO1NBQ3hFO2FBQU0sSUFBSSxJQUFJLENBQUMsY0FBYyxLQUFLLE1BQU0sRUFBRTtZQUN6QyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSwyQ0FBMkMsRUFBRSxFQUFFLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztTQUN6RjtJQUNILENBQUM7SUFFRCxLQUFLLENBQUMsT0FBTztRQUNYLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUU1RCxNQUFNLGFBQWEsR0FBRyxVQUFVLEVBQUUscUJBQXFCLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyw0QkFBNEIsRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDO1FBRTdHLHVFQUF1RTtRQUN2RSxDQUFDLFVBQVUsRUFBRSxHQUFHLGFBQWEsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO1lBQzNDLENBQUMsRUFBRSxhQUFhLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtnQkFDL0IsTUFBTSxjQUFjLEdBQUcsQ0FBQyxDQUFDLG9CQUFvQixDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLENBQUM7Z0JBRTNFLElBQUksY0FBYyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7b0JBQzdCLE1BQU0sSUFBSSxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDL0IsTUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyw2QkFBNkIsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO29CQUNwRyxNQUFNLE9BQU8sR0FBRyxjQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7b0JBRTVFLE1BQU0sR0FBRyxHQUFHLGlDQUFpQyxPQUFPLElBQUksR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLFNBQVMsdUJBQXVCLENBQUM7b0JBRTdHLE1BQU0sS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2lCQUNsQjtZQUNILENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFO1lBQ3hFLElBQUksQ0FBQyx3QkFBd0IsRUFBRSxDQUFDO1NBQ2pDO1FBRUQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRTtZQUMvQyxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUM7WUFDckIsTUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyw2QkFBNkIsQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUFFLENBQUMsWUFBWSxFQUFFLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1lBQzFHLE1BQU0sS0FBSyxHQUFhLEVBQUUsQ0FBQztZQUMzQixNQUFNLE9BQU8sR0FBRyxjQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLGFBQWEsRUFBRSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7WUFDL0UsT0FBTztpQkFDSixPQUFPLEVBQUU7aUJBQ1QsS0FBSyxDQUFDLElBQUksQ0FBQztpQkFDWCxPQUFPLENBQUMsQ0FBQyxDQUFTLEVBQUUsQ0FBUyxFQUFFLEVBQUU7Z0JBQ2hDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxPQUFPLElBQUksR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDckQsQ0FBQyxDQUFDLENBQUM7WUFFTCxNQUFNLEdBQUcsR0FBRyxHQUFHLE9BQU8sQ0FBQyxXQUFXLEVBQUUsT0FBTyxPQUFPLElBQUksR0FBRyxDQUFDLElBQUksSUFBSSxHQUFHLENBQUMsU0FBUyxTQUFTLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQztZQUVqSCxJQUNFLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQztnQkFDNUMsSUFBSSxDQUFDLGtCQUFrQixFQUFFLEtBQUssRUFBRSxDQUFDLHVCQUF1QixDQUFDLEtBQUssRUFDOUQ7Z0JBQ0EsTUFBTSxJQUFJLEtBQUssQ0FBQywwQ0FBMEMsR0FBRyxFQUFFLENBQUMsQ0FBQzthQUNsRTtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsTUFBTSxFQUFFLFdBQVcsRUFBRSxhQUFhLEVBQUUsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUMvRCxJQUFJLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDcEMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLHlCQUF5QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFaEUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRTtZQUMvQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGdCQUFnQixDQUFDO2dCQUFFLE9BQU87WUFFekQsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7WUFFckIsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixFQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxFQUFFLENBQUM7WUFDbkYsSUFDRSxDQUFDLGNBQWMsRUFBRSxVQUFVLENBQUMsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUMzRCxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxFQUFFLElBQUksS0FBSyxVQUFVLENBQUM7Z0JBQ25HLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLEVBQUUsSUFBSSxLQUFLLE1BQU0sQ0FBQztnQkFDL0YsVUFBVSxDQUFDLE9BQU8sRUFBRSxDQUFDLFVBQVUsQ0FBQyxHQUFHLGNBQWMsVUFBVSxDQUFDO2dCQUM1RCxVQUFVLENBQUMsT0FBTyxFQUFFLENBQUMsVUFBVSxDQUFDLEdBQUcsVUFBVSxVQUFVLENBQUMsRUFDeEQ7Z0JBQ0EsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLE9BQU8sRUFBRyxDQUFDO2dCQUVsQyxJQUFJLFNBQVMsS0FBSyxJQUFJLENBQUMsSUFBSSxFQUFFO29CQUMzQixJQUFJLFVBQVUsQ0FBQyxPQUFPLEVBQUUsS0FBSyxVQUFVO3dCQUFFLElBQUksQ0FBQyxjQUFjLEdBQUcsTUFBTSxDQUFDO29CQUV0RSxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztvQkFDdEIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFFMUIsSUFBSSxDQUFDLEdBQUcsR0FBRzt3QkFDVCxJQUFJLEVBQUUsU0FBUzt3QkFDZixJQUFJLEVBQUUsRUFBRTt3QkFDUixPQUFPLEVBQUUsRUFBRTtxQkFDWixDQUFDO29CQUVGLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztpQkFDdkQ7YUFDRjtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFDRSxJQUFJLENBQUMsY0FBYyxLQUFLLE1BQU07WUFDOUIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsTUFBTSxLQUFLLENBQUM7WUFDaEUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUM7aUJBQ2hDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztpQkFDcEIsUUFBUSxDQUFDLFFBQVEsQ0FBQyxFQUNyQjtZQUNBLE1BQU0sSUFBSSxHQUFHLG1CQUFtQixDQUFDO1lBQ2pDLE1BQU0sQ0FBQyxHQUFHO2dCQUNSLElBQUk7Z0JBQ0osSUFBSSxFQUFFLG1EQUFtRDtnQkFDekQsT0FBTyxFQUFFLEVBQUUsSUFBSSxFQUFFLFNBQVMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRTtnQkFDM0MsSUFBSSxFQUFFLEVBQUU7Z0JBQ1IsTUFBTSxFQUFFLEVBQUU7YUFDWCxDQUFDO1lBRUYsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7Z0JBQ3BCLEdBQUcsQ0FBQztnQkFDSixNQUFNLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFO2dCQUN0QyxNQUFNLEVBQUU7b0JBQ04sTUFBTSxFQUFFLEVBQUU7b0JBQ1YsSUFBSSxFQUFFLEVBQUU7aUJBQ1Q7Z0JBQ0QsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFTO2FBQ3JCLENBQUMsQ0FBQztZQUVILElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUV6QixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsY0FBYyxJQUFJLEdBQUcsRUFBRSxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUM7U0FDMUU7UUFFRCxJQUFJLElBQUksQ0FBQyxjQUFjLEtBQUssTUFBTTtZQUFFLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUUzRCxPQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ3pDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxFQUFHLENBQUMsQ0FBQztTQUN4RDtRQUVELE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUU7WUFDcEQsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQyxFQUFFO2dCQUNoRixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO2FBQ3BFO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxNQUFNLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztRQUM1RixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxJQUFBLHVCQUFZLEVBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztRQUM5RSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUM7UUFFakYsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzlDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUM7Z0JBQUUsT0FBTztZQUUvRyxNQUFNLFlBQVksR0FBRyxjQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO1lBQ25GLE1BQU0sSUFBSSxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsNkJBQTZCLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7WUFDbEgsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7Z0JBQ25CLElBQUksRUFBRSxDQUFDLEdBQUcsQ0FBQztnQkFDWCxNQUFNLEVBQUUsR0FBRyxZQUFZLElBQUksSUFBSSxFQUFFO2dCQUNqQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLFlBQVk7YUFDN0IsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLFNBQVMsR0FBRyxLQUFLLENBQUM7UUFFdEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtZQUMvQixJQUFJLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUN6RCxTQUFTLEdBQUcsSUFBSSxDQUFDO2FBQ2xCO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLFNBQVMsRUFBRTtZQUNiLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ3JHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUk7Z0JBQ3BDLDBLQUEwSyxDQUFDO1NBQzlLO1FBRUQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQzlDLEdBQUcsQ0FBQztZQUNKLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztZQUNqRCxPQUFPLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFO1NBQ2hELENBQUMsQ0FBQyxDQUFDO1FBRUosSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUU7WUFDbEMsTUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDO1lBQ2pCLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUVuRSxJQUFJLFVBQVUsS0FBSyxTQUFTO2dCQUFFLE1BQU0sS0FBSyxDQUFDLGNBQWMsQ0FBQyxDQUFDLElBQUksWUFBWSxDQUFDLENBQUM7WUFFNUUsTUFBTSxPQUFPLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQztZQUNoQyxJQUFJLE9BQU8sS0FBSyxFQUFFO2dCQUFFLE9BQU87WUFFM0IsSUFBSTtnQkFDRixNQUFNLFdBQVcsR0FBRyxJQUFJLEtBQUssQ0FBQyxXQUFXLEVBQUUsQ0FBQztnQkFDNUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxHQUFHLFdBQVcsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBRXhELENBQUMsQ0FBQyxJQUFJLEdBQUcsYUFBYSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFFbEQsVUFBVSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7b0JBQ3JDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQztvQkFFM0QsSUFBSSxHQUFHLEtBQUssU0FBUzt3QkFBRSxNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLGFBQWEsMEJBQTBCLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO29CQUU3RixHQUFHLENBQUMsSUFBSSxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQ3RDLENBQUMsQ0FBQyxDQUFDO2dCQUVILElBQUksVUFBVSxDQUFDLFlBQVksRUFBRTtvQkFDM0IsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEdBQUcsYUFBYSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7aUJBQ2pFO2FBQ0Y7WUFBQyxPQUFPLENBQUMsRUFBRTtnQkFDVixzQ0FBc0M7Z0JBQ3RDLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZTtvQkFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLHdDQUF3QyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7YUFDakc7UUFDSCxDQUFDLENBQUMsQ0FBQztRQUVILElBQUksSUFBSSxDQUFDLGNBQWMsS0FBSyxNQUFNO1lBQUUsT0FBTztRQUUzQyxzQ0FBc0M7UUFFdEMsSUFBSSxDQUFDLGNBQWMsR0FBRyxPQUFPLENBQUM7UUFFOUIsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLO2FBQ1osR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO2FBQ2xCLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO1lBQ2IsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxFQUFFO2dCQUMzQixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3pFLElBQUksT0FBTyxLQUFLLFNBQVM7b0JBQUUsT0FBTztnQkFDbEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDaEM7UUFDSCxDQUFDLENBQUMsQ0FBQztRQUVMLE9BQU8sSUFBSSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDekMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLEVBQUcsQ0FBQyxDQUFDO1NBQ3hEO1FBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDOUQsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBQSx1QkFBWSxFQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDaEQsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUFFTyxJQUFJLENBQUMsSUFBYSxFQUFFLElBQVksRUFBRSxJQUFjLEVBQUUsWUFBcUI7UUFDN0UsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFFckIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLElBQUksQ0FBQztZQUFFLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBRTVELElBQUksWUFBWTtZQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksRUFBRSxNQUFNLFlBQVksRUFBRSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7UUFDNUYsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUUsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7SUFFTyxRQUFRLENBQUMsSUFBYSxFQUFFLElBQVksRUFBRSxZQUFxQjtRQUNqRSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsU0FBUyxDQUFDLElBQUksRUFBRSxZQUFZLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBRU8sWUFBWSxDQUFDLElBQWdEO1FBQ25FLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGdCQUFnQixDQUFDLEVBQUU7WUFDL0MsT0FBTyx5QkFBeUIsQ0FBQztTQUNsQztRQUVELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtZQUM3QyxPQUFPLG1CQUFtQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztRQUM1RCxDQUFDLENBQUMsQ0FBQztRQUVILE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDO2FBQ3pHLE9BQU8sQ0FBQyxVQUFVLEVBQUUsU0FBUyxDQUFDO2FBQzlCLE9BQU8sQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDO2FBQzNCLE9BQU8sQ0FBQyxjQUFjLEVBQUUsUUFBUSxDQUFDLEVBQUUsQ0FBQztJQUN6QyxDQUFDO0lBRU8sVUFBVSxDQUFDLFVBQXNEO1FBQ3ZFLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxXQUFXLElBQUksQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzVFLENBQUM7SUFFTyxlQUFlO1FBQ3JCLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBRWhILFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQyxVQUFVLEVBQUUsRUFBRTtZQUNsQyxJQUFJLFVBQVUsS0FBSyxZQUFZO2dCQUFFLE9BQU87WUFDeEMsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7Z0JBQy9CLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO29CQUM1QyxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFFLENBQUM7b0JBQ3BFLE9BQU8sVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFXLENBQUMsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUM7Z0JBQzdELENBQUMsQ0FBQyxDQUFDO2dCQUVILE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQXNCLENBQUMsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztnQkFFbkcsSUFBSSxPQUFPLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxLQUFLLFNBQVMsSUFBSSxNQUFNLEtBQUssU0FBUyxFQUFFO29CQUNqRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FDekcsSUFBSSxDQUFDLElBQUksVUFBVSxFQUFFLEVBQ3JCLGtCQUFrQixDQUNuQixDQUFDO29CQUNGLE9BQU87aUJBQ1I7Z0JBRUQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxJQUFJLFVBQVUsR0FBRyxDQUFDLENBQUM7Z0JBRXRELElBQUksQ0FBQyxDQUFDLFdBQVcsRUFBRSxLQUFLLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLEVBQUUsTUFBTSxFQUFFO29CQUMvRCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsZ0JBQWdCLEVBQUUsaUJBQWlCLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFFLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztpQkFDOUc7Z0JBRUQsSUFBSSxPQUFPLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxNQUFNLEtBQUssU0FBUyxFQUFFO29CQUNoRCxJQUFJLENBQUMsUUFBUSxDQUNYLElBQUksQ0FBQyxTQUFTLEVBQ2QsS0FBSyxFQUNMLHdEQUF3RCxVQUFVLElBQUksQ0FBQyxFQUFFLENBQzFFLENBQUM7b0JBQ0YsT0FBTztpQkFDUjtnQkFFRCxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7b0JBQ3BCLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBRSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUN6RSxDQUFDLENBQUMsQ0FBQztnQkFFSCxJQUFJLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO29CQUN0QixJQUFJLENBQUMsU0FBUyxDQUNaLElBQUksQ0FBQyxTQUFTLEVBQ2Qsd0JBQXdCLEVBQ3hCLFNBQVMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsY0FBYyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FDaEUsQ0FBQztpQkFDSDtnQkFFRCxJQUFJLE1BQU0sRUFBRTtvQkFDVixJQUFJLENBQUMsU0FBUyxDQUNaLElBQUksQ0FBQyxTQUFTLEVBQ2Qsa0NBQWtDLEVBQ2xDLFdBQVcsTUFBTSxDQUFDLElBQUksRUFBRSxFQUN4QixPQUFPLEVBQ1AsUUFBUSxDQUNULENBQUM7aUJBQ0g7cUJBQU07b0JBQ0wsSUFBSSxDQUFDLFFBQVEsQ0FDWCxJQUFJLENBQUMsU0FBUyxFQUNkLEtBQUssRUFDTCw2REFBNkQsQ0FBQyxJQUFJLFVBQVUsRUFBRSxDQUMvRSxDQUFDO2lCQUNIO1lBQ0gsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUVILElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFO1lBQ2pGLE1BQU0sb0JBQW9CLEdBQUcsQ0FBQyxLQUFlLEVBQUUsRUFBRTtnQkFDL0MsSUFBSSxTQUFTLEdBQUcsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7Z0JBQ2pDLE1BQU0sT0FBTyxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFDakMsT0FBTyxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQUssT0FBTyxJQUFJLFNBQVMsSUFBSSxDQUFDLEVBQUU7b0JBQ3JELEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQztvQkFDWixTQUFTLEVBQUUsQ0FBQztpQkFDYjtnQkFDRCxPQUFPLEtBQUssQ0FBQztZQUNmLENBQUMsQ0FBQztZQUVGLE1BQU0sVUFBVSxHQUFHLG9CQUFvQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7WUFFL0csSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxHQUFHLFVBQVUsQ0FBQztTQUMvRDtJQUNILENBQUM7SUFFTyxnQkFBZ0IsQ0FBQyxJQUFhLEVBQUUsTUFBYyxFQUFFLElBQWMsRUFBRSxZQUFvQjtRQUMxRixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztRQUM1QixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFTyxhQUFhLENBQUMsSUFBYSxFQUFFLE1BQWMsRUFBRSxJQUFjO1FBQ2pFLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQzVCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBRU8sYUFBYSxDQUFDLElBQWEsRUFBRSxNQUFjO1FBQ2pELElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQzVCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQzVCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7SUFDekQsQ0FBQztJQUVPLFlBQVksQ0FBQyxJQUFhO1FBQ2hDLE1BQU0sYUFBYSxHQUFHO1lBQ3BCLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLHVCQUF1QixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDMUYsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsd0JBQXdCLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUM1RixDQUFDO1FBQ0YsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO1lBQzFCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzlELElBQUksT0FBTyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDL0QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQzNELElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUMzQjtRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVPLHFCQUFxQixDQUFDLElBQXVCO1FBQ25ELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUNsQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQztZQUFFLE1BQU0sS0FBSyxDQUFDLGtCQUFrQixDQUFDLENBQUM7UUFDaEYsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsT0FBTyxFQUFFLEtBQUssT0FBTztZQUFFLE1BQU0sS0FBSyxDQUFDLGtCQUFrQixDQUFDLENBQUM7UUFFaEYsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBRWpDLE1BQU0sWUFBWSxHQUFHLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLGVBQWUsRUFBRTtZQUN4RCxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLHNCQUFzQixFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsUUFBUSxFQUFFO1lBQ2pFLENBQUMsQ0FBQyxTQUFTLENBQUM7UUFDZCxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVPLGtCQUFrQixDQUFDLElBQW9CO1FBQzdDLE1BQU0sUUFBUSxHQUFHLGFBQWEsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ2xELElBQUksQ0FBQyxZQUFZLElBQUksQ0FBQyxDQUFDO1FBRXZCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7UUFDbEMsSUFBSSxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUM7UUFFNUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsR0FBRyxRQUFRLGFBQWEsQ0FBQyxDQUFDO1FBQzlDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUM7UUFDdEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsR0FBRyxRQUFRLEdBQUcsQ0FBQyxDQUFDO1FBQ3BDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEdBQUcsUUFBUSxZQUFZLENBQUMsQ0FBQztRQUM3QyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUM7UUFDOUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsT0FBTyxRQUFRLFlBQVksQ0FBQyxDQUFDO1FBQ2pELElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEdBQUcsUUFBUSxPQUFPLENBQUMsQ0FBQztRQUV4QyxJQUFJLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQztJQUM5QixDQUFDO0lBRU8scUJBQXFCLENBQUMsSUFBdUI7UUFDbkQsTUFBTSxRQUFRLEdBQUcsVUFBVSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDN0MsSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLENBQUM7UUFFckIsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQztRQUNsQyxJQUFJLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQztRQUU1QixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxHQUFHLFFBQVEsR0FBRyxDQUFDLENBQUM7UUFDcEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsR0FBRyxRQUFRLFlBQVksQ0FBQyxDQUFDO1FBQzdDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQztRQUM5QyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxNQUFNLFFBQVEsTUFBTSxDQUFDLENBQUM7UUFFMUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQztRQUN0QyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxLQUFLLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFDckMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsR0FBRyxRQUFRLE9BQU8sQ0FBQyxDQUFDO1FBRXhDLElBQUksQ0FBQyxXQUFXLEdBQUcsUUFBUSxDQUFDO0lBQzlCLENBQUM7SUFFTyxtQkFBbUIsQ0FBQyxJQUFxQjtRQUMvQyxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDOUIsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQzNDLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ3hFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBRTlDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUMsQ0FBQztRQUUvQyxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO1FBQ2pDLE1BQU0sUUFBUSxHQUFHLFFBQVEsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3pDLElBQUksQ0FBQyxRQUFRLElBQUksQ0FBQyxDQUFDO1FBRW5CLElBQUksQ0FBQyxXQUFXLEdBQUcsUUFBUSxDQUFDO1FBRTVCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEdBQUcsUUFBUSxHQUFHLENBQUMsQ0FBQztRQUNwQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLG1CQUFtQixFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDeEQsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDLENBQUM7UUFDcEQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsTUFBTSxRQUFRLE1BQU0sQ0FBQyxDQUFDO1FBRTFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUM7UUFFdEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsR0FBRyxRQUFRLFlBQVksQ0FBQyxDQUFDO1FBQzdDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMscUJBQXFCLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUMxRCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLENBQUM7UUFDL0MsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsS0FBSyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQ3JDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEdBQUcsUUFBUSxPQUFPLENBQUMsQ0FBQztRQUV4QyxJQUFJLENBQUMsV0FBVyxHQUFHLE9BQU8sQ0FBQztJQUM3QixDQUFDO0lBRU8scUJBQXFCLENBQUMsSUFBdUI7UUFDbkQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQ3ZDLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUNsQyxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsY0FBYyxFQUFnQyxDQUFDO1FBQ3pFLE1BQU0sSUFBSSxHQUFHLFlBQVksQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUV2RSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztJQUMxRCxDQUFDO0lBRUQ7O09BRUc7SUFDSyxXQUFXLENBQUMsSUFBYTtRQUMvQixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXhCLHVEQUF1RDtRQUN2RCxJQUFJLGNBQWMsR0FBRyxLQUFLLENBQUM7UUFFM0IsSUFDRSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQztZQUM1QyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQztZQUM3QyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUM7WUFDakMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsbUJBQW1CLENBQUM7WUFDL0MsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsaUJBQWlCLENBQUMsRUFDN0M7WUFDQSxJQUFJLElBQUksQ0FBQyxTQUFTLEtBQUssQ0FBQyxFQUFFO2dCQUN4QixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztnQkFDekIsY0FBYyxHQUFHLElBQUksQ0FBQzthQUN2QjtZQUNELElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQyxDQUFDO1NBQ3JCO1FBRUQsSUFBSTtZQUNGLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLG1CQUFtQixDQUFDO2dCQUFFLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDcEYsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDO2dCQUFFLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDaEYsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsaUJBQWlCLENBQUM7Z0JBQUUsSUFBSSxDQUFDLHVCQUF1QixDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUNyRixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsQ0FBQztnQkFBRSxJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQzNGLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQztnQkFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUN4RSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx1QkFBdUIsQ0FBQztnQkFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUNuRixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUM7Z0JBQUUsSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUM5RSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxzQkFBc0IsQ0FBQztnQkFBRSxJQUFJLENBQUMsNkJBQTZCLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQ2hHLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGlCQUFpQixDQUFDO2dCQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUM7aUJBQ3pGLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHVCQUF1QixDQUFDO2dCQUFFLElBQUksQ0FBQyw4QkFBOEIsQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDbEcsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksS0FBSyxHQUFHO2dCQUFFLElBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQztpQkFDbkYsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDO2dCQUFFLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDaEYsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDO2dCQUFFLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDaEYsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDO2dCQUFFLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDNUUsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDO2dCQUFFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUMvRSxjQUFjO2lCQUNULElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQztnQkFBRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQ3hFLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHVCQUF1QixDQUFDO2dCQUFFLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDOUYsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsbUJBQW1CLENBQUM7Z0JBQUUsSUFBSSxDQUFDLHlCQUF5QixDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUN6RixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDO2dCQUM1RixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzVCLFVBQVU7aUJBQ0wsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDO2dCQUFFLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDdkUsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDO2dCQUFFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDMUUsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMscUJBQXFCLENBQUM7Z0JBQUUsSUFBSSxDQUFDLHNCQUFzQixDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUN4RixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQztnQkFBRSxJQUFJLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQ3BGLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQyxFQUFFO2dCQUNsRCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7Z0JBQ2xDLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDLEVBQUU7b0JBQ3ZELElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDbkM7cUJBQU07b0JBQ0wsSUFBSSxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUNsQzthQUNGO2lCQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLG1CQUFtQixDQUFDO2dCQUFFLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDNUYsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsZUFBZSxDQUFDO2dCQUFFLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDbEYsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsdUJBQXVCLENBQUM7Z0JBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQztpQkFDL0YsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsaUJBQWlCLENBQUM7Z0JBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQyxDQUFDO2lCQUM5RixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx1QkFBdUIsQ0FBQztnQkFBRSxJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQzFGLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHFCQUFxQixDQUFDO2dCQUFFLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDOUYsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRTtnQkFDN0QsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQzthQUMxRDtpQkFBTSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxLQUFLLEVBQUUsQ0FBQyxVQUFVLENBQUMsWUFBWSxFQUFFO2dCQUNoRSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO2FBQzFEO2lCQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQyxFQUFFO2dCQUNwRCxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxLQUFLLElBQUksQ0FBQyxXQUFXLE1BQU0sQ0FBQyxDQUFDO2FBQ2xEO2lCQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGlCQUFpQixDQUFDLEVBQUU7Z0JBQ3ZELElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEtBQUssSUFBSSxDQUFDLFdBQVcsV0FBVyxDQUFDLENBQUM7YUFDdkQ7O2dCQUFNLE1BQU0sSUFBSSxLQUFLLENBQUMsc0JBQXNCLElBQUksQ0FBQyxXQUFXLEVBQUUsRUFBRSxDQUFDLENBQUM7U0FDcEU7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLElBQUksQ0FBQyxDQUFDLENBQUMsWUFBWSxLQUFLLENBQUM7Z0JBQUUsTUFBTSxDQUFDLENBQUM7WUFFbkMscUVBQXFFO1lBQ3JFLDhFQUE4RTtZQUM5RSxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRWxDLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMxQyxNQUFNLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLDZCQUE2QixDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUUsQ0FBQyxZQUFZLEVBQUUsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7WUFDMUcsTUFBTSxLQUFLLEdBQWEsRUFBRSxDQUFDO1lBQzNCLE1BQU0sT0FBTyxHQUFHLGNBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsYUFBYSxFQUFFLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztZQUMvRSxPQUFPO2lCQUNKLE9BQU8sRUFBRTtpQkFDVCxLQUFLLENBQUMsSUFBSSxDQUFDO2lCQUNYLE9BQU8sQ0FBQyxDQUFDLENBQVMsRUFBRSxDQUFTLEVBQUUsRUFBRTtnQkFDaEMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLE9BQU8sSUFBSSxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNyRCxDQUFDLENBQUMsQ0FBQztZQUVMLE1BQU0sR0FBRyxHQUFHLDhCQUE4QixPQUFPLENBQUMsV0FBVyxFQUFFLE9BQU8sT0FBTyxJQUFJLEdBQUcsQ0FBQyxJQUFJLElBQ3ZGLEdBQUcsQ0FBQyxTQUNOLFNBQVMsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO1lBRWxDLENBQUMsQ0FBQyxPQUFPLEdBQUcsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO1lBRTNELE1BQU0sQ0FBQyxDQUFDO1NBQ1Q7UUFFRCxJQUFJLGNBQWM7WUFBRSxJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRU8sOEJBQThCLENBQUMsSUFBZ0M7UUFDckUsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUMzQixJQUFJLElBQUksS0FBSyxTQUFTO1lBQUUsTUFBTSxJQUFJLEtBQUssRUFBRSxDQUFDO1FBQzFDLE1BQU0sUUFBUSxHQUFvQixFQUFFLENBQUM7UUFFckMsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXRDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtZQUNqQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGtCQUFrQixDQUFDO2dCQUFFLE1BQU0sSUFBSSxLQUFLLEVBQUUsQ0FBQztZQUNuRSxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsY0FBYyxFQUFHLENBQUM7UUFDM0YsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsb0JBQW9CLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUFFTyw0QkFBNEIsQ0FBQyxJQUE4QjtRQUNqRSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDO1FBQzdCLE1BQU0sV0FBVyxHQUFHLFdBQVcsRUFBRSxFQUFFLENBQUM7UUFDcEMsSUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLENBQUM7UUFFdkIsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDO1FBQzdDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLE1BQU0sV0FBVyxRQUFRLENBQUMsQ0FBQztRQUMvQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO1FBQ3JDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEtBQUssV0FBVyxNQUFNLENBQUMsQ0FBQztRQUM1QyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxHQUFHLFdBQVcsU0FBUyxDQUFDLENBQUM7UUFDN0MsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQztRQUN0QyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxHQUFHLFdBQVcsT0FBTyxDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVPLFNBQVMsQ0FBQyxJQUFhLEVBQUUsR0FBRyxLQUFlO1FBQ2pELEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBRU8sb0JBQW9CLENBQUMsUUFBZ0I7UUFDM0MsSUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLFNBQVM7WUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHdCQUF3QixDQUFDLENBQUM7UUFFM0UsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyxjQUFjLEVBQUU7WUFDekMsT0FBTyxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNyRDtRQUVELElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUssT0FBTyxFQUFFO1lBQ2xDLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUM7U0FDL0I7UUFFRCxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxLQUFLLE1BQU0sRUFBRTtZQUNqQyxPQUFPLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDaEQ7UUFFRCxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBRTtZQUNuQyxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQztTQUNoRDtRQUVELElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUssYUFBYSxFQUFFO1lBQ3hDLE9BQU8sSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDckQ7UUFFRCxNQUFNLElBQUksS0FBSyxFQUFFLENBQUM7SUFDcEIsQ0FBQztJQUVPLFlBQVksQ0FBQyxLQUFnQixFQUFFLGlCQUEwQixLQUFLO1FBQ3BFLE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztRQUVuRCxJQUFJLGNBQWM7WUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxVQUFVLEtBQUssQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3BHLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFakUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNyQixJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDN0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwQixJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUM3QixDQUFDLENBQUMsQ0FBQztRQUVILElBQUksY0FBYztZQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFFTyxZQUFZLENBQUMsUUFBaUQsRUFBRSxVQUFtQjtRQUN6RixJQUFJLElBQUksQ0FBQyxRQUFRLEtBQUssU0FBUztZQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsd0JBQXdCLENBQUMsQ0FBQztRQUMzRSxNQUFNLEVBQUUsUUFBUSxFQUFFLEdBQUcsSUFBSSxDQUFDO1FBRTFCLG9DQUFvQztRQUNwQyw0RUFBNEU7UUFFNUUsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUV6RCxNQUFNLFlBQVksR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDaEUsTUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDaEUsTUFBTSxXQUFXLEdBQUcsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxXQUFXLEVBQWMsQ0FBQztRQUN6RSxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxHQUFHLFlBQVksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1FBRTdFLE1BQU0sUUFBUSxHQUFHLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUUvQyxJQUFJLGdCQUFnQixHQUFjLEVBQUUsQ0FBQztRQUNyQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3hCLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDeEIsSUFBSSxDQUFDLFNBQVMsQ0FDWixVQUFVLEVBQ1YseUJBQXlCLEVBQ3pCLHlCQUF5QixFQUN6QixVQUFVLFVBQVUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMseUJBQXlCLENBQzVFLENBQUM7YUFDSDtZQUVELElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUU7Z0JBQ3hELGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDekIsT0FBTzthQUNSO1lBRUQsSUFBSSxnQkFBZ0IsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUMvQixJQUFJLENBQUMsWUFBWSxDQUFDLGdCQUFnQixDQUFDLENBQUM7Z0JBQ3BDLElBQUksQ0FBQyxRQUFRO29CQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLHVDQUF1QyxDQUFDLENBQUM7Z0JBQ3pFLCtDQUErQztxQkFDMUMsSUFBSSxnQkFBZ0IsQ0FBQyxNQUFNLEtBQUssQ0FBQztvQkFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxhQUFhLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBRTNFLGdCQUFnQixHQUFHLEVBQUUsQ0FBQzthQUN2QjtZQUVELElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRXpCLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLGVBQWUsRUFBRSxFQUFFO2dCQUNqQyxJQUFJLENBQUMsNkJBQTZCLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ2pEO2lCQUFNO2dCQUNMLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDckI7WUFFRCxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDckMsY0FBYyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFeEMsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSx3Q0FBd0MsQ0FBQyxDQUFDO2lCQUN4RixJQUFJLENBQUMsUUFBUTtnQkFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSx1Q0FBdUMsQ0FBQyxDQUFDO2lCQUN6RSxJQUFJLENBQUMsS0FBSyxDQUFDO2dCQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQy9DLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxnQkFBZ0IsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQy9CLElBQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztZQUNwQyxJQUFJLENBQUMsUUFBUTtnQkFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsRUFBRSx1Q0FBdUMsQ0FBQyxDQUFDO1lBQ2xGLElBQUksUUFBUSxJQUFJLGdCQUFnQixDQUFDLE1BQU0sS0FBSyxRQUFRLENBQUMsTUFBTTtnQkFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsRUFBRSxRQUFRLENBQUMsQ0FBQztTQUNsRztRQUVELElBQUksQ0FBQyxRQUFRO1lBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLEVBQUUsd0JBQXdCLEVBQUUsZ0NBQWdDLENBQUMsQ0FBQztJQUN4RyxDQUFDO0lBRU8sYUFBYSxDQUFDLElBQWEsRUFBRSxJQUFjO1FBQ2pELElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxNQUFNLEVBQUU7WUFDeEIsTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBRWpFLElBQUksYUFBYSxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUN2QixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztnQkFFNUIsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUM7b0JBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBQ3BFLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLFdBQVcsQ0FBQyxFQUFFLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEtBQUssR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUVqRSxJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUM7Z0JBRTFFLE9BQU87YUFDUjtZQUVELElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLEVBQUU7Z0JBQ2xDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUNoQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztnQkFDOUIsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDO2dCQUUxRSxPQUFPO2FBQ1I7U0FDRjtRQUVELE1BQU0sT0FBTyxHQUFHLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBRTFDLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxjQUFjLElBQUksSUFBSSxDQUFDLDBCQUEwQixDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3pFLE1BQU0sUUFBUSxHQUFHLG1CQUFtQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNoRCxJQUFJLFFBQVEsS0FBSyxNQUFNO2dCQUFFLE9BQU87WUFDaEMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFN0MsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ25DLElBQUksTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDZCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxPQUFPLE1BQU0sRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDO2FBQzVDO1lBQ0QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLGFBQWEsRUFBRSxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7U0FDL0Q7YUFBTSxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUN4QixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxhQUFhLEVBQUUsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1NBQzdFO2FBQU0sSUFBSSxPQUFPLEtBQUssTUFBTSxFQUFFO1lBQzdCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxPQUFPLEVBQUUsV0FBVyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1NBQ25FO2FBQU0sSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDMUIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDOUI7SUFDSCxDQUFDO0lBRU8sZUFBZSxDQUFDLElBQWM7UUFDcEMsTUFBTSxJQUFJLEdBQWlCLElBQUksWUFBWSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztRQUVyRCxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7UUFDZixJQUFJLGdCQUFnQixHQUFHLENBQUMsQ0FBQztRQUV6QixNQUFNLGVBQWUsR0FBRyxDQUFDLEVBQVksRUFBRSxFQUFFO1lBQ3ZDLE1BQU0sT0FBTyxHQUFHLG1CQUFtQixDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBRXhDLElBQUksT0FBTyxLQUFLLE1BQU0sRUFBRTtnQkFDdEIsZ0JBQWdCLElBQUksQ0FBQyxDQUFDO2dCQUN0QixJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksWUFBWSxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO2dCQUN2QyxPQUFPO2FBQ1I7WUFFRCxJQUFJLGdCQUFnQixFQUFFO2dCQUNwQixNQUFNLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDMUMsZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDO2FBQ3RCO1lBRUQsSUFBSSxFQUFFLENBQUMsSUFBSSxLQUFLLE9BQU8sSUFBSSxFQUFFLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBRTtnQkFDL0MsTUFBTSxDQUFDLEdBQUcsSUFBSSxZQUFZLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxDQUFDO2dCQUN2QyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUNuQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ2I7aUJBQU0sSUFBSSxFQUFFLENBQUMsSUFBSSxLQUFLLGFBQWEsSUFBSSxFQUFFLENBQUMsSUFBSSxLQUFLLGNBQWMsRUFBRTtnQkFDbEUsTUFBTSxDQUFDLEdBQUcsSUFBSSxZQUFZLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxDQUFDO2dCQUN2QyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQ3JDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDYjs7Z0JBQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLFlBQVksQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUU5QyxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLEVBQUU7Z0JBQzFCLE1BQU0sSUFBSSxDQUFDLENBQUM7YUFDYjtpQkFBTTtnQkFDTCxNQUFNLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsQ0FBQzthQUNsQztRQUNILENBQUMsQ0FBQztRQUVGLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxRQUFRLEVBQUU7WUFDMUIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7Z0JBQzNDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNyQixDQUFDLENBQUMsQ0FBQztTQUNKO1FBRUQsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLE9BQU8sRUFBRTtZQUN6QixJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO2dCQUMxQixlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDckIsQ0FBQyxDQUFDLENBQUM7U0FDSjtRQUVELElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxhQUFhLEVBQUU7WUFDL0IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQzNDO1FBRUQsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLGNBQWMsRUFBRTtZQUNoQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDM0M7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFTyxvQkFBb0IsQ0FBQyxRQUFpRCxFQUFFLFVBQW1CO1FBQ2pHLE1BQU0sRUFBRSxRQUFRLEVBQUUsR0FBRyxJQUFJLENBQUM7UUFDMUIsSUFBSSxRQUFRLEtBQUssU0FBUztZQUFFLE1BQU0sS0FBSyxDQUFDLHVEQUF1RCxDQUFDLENBQUM7UUFFakcsSUFDRSxRQUFRLENBQUMsSUFBSSxLQUFLLE9BQU87WUFDekIsUUFBUSxDQUFDLElBQUksS0FBSyxRQUFRO1lBQzFCLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxLQUFLLGFBQWEsSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLGNBQWMsQ0FBQyxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQzVHO1lBQ0EsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsVUFBVSxDQUFDLENBQUM7WUFDeEMsSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLGNBQWMsRUFBRTtnQkFDcEMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLEVBQUUsVUFBVSxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLEVBQUUsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO2FBQ3pHO1lBQ0QsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7WUFDekIsT0FBTztTQUNSO1FBRUQsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUV6RCxJQUNFLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyxhQUFhLElBQUksUUFBUSxDQUFDLElBQUksS0FBSyxjQUFjLENBQUM7WUFDckUsVUFBVSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUN6RDtZQUNBLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxJQUFJLEtBQUssY0FBYyxDQUFDLENBQUM7U0FDL0Q7YUFBTTtZQUNMLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3hCLElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUV6QixJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxlQUFlLEVBQUUsRUFBRTtvQkFDakMsSUFBSSxDQUFDLDZCQUE2QixDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDakQ7cUJBQU07b0JBQ0wsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDckI7Z0JBQ0QsY0FBYyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3hDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNoQyxJQUFJLENBQUM7b0JBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDN0MsQ0FBQyxDQUFDLENBQUM7U0FDSjtRQUVELElBQUksUUFBUSxDQUFDLElBQUksS0FBSyxhQUFhLEVBQUU7WUFDbkMsTUFBTSxFQUFFLE1BQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQztZQUU1QixJQUFJLE1BQU0sSUFBSSxRQUFRLENBQUMsTUFBTSxHQUFHLE1BQU0sRUFBRTtnQkFDdEMsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3JELElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFLFVBQVUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEdBQUcsQ0FBQyxNQUFNLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUU1RixJQUFJLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQztvQkFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsRUFBRSxRQUFRLENBQUMsQ0FBQzthQUM5RDtTQUNGO1FBRUQsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7SUFDM0IsQ0FBQztJQUVPLDZCQUE2QixDQUFDLElBQStCO1FBQ25FLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxTQUFTO1lBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO1FBQzNFLE1BQU0sRUFBRSxRQUFRLEVBQUUsR0FBRyxJQUFJLENBQUM7UUFFMUIsSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLGNBQWMsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUN2RSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDckMsT0FBTztTQUNSO1FBRUQsSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ssa0JBQWtCLENBQ3hCLElBQXlCLEVBQ3pCLFFBQStCLEVBQUU7UUFFakMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVqQjs7O1dBR0c7UUFDSCxJQUFJLElBQUksR0FBa0IsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBRS9DLDJEQUEyRDtRQUMzRCxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFO1lBQ2hELElBQUksR0FBRyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7U0FDN0I7UUFFRCxJQUNFLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx1QkFBdUIsQ0FBQztZQUNsRCxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUM7WUFDbkQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQyxFQUN6QztZQUNBLE9BQU8sSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztTQUM3QztRQUVELEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNoQixPQUFPLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsQ0FBQztJQUMvQixDQUFDO0lBRU8sY0FBYyxDQUFDLElBQWdDLEVBQUUsUUFBc0MsRUFBRTtRQUMvRixLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRWpCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUNsQyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx1QkFBdUIsQ0FBQyxFQUFFO1lBQ3RELElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQ2xDO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7T0FnQkc7SUFDSyxZQUFZLENBQ2xCLElBQWEsRUFDYixTQUFpQixFQUNqQixJQUFhO1FBZWIsSUFBSSxJQUFJLEdBQUcsU0FBUyxDQUFDO1FBQ3JCLElBQUksWUFBWSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFbEQsSUFBSSxJQUFJLEdBQXdCLE9BQU8sQ0FBQztRQUN4QyxJQUFJLGlCQUEwRCxDQUFDO1FBRS9ELE1BQU0sU0FBUyxHQUFpQyxFQUFFLENBQUM7UUFFbkQ7Ozs7Ozs7Ozs7O1VBV0U7UUFDRixPQUFPLFlBQVksQ0FBQyxZQUFZLEtBQUssU0FBUyxFQUFFO1lBQzlDLElBQUksWUFBWSxDQUFDLFNBQVM7Z0JBQUUsU0FBUyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUM7WUFFbkUsSUFBSSxHQUFHLFlBQVksQ0FBQyxZQUFhLENBQUM7WUFDbEMsWUFBWSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDMUM7UUFFRCxtR0FBbUc7UUFDbkcsSUFBSSxZQUFZLENBQUMsaUJBQWlCLEtBQUssU0FBUyxFQUFFO1lBQ2hELElBQUksWUFBWSxDQUFDLFNBQVM7Z0JBQUUsU0FBUyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDbkUsZ0RBQWdEO1lBQ2hELElBQUksR0FBRyxjQUFjLENBQUMsWUFBWSxDQUFDLGlCQUFpQixDQUFFLENBQUM7WUFDdkQsSUFBSSxHQUFHLFNBQVMsQ0FBQztZQUNqQixpQkFBaUIsR0FBRyxZQUFZLENBQUMsaUJBQWlCLENBQUM7U0FDcEQ7UUFFRCwwRUFBMEU7UUFDMUUsSUFBSSxDQUFDLElBQUksRUFBRTtZQUNULE9BQU87Z0JBQ0wsSUFBSTtnQkFDSixJQUFJO2dCQUNKLFNBQVMsRUFBRSxTQUFTLENBQUMsT0FBTyxFQUFFLENBQUMsSUFBSSxFQUFFO2dCQUNyQyxpQkFBaUI7Z0JBQ2pCLGVBQWUsRUFBRSxZQUFZLENBQUMsZUFBZTtnQkFDN0MsbUJBQW1CLEVBQUUsWUFBWSxDQUFDLG1CQUFtQjthQUN0RCxDQUFDO1NBQ0g7UUFFRCx5RUFBeUU7UUFDekUsSUFBSSxZQUFZLENBQUMsaUJBQWlCLEtBQUssU0FBUyxFQUFFO1lBQ2hELElBQUksQ0FBQyxtQkFBbUIsQ0FBQztnQkFDdkIsSUFBSSxFQUFFLFlBQVksQ0FBQyxpQkFBaUI7Z0JBQ3BDLGVBQWUsRUFBRSxZQUFZLENBQUMsZUFBZTtnQkFDN0MsbUJBQW1CLEVBQUUsWUFBWSxDQUFDLG1CQUFtQjtnQkFDckQsTUFBTSxFQUFFLEtBQUs7YUFDZCxDQUFDLENBQUM7WUFDSCxvSUFBb0k7U0FDckk7YUFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLG1CQUFtQixDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFO1lBQy9FLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLGFBQWEsWUFBWSxDQUFDLEtBQU0sT0FBTyxJQUFJLEtBQUssWUFBWSxDQUFDLFVBQVUsRUFBRSxFQUFFLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUMvRzthQUFNO1lBQ0wsSUFBSSxDQUFDLFFBQVEsR0FBRyxZQUFZLENBQUMsSUFBSSxDQUFDO1NBQ25DO1FBRUQsT0FBTyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLFNBQVMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDO0lBQy9ELENBQUM7SUFFTyxXQUFXLENBQUMsSUFBYTtRQUMvQixNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDO1FBQ2hELHlDQUF5QztRQUN6QyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUN6QyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDNUIsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUUzQyxJQUFJLFFBQVEsQ0FBQyxLQUFLLEtBQUssU0FBUyxFQUFFO2dCQUNoQyxNQUFNLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUM5RCxJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssSUFBSSxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRTtvQkFDbkUsTUFBTSxLQUFLLENBQUMscUZBQXFGLENBQUMsQ0FBQztpQkFDcEc7Z0JBRUQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsY0FBYyxLQUFLLE9BQU8sSUFBSSxLQUFLLFVBQVUsRUFBRSxDQUFDLENBQUM7YUFDdEU7aUJBQU07Z0JBQ0wsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUU1RCxJQUFJLGNBQWMsQ0FBQyxJQUFJLEtBQUssT0FBTyxFQUFFO29CQUNuQyxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFFdkQsSUFBSSxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLGNBQWMsQ0FBQyxJQUFJLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFO3dCQUNsRixNQUFNLEtBQUssQ0FBQyxxRkFBcUYsQ0FBQyxDQUFDO3FCQUNwRztvQkFFRCxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxjQUFjLEtBQUssQ0FBQyxLQUFLLE9BQU8sSUFBSSxLQUFLLEtBQUssQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDO2lCQUNsRjtxQkFBTTtvQkFDTCxNQUFNLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO29CQUNuRSxNQUFNLE1BQU0sR0FBRyxJQUFJLEtBQUssS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7b0JBQ3BGLElBQUksQ0FBQyxtQkFBbUIsQ0FBQzt3QkFDdkIsSUFBSSxFQUFFLGNBQWMsQ0FBQyxpQkFBa0I7d0JBQ3ZDLG1CQUFtQixFQUFFLGNBQWMsQ0FBQyxtQkFBbUI7d0JBQ3ZELGVBQWUsRUFBRSxjQUFjLENBQUMsZUFBZTt3QkFDL0MsTUFBTTtxQkFDUCxDQUFDLENBQUM7aUJBQ0o7YUFDRjtTQUNGO2FBQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDLEVBQUU7WUFDM0csSUFBSSxXQUErQixDQUFDO1lBRXBDLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQyxFQUFFO2dCQUM3QyxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDO29CQUN0RSxNQUFNLElBQUksS0FBSyxDQUFDLG9DQUFvQyxDQUFDLENBQUM7Z0JBQ3hELFdBQVcsR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBaUMsQ0FBQyxDQUFDO2FBQ25GOztnQkFBTSxXQUFXLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRTFDLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFZLENBQUMsRUFBRTtnQkFDOUIsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFZLENBQUMsQ0FBQztnQkFDM0MsTUFBTSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsR0FBRyxPQUFPLENBQUM7Z0JBRS9CLGNBQWMsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUNwQyxJQUFJLElBQUksS0FBSyxTQUFTLEVBQUU7b0JBQ3RCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLFNBQVMsSUFBSSxFQUFFLENBQUMsQ0FBQztpQkFDdEM7cUJBQU07b0JBQ0wsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBRXhFLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ3pDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO29CQUM1QixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztpQkFDL0I7Z0JBRUQsT0FBTzthQUNSO1lBQ0QsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFZLENBQUMsQ0FBQztZQUVwRCxNQUFNLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxHQUFHLFdBQVcsQ0FBQztZQUN4QyxJQUFJLE1BQU0sR0FDUixJQUFJLEtBQUssS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLFNBQVMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUM7Z0JBQ2xHLENBQUMsQ0FBQyxTQUFTO2dCQUNYLENBQUMsQ0FBQyxLQUFLLENBQUM7WUFDWixJQUFJLFNBQVMsQ0FBQyxJQUFJLEtBQUssTUFBTTtnQkFBRSxNQUFNLEdBQUcsS0FBSyxDQUFDO1lBQzlDLHFHQUFxRztZQUNyRyxrQkFBa0I7WUFDbEIsSUFDRSxJQUFJLEtBQUssS0FBSztnQkFDZCxNQUFNLEtBQUssU0FBUztnQkFDcEIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsRUFDbEU7Z0JBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7YUFDdEM7WUFFRCxJQUFJLENBQUMsbUJBQW1CLENBQUM7Z0JBQ3ZCLElBQUk7Z0JBQ0osTUFBTTthQUNQLENBQUMsQ0FBQztTQUNKO2FBQU07WUFDTCxNQUFNLElBQUksS0FBSyxDQUFDLGdCQUFnQixJQUFJLENBQUMsV0FBVyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1NBQzdEO0lBQ0gsQ0FBQztJQTBKTyxjQUFjLENBQUMsYUFBMkIsRUFBRSxTQUFxQyxFQUFFLElBQWE7UUFDdEcsSUFBSSxvQkFBb0IsR0FBRyxhQUFhLENBQUM7UUFDekMsSUFBSSxrQkFBa0IsR0FBRyxLQUFLLENBQUM7UUFFL0IsNkZBQTZGO1FBQzdGLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDM0IsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUU7Z0JBQzNCLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxFQUFFO29CQUNqQyxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFFbEYsTUFBTSxJQUFJLEdBQUcsb0JBQW9CLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBRXpDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLE9BQU8sSUFBSSxDQUFDLFVBQVUsZ0JBQWdCLEVBQUUsR0FBRyxDQUFDLENBQUM7b0JBRWxFLG9CQUFvQixHQUFHLElBQUksQ0FBQztvQkFDNUIsT0FBTztpQkFDUjtnQkFFRCxNQUFNLElBQUksR0FBRyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFFckMsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFFdkMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsYUFBYSxLQUFLLENBQUMsS0FBSyx1QkFBdUIsR0FBRyxFQUFFLEVBQUUsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUV4RixJQUFJLENBQUMsU0FBUyxDQUNaLElBQUk7Z0JBQ0osMEVBQTBFO2dCQUMxRSxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQ3RDLHVCQUF1QixFQUN2QixHQUFHLENBQ0osQ0FBQztnQkFFRixvQkFBb0IsR0FBRyxJQUFJLENBQUM7Z0JBQzVCLE9BQU87YUFDUjtZQUVELE1BQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFFOUMsTUFBTSxJQUFJLEdBQWlCLE1BQU0sQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDO2dCQUNoRCxDQUFDLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDO2dCQUN6QixDQUFDLENBQUMsb0JBQW9CLENBQUMsU0FBUyxDQUFDLElBQUksb0JBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFL0QsSUFBSSxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssTUFBTSxJQUFJLENBQUMsa0JBQWtCLEVBQUU7Z0JBQ3BFLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLE9BQU8sSUFBSSxDQUFDLFVBQVUsZ0JBQWdCLEVBQUUsR0FBRyxDQUFDLENBQUM7Z0JBRWpFLGtCQUFrQixHQUFHLElBQUksQ0FBQzthQUMzQjtpQkFBTSxJQUFJLG9CQUFvQixDQUFDLFNBQVMsS0FBSyxPQUFPLEVBQUU7Z0JBQ3JELElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLE9BQU8sSUFBSSxDQUFDLFVBQVUsZ0JBQWdCLEVBQUUsR0FBRyxDQUFDLENBQUM7Z0JBQ2pFLDZDQUE2QzthQUM5QztpQkFBTSxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUN4QyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsRUFBRTtvQkFDNUIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsT0FBTyxTQUFTLEdBQUcsQ0FBQyxhQUFhLEVBQUUsR0FBRyxDQUFDLENBQUM7aUJBQzdEO3FCQUFNO29CQUNMLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBRXRCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQzt3QkFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsQ0FBQztvQkFFMUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsT0FBTyxFQUFFLGNBQWMsRUFBRSxHQUFHLENBQUMsQ0FBQztpQkFDbkQ7Z0JBQ0QsMEJBQTBCO2FBQzNCO2lCQUFNLElBQUksQ0FBQyxrQkFBa0IsRUFBRTtnQkFDOUIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLEVBQUU7b0JBQzVCLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLE9BQU8sU0FBUyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxHQUFHLENBQUMsQ0FBQztpQkFDbEc7cUJBQU07b0JBQ0wsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFFdEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO3dCQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDO29CQUUxRCxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRSxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsdUJBQXVCLEVBQUUsR0FBRyxDQUFDLENBQUM7aUJBQzNGO2FBQ0Y7WUFFRCxJQUNFLG9CQUFvQixDQUFDLFNBQVMsS0FBSyxTQUFTO2dCQUM1QyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsMEJBQTBCLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLENBQUMsRUFDeEU7Z0JBQ0EsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsT0FBTyxFQUFFLHlCQUF5QixDQUFDLENBQUM7YUFDekQ7WUFFRCxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDL0QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsUUFBUSxlQUFlLENBQUMsU0FBUyxFQUFFLEVBQUUsTUFBTSxFQUFFLGdCQUFnQixDQUFDLENBQUM7YUFDcEY7WUFFRCxvQkFBb0IsR0FBRyxJQUFJLENBQUM7UUFDOUIsQ0FBQyxDQUFDLENBQUM7UUFFSCxPQUFPLG9CQUFvQixDQUFDO0lBQzlCLENBQUM7SUFFTywrQkFBK0IsQ0FDckMsSUFBYSxFQUNiLFNBQXFDLEVBQ3JDLGdCQUF5QixFQUN6QixRQUFrQjtRQUVsQixNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBRWpDLElBQUksb0JBQW9CLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUU1RCxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzNCLElBQUksU0FBNkIsQ0FBQztZQUVsQyxJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVEsRUFBRTtnQkFDM0IsSUFBSSxHQUFHLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxFQUFFO29CQUNoQyxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUV2QyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxhQUFhLEtBQUssQ0FBQyxLQUFLLHVCQUF1QixHQUFHLEVBQUUsRUFBRSxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7aUJBQ3pGOztvQkFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDeEY7aUJBQU0sSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLEVBQUU7Z0JBQ25ELFNBQVMsR0FBRyxRQUFRLENBQUUsR0FBcUIsQ0FBQyxPQUFPLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQzthQUM1RDtpQkFBTTtnQkFDTCxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ3ZCO1lBRUQsTUFBTSxZQUFZLEdBQUcsb0JBQW9CLENBQUMsU0FBUyxJQUFJLENBQUMsQ0FBQyxJQUFJLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRXJGLElBQUksU0FBUyxJQUFJLG9CQUFvQixDQUFDLFNBQVMsQ0FBQyxFQUFFO2dCQUNoRCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxPQUFPLFlBQVksQ0FBQyxVQUFVLGdCQUFnQixDQUFDLENBQUM7YUFDdEU7aUJBQU07Z0JBQ0wsSUFBSSxTQUFTLEtBQUssU0FBUztvQkFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxPQUFPLFNBQVMsRUFBRSxDQUFDLENBQUM7Z0JBQ3JFLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSx1QkFBdUIsQ0FBQyxDQUFDO2FBQy9GO1lBRUQsSUFBSSxDQUFDO2dCQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBRWhDLG9CQUFvQixHQUFHLFlBQVksQ0FBQztRQUN0QyxDQUFDLENBQUMsQ0FBQztRQUVILE1BQU0sSUFBSSxHQUFHLG9CQUFvQixDQUFDO1FBRWxDLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRTdDLE1BQU0saUJBQWlCLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxFQUFFLGlCQUFpQixJQUFJLGdCQUFnQixDQUFDO1FBQ2pILE1BQU0sS0FBSyxHQUNULGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDO1lBQ2hFLGNBQWMsQ0FBQyxpQkFBaUIsQ0FBQztZQUNqQyxJQUFJLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxpQkFBaUIsQ0FBRSxDQUFDO1lBQ3JELElBQUksQ0FBQyxZQUFZLENBQUMsY0FBYyxDQUFDLGlCQUFpQixDQUFFLENBQUMsQ0FBQyxJQUFJLEtBQUssS0FBSztZQUNwRSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxjQUFjLENBQUMsaUJBQWlCLENBQUUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRXZGLElBQUksUUFBUSxFQUFFO1lBQ1osSUFBSSxRQUFRLENBQUMsT0FBTyxFQUFFLENBQUMsZUFBZSxFQUFFLEVBQUU7Z0JBQ3hDLElBQUksQ0FBQyxlQUFlLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUMzQztpQkFBTTtnQkFDTCxJQUFJLENBQUMsZUFBZSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQ2hDO1lBRUQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRXBDLElBQUksQ0FBQyxLQUFLLEVBQUU7Z0JBQ1YsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7YUFDakM7WUFFRCxJQUFJLENBQUMsV0FBVyxDQUFDLGdCQUFnQixDQUFDLENBQUM7U0FDcEM7YUFBTTtZQUNMLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLE9BQU8sTUFBTSxFQUFFLENBQUMsQ0FBQztZQUNyQyxJQUFJLEtBQUssRUFBRTtnQkFDVCxJQUFJLENBQUMsbUJBQW1CLENBQUM7b0JBQ3ZCLElBQUksRUFBRSxpQkFBaUI7b0JBQ3ZCLE1BQU0sRUFBRSxTQUFTO2lCQUNsQixDQUFDLENBQUM7YUFDSjs7Z0JBQU0sSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7WUFFeEMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3BDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztTQUMzQjtJQUNILENBQUM7SUFFTyx3QkFBd0IsQ0FDOUIsSUFBYSxFQUNiLFNBQXFDLEVBQ3JDLGdCQUF5QixFQUN6QixRQUFrQjtRQUVsQixNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBRWpDLGlGQUFpRjtRQUNqRiwrRkFBK0Y7UUFDL0YseUJBQXlCO1FBQ3pCLE1BQU0sZUFBZSxHQUFHLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLFVBQVUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM3RyxJQUFJLGdCQUFnQixHQUFHLElBQUksQ0FBQztRQUU1QixTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDdEIsSUFBSSxPQUFPLENBQUMsS0FBSyxRQUFRLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUM7b0JBQUUsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDO2dCQUN6RCxPQUFPO2FBQ1I7WUFFRCxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFFLENBQW1CLENBQUMsT0FBTyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7Z0JBQUUsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDO1FBQzNGLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxlQUFlLEVBQUU7WUFDbkIsSUFBSSxDQUFDLCtCQUErQixDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDbEYsT0FBTztTQUNSO1FBRUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsU0FBUyxlQUFlLENBQUMsU0FBUyxFQUFFLEVBQUUseUJBQXlCLENBQUMsQ0FBQztRQUV0RixNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRXZELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsYUFBYSxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUVwRSxJQUFJLFFBQThCLENBQUM7UUFFbkMsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxhQUFhLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssY0FBYyxFQUFFO1lBQy9FLFFBQVEsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztTQUM5QjthQUFNO1lBQ0wsUUFBUSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUM7U0FDekI7UUFFRCxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3BDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLEVBQUU7Z0JBQzFELE1BQU0sSUFBSSxLQUFLLENBQUMsK0NBQStDLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7YUFDckc7WUFFRCxJQUFJLFFBQVEsRUFBRTtnQkFDWixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsU0FBUyxlQUFlLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxDQUFDO2FBQzNFO1lBRUQsSUFBSSxDQUFDLFNBQVMsQ0FDWixJQUFJLEVBQ0osUUFBUSxlQUFlLENBQUMsU0FBUyxFQUFFLEVBQ25DLFFBQVEsZUFBZSxDQUFDLFNBQVMsRUFBRSxFQUNuQyxXQUFXLEVBQ1gsZ0JBQWdCLENBQ2pCLENBQUM7WUFFRixJQUFJLE9BQU8sQ0FBQyxNQUFPLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxjQUFjLEVBQUU7Z0JBQ2hELElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSx5QkFBeUIsQ0FBQyxDQUFDO2FBQzFEO1lBRUQsSUFBSSxRQUFRLEVBQUU7Z0JBQ1osSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLFNBQVMsZUFBZSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUM7YUFDdEU7WUFFRCxJQUFJLENBQUMsU0FBUyxDQUNaLElBQUksRUFDSixtQ0FBbUMsRUFDbkMsUUFBUSxlQUFlLENBQUMsU0FBUyxFQUFFLEVBQ25DLE1BQU0sRUFDTiwwQ0FBMEMsRUFDMUMsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVMsQ0FBQyxxQkFBcUIsRUFDekQsOEJBQThCLEVBQzlCLE9BQU8sRUFDUCx5QkFBeUIsQ0FDMUIsQ0FBQztZQUVGLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsU0FBUyxlQUFlLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQ3ZGO1FBRUQsSUFBSSxRQUFRLEVBQUU7WUFDWixJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUNwQyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEVBQUUsU0FBUyxLQUFLLE9BQU8sRUFBRTtvQkFDekMsTUFBTSxJQUFJLEtBQUssQ0FDYixrSEFBa0gsQ0FDbkgsQ0FBQztpQkFDSDtnQkFDRCxrQkFBa0I7Z0JBQ2xCLElBQUksQ0FBQyxTQUFTLENBQ1osSUFBSSxFQUNKLFFBQVEsZUFBZSxDQUFDLFNBQVMsRUFBRSxFQUNuQyxPQUFPLEVBQ1AsUUFBUSxlQUFlLENBQUMsWUFBWSxFQUFFLEVBQ3RDLFlBQVksQ0FDYixDQUFDO2dCQUVGLGtCQUFrQjtnQkFDbEIsSUFBSSxRQUFRLENBQUMsT0FBTyxFQUFFLENBQUMsZUFBZSxFQUFFLEVBQUU7b0JBQ3hDLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUM1RDtxQkFBTTtvQkFDTCxJQUFJLENBQUMsZUFBZSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2lCQUNoQztnQkFFRCxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBRTVDLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLEtBQUssRUFBRSxTQUFTLGVBQWUsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDO2dCQUV2RSxtQkFBbUI7Z0JBQ25CLElBQUksQ0FBQyxTQUFTLENBQ1osSUFBSSxFQUNKLFFBQVEsZUFBZSxDQUFDLFNBQVMsRUFBRSxFQUNuQyxRQUFRLGVBQWUsQ0FBQyxZQUFZLEVBQUUsRUFDdEMsUUFBUSxlQUFlLENBQUMsYUFBYSxFQUFFLEVBQ3ZDLHlCQUF5QixFQUN6QixRQUFRLGVBQWUsQ0FBQyxTQUFTLEVBQUUsRUFDbkMsS0FBSyxFQUNMLFlBQVksQ0FDYixDQUFDO2dCQUVGLGlCQUFpQjtnQkFDakIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxTQUFTLGVBQWUsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDO2dCQUUvRSx3QkFBd0I7Z0JBQ3hCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLGdDQUFnQyxDQUFDLENBQUM7Z0JBRXZELE1BQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxNQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQztnQkFFM0UsTUFBTSxtQkFBbUIsR0FBRyxPQUFPLENBQUMsTUFBTyxDQUFDLEtBQUssQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO2dCQUU5RyxNQUFNLFNBQVMsR0FBRyxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO2dCQUVwRixTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUU7b0JBQ3pCLElBQUksQ0FBQyxTQUFTLENBQ1osSUFBSSxFQUNKLFFBQVEsZUFBZSxDQUFDLGdCQUFnQixFQUFFLEVBQzFDLFFBQVEsZUFBZSxDQUFDLGlCQUFpQixFQUFFLEVBQzNDLE9BQU8sSUFBSSxFQUFFLEVBQ2IsaUJBQWlCLEVBQ2pCLDhCQUE4QixDQUMvQixDQUFDO2dCQUNKLENBQUMsQ0FBQyxDQUFDO2dCQUVILElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLFFBQVEsZUFBZSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7YUFDMUQ7aUJBQU0sSUFBSSxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssTUFBTSxFQUFFO2dCQUN2RCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUscUJBQXFCLENBQUMsQ0FBQztnQkFFckQsSUFBSSxnQkFBZ0IsR0FBRyxDQUFDLENBQUM7Z0JBQ3pCLE1BQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxNQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQztnQkFDM0UsTUFBTSxjQUFjLEdBQUcsT0FBTyxDQUFDLE1BQU8sQ0FBQyxJQUFJLENBQUM7Z0JBRTVDLElBQUksY0FBYyxDQUFDLElBQUksS0FBSyxPQUFPLElBQUksY0FBYyxDQUFDLElBQUksS0FBSyxRQUFRLEVBQUU7b0JBQ3ZFLEtBQUssSUFBSSxDQUFDLEdBQUcsWUFBWSxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO3dCQUMxQyxNQUFNLEVBQUUsSUFBSSxFQUFFLEdBQUcsT0FBTyxDQUFDLE1BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFDcEMsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sRUFBRTs0QkFDaEQsZ0JBQWdCLElBQUksQ0FBQyxDQUFDO3lCQUN2Qjs7NEJBQU0sTUFBTTtxQkFDZDtvQkFFRCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxPQUFPLGdCQUFnQixFQUFFLENBQUMsQ0FBQztpQkFDakQ7cUJBQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsdUJBQXVCLENBQUMsRUFBRTtvQkFDN0QsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7b0JBQzdDLElBQUksT0FBTyxLQUFLLFNBQVM7d0JBQUUsTUFBTSxLQUFLLEVBQUUsQ0FBQztvQkFFekMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztpQkFDM0I7cUJBQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUMsRUFBRTtvQkFDOUQsSUFBSSxVQUFVLEVBQUUsSUFBSSxLQUFLLFFBQVE7d0JBQUUsTUFBTSxLQUFLLEVBQUUsQ0FBQztvQkFDakQsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO29CQUN2RSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxPQUFPLEdBQUcsRUFBRSxDQUFDLENBQUM7aUJBQ25DOztvQkFBTSxNQUFNLEtBQUssRUFBRSxDQUFDO2dCQUVyQixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSx3QkFBd0IsQ0FBQyxDQUFDO2dCQUMvQyxJQUFJLE9BQU8sQ0FBQyxNQUFPLENBQUMsU0FBUyxLQUFLLFNBQVMsRUFBRTtvQkFDM0MsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLGdDQUFnQyxDQUFDLENBQUM7aUJBQ2xFO2dCQUNELElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLFFBQVEsZUFBZSxDQUFDLFNBQVMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxDQUFDO2dCQUNsRSxJQUFJLENBQUMsZUFBZSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUUvQixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQzthQUMvQjtpQkFBTTtnQkFDTCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxRQUFRLGVBQWUsQ0FBQyxTQUFTLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQztnQkFDbEUsSUFBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDL0IsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUM1QyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQzthQUNqQztZQUVELElBQUksQ0FBQyxXQUFXLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztTQUNwQzthQUFNO1lBQ0wsSUFBSSxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssTUFBTSxFQUFFO2dCQUNoRCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsR0FBRyxDQUFDLENBQUM7Z0JBRW5DLElBQUksZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDO2dCQUN6QixNQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsTUFBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQzNFLE1BQU0sY0FBYyxHQUFHLE9BQU8sQ0FBQyxNQUFPLENBQUMsSUFBSSxDQUFDO2dCQUU1QyxJQUFJLGNBQWMsQ0FBQyxJQUFJLEtBQUssT0FBTyxJQUFJLGNBQWMsQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO29CQUN2RSxLQUFLLElBQUksQ0FBQyxHQUFHLFlBQVksR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTt3QkFDMUMsTUFBTSxFQUFFLElBQUksRUFBRSxHQUFHLE9BQU8sQ0FBQyxNQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQ3BDLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxNQUFNLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxNQUFNLEVBQUU7NEJBQ2hELGdCQUFnQixJQUFJLENBQUMsQ0FBQzt5QkFDdkI7OzRCQUFNLE1BQU07cUJBQ2Q7b0JBRUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsT0FBTyxnQkFBZ0IsRUFBRSxDQUFDLENBQUM7aUJBQ2pEO3FCQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHVCQUF1QixDQUFDLEVBQUU7b0JBQzdELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO29CQUM3QyxJQUFJLE9BQU8sS0FBSyxTQUFTO3dCQUFFLE1BQU0sS0FBSyxFQUFFLENBQUM7b0JBRXpDLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7aUJBQzNCO3FCQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDLEVBQUU7b0JBQzlELElBQUksVUFBVSxFQUFFLElBQUksS0FBSyxRQUFRO3dCQUFFLE1BQU0sS0FBSyxFQUFFLENBQUM7b0JBQ2pELE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztvQkFDdkUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsT0FBTyxHQUFHLEVBQUUsQ0FBQyxDQUFDO2lCQUNuQzs7b0JBQU0sTUFBTSxLQUFLLEVBQUUsQ0FBQztnQkFFckIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLFFBQVEsZUFBZSxDQUFDLFNBQVMsRUFBRSxFQUFFLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztnQkFFakYsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxDQUFDO2dCQUMvQyxPQUFPO2FBQ1I7WUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQ3JDLElBQUksQ0FBQyxTQUFTLENBQ1osSUFBSSxFQUNKLFFBQVEsZUFBZSxDQUFDLFNBQVMsRUFBRSxFQUNuQyxNQUFNLEVBQ04sT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUN6QyxVQUFVLENBQ1gsQ0FBQzthQUNIO1lBRUQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRXZDLElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQztTQUM5QjtJQUNILENBQUM7SUFFTyx1QkFBdUIsQ0FBQyxJQUEwQjtRQUN4RCxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQztZQUFFLE1BQU0sS0FBSyxDQUFDLGdDQUFnQyxDQUFDLENBQUM7UUFDeEcsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFLEtBQUssU0FBUztZQUNwQyxNQUFNLEtBQUssQ0FBQyxnREFBZ0QsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQztRQUU5RixNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsRUFBRSxPQUFPLEVBQUU7WUFDcEQsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFHLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDdkQsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUM7UUFFbkIsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBRSxDQUFDO1FBRWhHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEdBQUcsSUFBSTthQUMvQixTQUFTLEVBQUU7YUFDWCxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQzthQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFZCxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMscUNBQXFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFFMUcsSUFBSSxLQUFLLEdBQUcsUUFBUSxDQUFDO1FBRXJCLElBQUksQ0FBQyxZQUFZLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtZQUNqQyxJQUNFLElBQUk7aUJBQ0QsYUFBYSxFQUFFO2lCQUNmLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO2lCQUN4QixRQUFRLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUV6QixPQUFPO1lBQ1QsSUFBSSxDQUFDLENBQUMsWUFBWSxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLGNBQWM7Z0JBQUUsS0FBSyxHQUFHLFNBQVMsQ0FBQztpQkFDdkUsSUFBSSxDQUFDLENBQUMsWUFBWSxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLGdCQUFnQjtnQkFBRSxLQUFLLEdBQUcsV0FBVyxDQUFDO2lCQUNoRixJQUFJLENBQUMsQ0FBQyxZQUFZLENBQUMsSUFBSSxLQUFLLEVBQUUsQ0FBQyxVQUFVLENBQUMsYUFBYSxFQUFFO2dCQUM1RCxNQUFNLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLE9BQU8sRUFBRSxrQ0FBa0MsQ0FBQyxDQUFDO2FBQ2hGO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLEtBQUssS0FBSyxRQUFRLEVBQUU7WUFDdEIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzdCLE9BQU87U0FDUjtRQUVELElBQUksSUFBSSxDQUFDLGNBQWMsS0FBSyxNQUFNLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxLQUFLLE9BQU8sRUFBRTtZQUM5RSxNQUFNLEtBQUssQ0FBQyxvRUFBb0UsQ0FBQyxDQUFDO1NBQ25GO1FBRUQsSUFBSSxJQUFJLENBQUMsY0FBYyxLQUFLLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxVQUFVLEVBQUUsU0FBUyxDQUFDLElBQUksQ0FBQztZQUMzRSxNQUFNLEtBQUssQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDO1FBRTNELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLEdBQUcsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsQ0FBQztRQUN6RCxJQUFJLFVBQVUsR0FBRyxLQUFLLENBQUM7UUFFdkIsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQztRQUN0QyxJQUNFO1lBQ0UsbUJBQW1CO1lBQ25CLG1CQUFtQjtZQUNuQixtQkFBbUI7WUFDbkIsb0JBQW9CO1lBQ3BCLHVCQUF1QjtZQUN2QixZQUFZO1NBQ2IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQ2I7WUFDQSxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxLQUFLLG1CQUFtQixDQUFDO1lBQ3JFLElBQUksRUFBYyxDQUFDO1lBRW5CLElBQUksQ0FBQyxLQUFLLG1CQUFtQjtnQkFBRSxFQUFFLEdBQUcsTUFBTSxDQUFDO2lCQUN0QyxJQUFJLENBQUMsS0FBSyxtQkFBbUI7Z0JBQUUsRUFBRSxHQUFHLG1CQUFtQixDQUFDO2lCQUN4RCxJQUFJLENBQUMsS0FBSyxtQkFBbUI7Z0JBQUUsRUFBRSxHQUFHLG1CQUFtQixDQUFDO2lCQUN4RCxJQUFJLENBQUMsS0FBSyxvQkFBb0I7Z0JBQUUsRUFBRSxHQUFHLE9BQU8sQ0FBQztpQkFDN0MsSUFBSSxDQUFDLEtBQUssdUJBQXVCO2dCQUFFLEVBQUUsR0FBRyxVQUFVLENBQUM7aUJBQ25ELElBQUksQ0FBQyxLQUFLLFlBQVk7Z0JBQUUsRUFBRSxHQUFHLFlBQVksQ0FBQzs7Z0JBQzFDLE1BQU0sS0FBSyxFQUFFLENBQUM7WUFFbkIsTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztZQUU1QyxJQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLE1BQWdCLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDMUQ7UUFFRCxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDakMsTUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBQy9CLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDLEVBQUU7Z0JBQ3ZELElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE9BQU8sRUFBRSxLQUFLLEtBQUs7b0JBQUUsTUFBTSxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7Z0JBQzlGLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxLQUFLLFVBQVU7b0JBQUUsTUFBTSxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7Z0JBQ25GLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO2dCQUN2QyxPQUFPO2FBQ1I7WUFFRCxNQUFNLFFBQVEsR0FBRyxDQUFDLENBQUMsYUFBYSxFQUFFLENBQUM7WUFDbkMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUM7Z0JBQUUsTUFBTSxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDcEcsTUFBTSxRQUFRLEdBQUcsUUFBUSxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBRTFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUM7Z0JBQUUsTUFBTSxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDOUcsTUFBTSxjQUFjLEdBQUcsUUFBUSxDQUFDLGFBQWEsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQzFELE1BQU0saUJBQWlCLEdBQUcsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBRTNELFFBQVEsY0FBYyxFQUFFO2dCQUN0QixLQUFLLEtBQUs7b0JBQ1IsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7b0JBQ3ZDLE1BQU07Z0JBQ1IsS0FBSyxPQUFPO29CQUNWLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUUsWUFBWSxFQUFFLFVBQVUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQzt3QkFDM0UsTUFBTSxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7b0JBRWxELElBQUksaUJBQWlCLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUM7d0JBQ2hGLE1BQU0sS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7b0JBRXBFLElBQUksQ0FBQyxRQUFRLEVBQUUsWUFBWSxDQUFDLENBQUMsUUFBUSxDQUFDLGlCQUFpQixDQUFDLElBQUksUUFBUSxDQUFDLFlBQVksRUFBRSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7d0JBQ2hHLElBQUksaUJBQWlCLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFOzRCQUN4QyxVQUFVLEdBQUcsSUFBSSxDQUFDOzRCQUNsQixJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSTtnQ0FBRSxNQUFNLEtBQUssQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDOzRCQUMvRSxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksR0FBRyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsQ0FBQzt5QkFDdEY7OzRCQUFNLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztxQkFDMUQ7eUJBQU07d0JBQ0wsTUFBTSxHQUFHLEdBQUcsUUFBUSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUN2QyxJQUFJLEdBQUcsS0FBSyxTQUFTOzRCQUFFLE1BQU0sS0FBSyxDQUFDLG1DQUFtQyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDO3dCQUVyRixJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQzs0QkFBRSxNQUFNLEtBQUssQ0FBQyx1QkFBdUIsR0FBRyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQzt3QkFFbEcsTUFBTSxFQUFFLEdBQUcsR0FBRyxDQUFDLGNBQWMsRUFNTixDQUFDO3dCQUN4QixJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7NEJBQUUsTUFBTSxLQUFLLENBQUMsdUJBQXVCLEVBQUUsRUFBRSxDQUFDLENBQUM7d0JBRXpFLElBQUksaUJBQWlCLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFOzRCQUN4QyxVQUFVLEdBQUcsSUFBSSxDQUFDOzRCQUNsQixJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDO2dDQUFFLE1BQU0sS0FBSyxDQUFDLGdDQUFnQyxFQUFFLEVBQUUsQ0FBQyxDQUFDOzRCQUMvRSxNQUFNLE1BQU0sR0FBRyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDLFdBQVcsRUFBdUIsQ0FBQzs0QkFFeEYsSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksRUFBRSxDQUFDO3lCQUMzRTs7NEJBQU0sSUFBSSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxpQkFBMkIsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztxQkFDNUU7b0JBQ0QsTUFBTTtnQkFFUixLQUFLLHNCQUFzQjtvQkFDekIsSUFBSSxRQUFRLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUU7d0JBQzlCLE1BQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFFdkMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUM7NEJBQUUsTUFBTSxLQUFLLENBQUMsdUJBQXVCLEdBQUcsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7d0JBRWxHLE1BQU0sRUFBRSxHQUFHLEdBQUcsQ0FBQyxjQUFjLEVBTU4sQ0FBQzt3QkFDeEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDOzRCQUFFLE1BQU0sS0FBSyxDQUFDLHVCQUF1QixFQUFFLEVBQUUsQ0FBQyxDQUFDO3dCQUV6RSxJQUFJLGlCQUFpQixLQUFLLE1BQU0sSUFBSSxpQkFBaUIsS0FBSyxRQUFROzRCQUNoRSxNQUFNLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQzt3QkFDbEQsSUFBSSxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLE1BQU0sS0FBSyxDQUFDOzRCQUMxQyxNQUFNLEtBQUssQ0FBQyxpREFBaUQsQ0FBQyxDQUFDO3dCQUNqRSxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxJQUFJLENBQUM7NEJBQ2xFLE1BQU0sS0FBSyxDQUFDLGtDQUFrQyxDQUFDLENBQUM7d0JBRWxELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsaUJBQXNDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7cUJBQ2hGOzt3QkFBTSxNQUFNLEtBQUssQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQztvQkFFckUsTUFBTTtnQkFDUjtvQkFDRSxNQUFNLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQzthQUNuRDtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUM7UUFDbEQsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDakQsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7Z0JBQ2pELE1BQU0sS0FBSyxDQUFDLHdEQUF3RCxDQUFDLENBQUM7YUFDdkU7WUFFRCxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDN0IsT0FBTztTQUNSO1FBRUQsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksVUFBVSxLQUFLLEtBQUssRUFBRTtZQUMzRSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUMxQjtRQUVELElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNuQyxDQUFDO0lBRU8scUJBQXFCLENBQUMsSUFBYztRQUMxQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDakMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0QixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFTyxzQkFBc0IsQ0FBQyxJQUF3QjtRQUNyRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFNUIsSUFBSSxJQUFJLENBQUMsbUJBQW1CLEVBQUU7WUFDNUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsS0FBSyxJQUFJLENBQUMsbUJBQW1CLE1BQU0sQ0FBQyxDQUFDO1lBQ3pELE9BQU87U0FDUjtRQUVELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO1FBRXZELElBQUksbUJBQW1CLENBQUMsVUFBVSxDQUFDLEtBQUssTUFBTSxFQUFFO1lBQzlDLElBQ0UsSUFBSSxDQUFDLGFBQWEsRUFBRTtnQkFDcEIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQztnQkFDbkUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxFQUFFLE9BQU8sRUFBRSxLQUFLLFNBQVMsRUFDeEU7Z0JBQ0EsTUFBTSxLQUFLLENBQ1Qsa0ZBQWtGLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsQ0FDaEgsQ0FBQzthQUNIO1lBQ0QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDOUIsT0FBTztTQUNSO1FBRUQsSUFBSSxDQUFDLFFBQVEsR0FBRyxVQUFVLENBQUM7UUFFM0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFHLENBQUMsQ0FBQztRQUV4QyxjQUFjLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFaEQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQztRQUVoRSxJQUFJLENBQUMsUUFBUSxHQUFHLFNBQVMsQ0FBQztJQUM1QixDQUFDO0lBRU8sV0FBVyxDQUFDLElBQWEsRUFBRSxZQUFvQjtRQUNyRCxJQUFJLFlBQVksS0FBSyxFQUFFLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFFLENBQUMsSUFBSSxLQUFLLE1BQU07WUFBRSxPQUFPO1FBQzFGLE1BQU0sV0FBVyxHQUFHLG1CQUFtQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUV2RCxNQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUV2RSxJQUFJLFdBQVcsS0FBSyxRQUFRLElBQUksV0FBVyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUNoRSxJQUFJLENBQUMsU0FBUyxDQUNaLElBQUksRUFDSixVQUFVLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQ3pDLElBQUksRUFDSixLQUFLLEVBQ0wsS0FBSyxFQUNMLEtBQUssRUFDTCxPQUFPLFlBQVksR0FBRyxDQUFDLEVBQUUsRUFDekIsR0FBRyxFQUNILE1BQU0sRUFDTixZQUFZLENBQ2IsQ0FBQztZQUVGLE9BQU87U0FDUjtRQUVELElBQUksWUFBWSxHQUFHLFNBQVMsRUFBRTtZQUM1QixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsU0FBUyxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxZQUFZLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUV0RixPQUFPO1NBQ1I7UUFFRCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxVQUFVLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDdEUsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLE9BQU8sWUFBWSxFQUFFLEVBQUUsQ0FBQztJQUNoRSxDQUFDO0lBRU8seUJBQXlCLENBQUMsRUFBYztRQUM5QyxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQzlCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ3ZELE1BQU0sY0FBYyxHQUFHLElBQUksS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLHNCQUFzQixDQUFxQixDQUFDO1FBQ3JGLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDbEMsRUFBRSxFQUFFLENBQUM7UUFDTCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQzNCLElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxRQUFRLEdBQUcsV0FBVyxDQUFDO1FBQzVCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLE9BQU8sQ0FBQztRQUN6QyxJQUFJLENBQUMsc0JBQXNCLEdBQUcsY0FBYyxDQUFDO1FBQzdDLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVPLG9CQUFvQixDQUFDLElBQWE7UUFDeEMsT0FBTyxJQUFJLENBQUMseUJBQXlCLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ3RFLENBQUM7SUFFTyxrQkFBa0IsQ0FBQyxJQUFhO1FBQ3RDLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGdCQUFnQixDQUFDLEVBQUU7WUFDL0MsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUVELElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHVCQUF1QixDQUFDLEVBQUU7WUFDdEQsT0FBTyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUM7U0FDdEQ7UUFFRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFJTyxVQUFVLENBQUMsSUFBYTtRQUM5QixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUV2QyxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsRUFBRTtZQUM3QyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUUsS0FBSyxNQUFNLENBQUMsY0FBYyxFQUFFLEVBQUUsUUFBUSxFQUFFO2dCQUFFLE9BQU8sS0FBSyxDQUFDO1NBQzNFO1FBQ0QsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsdUJBQXVCLENBQUM7WUFBRSxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDekYsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsbUJBQW1CLENBQUM7WUFBRSxPQUFPLEtBQUssQ0FBQztRQUNuRSxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUM7WUFBRSxPQUFPLEtBQUssQ0FBQztRQUVyRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFTyx1QkFBdUIsQ0FBQyxJQUF5QixFQUFFLG1CQUFtQixHQUFHLEtBQUs7UUFDcEYsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2hDLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNsQyxJQUFJLFlBQVksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBRWpDLElBQUksSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUMsT0FBTyxFQUFFLEtBQUssR0FBRyxFQUFFO1lBQzdDLFlBQVksR0FBRyxTQUFTLENBQUM7WUFDekIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO1lBRTVCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUNyRCxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztZQUV6QixJQUFJLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsRUFBRTtnQkFDN0MsTUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUNoQyxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBQ2hFLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUV4RCxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUM1QixJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUU7b0JBQ3pCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO2lCQUM1QjtnQkFFRCxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDO2dCQUNoRCxJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssSUFBSSxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRTtvQkFDbkUsTUFBTSxLQUFLLENBQ1QsdUhBQXVILENBQ3hILENBQUM7aUJBQ0g7Z0JBQ0QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsY0FBYyxNQUFNLENBQUMsS0FBSyxPQUFPLElBQUksS0FBSyxNQUFNLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQzthQUNwRjtpQkFBTSxJQUFJLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx1QkFBdUIsQ0FBQyxFQUFFO2dCQUNqRSxJQUFJLENBQUMsc0JBQXNCLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQyxDQUFDO2dCQUNqRCxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUU7b0JBQ3pCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLFFBQVEsZUFBZSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUM7aUJBQ2hFO2FBQ0Y7aUJBQU0sSUFBSSxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUMsRUFBRTtnQkFDbEUsTUFBTSxjQUFjLEdBQUcsUUFBUTtxQkFDNUIsYUFBYSxFQUFFO29CQUNoQixFQUFFLE9BQU8sRUFBRTtxQkFDVixPQUFPLEVBQUU7cUJBQ1QsS0FBSyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7Z0JBRTlDLElBQUksY0FBYyxFQUFFO29CQUNsQixJQUFJLENBQUMsbUJBQW1CLENBQUM7d0JBQ3ZCLElBQUksRUFBRSxRQUFRO3dCQUNkLE1BQU0sRUFBRSxLQUFLO3dCQUNiLFFBQVEsRUFBRSxTQUFTO3FCQUNwQixDQUFDLENBQUM7aUJBQ0o7O29CQUFNLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDLENBQUM7Z0JBRXhELElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRTtvQkFDekIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsUUFBUSxlQUFlLENBQUMsZUFBZSxFQUFFLENBQUMsQ0FBQztpQkFDaEU7YUFDRjtZQUVELElBQUksQ0FBQyxRQUFRLEdBQUcsWUFBWSxDQUFDO1lBQzdCLE9BQU87U0FDUjtRQUVELElBQUksUUFBUSxHQUFHLElBQUk7YUFDaEIsZ0JBQWdCLEVBQUU7YUFDbEIsT0FBTyxFQUFFO2FBQ1QsT0FBTyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUM7YUFDcEIsT0FBTyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUM7YUFDcEIsT0FBTyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUM7YUFDcEIsT0FBTyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUM7YUFDcEIsT0FBTyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztRQUV4QixJQUFJLFdBQVcsR0FBRyxLQUFLLENBQUM7UUFFeEIsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUMvQyxJQUFJLG1CQUFtQixLQUFLLEtBQUssRUFBRTtnQkFDakMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUU1QixNQUFNLGFBQWEsR0FBRyxRQUFRO3FCQUMzQixhQUFhLEVBQUU7b0JBQ2hCLEVBQUUsT0FBTyxFQUFFO3FCQUNWLE9BQU8sRUFBRTtxQkFDVCxLQUFLLENBQUMsMkNBQTJDLENBQUMsQ0FBQztnQkFFdEQsTUFBTSxXQUFXLEdBQ2YsUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHVCQUF1QixDQUFDO29CQUN0RCxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUMsQ0FBQztnQkFFMUQsSUFBSSxDQUFDLGFBQWEsSUFBSSxXQUFXLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsYUFBYSxFQUFHLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxJQUFJLEtBQUssTUFBTSxFQUFFO29CQUMxRyxJQUFJLENBQUMsc0JBQXNCLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO29CQUM1QyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUU7d0JBQ3pCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLFFBQVEsZUFBZSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUM7d0JBQ2hFLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztxQkFDdkQ7b0JBQ0QsT0FBTztpQkFDUjtnQkFFRCxXQUFXLEdBQUcsSUFBSSxDQUFDO2FBQ3BCO1lBQ0QsUUFBUSxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1NBQ3RDO1FBRUQsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDbkMsSUFBSSxDQUFDLHdCQUF3QixDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3BDLE9BQU87U0FDUjtRQUVELE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN2RCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDckQsTUFBTSxXQUFXLEdBQUcsbUJBQW1CLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDbEQsTUFBTSxZQUFZLEdBQUcsbUJBQW1CLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFcEQsSUFDRSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUM7WUFDcEIsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztZQUMxQixXQUFXLEtBQUssUUFBUTtZQUN4QixDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLElBQUksUUFBUSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUN0RDtZQUNBLE1BQU0sS0FBSyxDQUNULDJHQUEyRyxDQUM1RyxDQUFDO1NBQ0g7UUFFRCxNQUFNLFFBQVEsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRXBGLElBQUksQ0FBQyxRQUFRLElBQUksV0FBVyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLFlBQVksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDdkYsTUFBTSxLQUFLLENBQUMsNENBQTRDLENBQUMsQ0FBQztTQUMzRDtRQUVELElBQUksUUFBUSxDQUFDLE9BQU8sRUFBRSxDQUFDLGVBQWUsRUFBRSxFQUFFO1lBQ3hDLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDLENBQUM7U0FDekQ7O1lBQU0sSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUVsQyxJQUFJLFNBQVMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxlQUFlLEVBQUUsRUFBRTtZQUN6QyxJQUFJLENBQUMsNkJBQTZCLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1NBQ3pEOztZQUFNLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFbkMsSUFDRSxRQUFRLEtBQUssR0FBRztZQUNoQixDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUM7Z0JBQ2hCLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyxhQUFhLElBQUksVUFBVSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFDakc7WUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFLFFBQVEsRUFBRSxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDOUQsSUFBSSxXQUFXO2dCQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDNUMsT0FBTztTQUNSO1FBRUQsSUFBSSxRQUFRLEtBQUssS0FBSyxJQUFJLFdBQVcsS0FBSyxRQUFRLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDOUUsTUFBTSxJQUFJLEtBQUssQ0FBQyx5REFBeUQsV0FBVyxRQUFRLFlBQVksRUFBRSxDQUFDLENBQUM7U0FDN0c7UUFFRCxJQUNFLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxXQUFXLEtBQUssUUFBUSxDQUFDO1lBQ3ZELENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQztZQUNwQixDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUM7WUFDeEIsQ0FBQyxRQUFRLEtBQUssSUFBSSxJQUFJLFFBQVEsS0FBSyxJQUFJLElBQUksUUFBUSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsSUFBSSxRQUFRLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQ2hHO1lBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxRQUFRLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7U0FDakU7YUFBTSxJQUFJLFFBQVEsSUFBSSxXQUFXLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQ3BHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLEVBQUUsSUFBSSxRQUFRLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFVBQVUsV0FBVyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1NBQ3JHO2FBQU0sSUFBSSxRQUFRLElBQUksV0FBVyxLQUFLLFFBQVEsRUFBRTtZQUMvQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFLElBQUksUUFBUSxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7U0FDOUQ7YUFBTTtZQUNMLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLEVBQUUsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1NBQ3hEO1FBRUQsSUFBSSxRQUFRLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxJQUFJLFdBQVcsS0FBSyxRQUFRLEVBQUU7WUFDdkcsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFVBQVUsV0FBVyxFQUFFLEVBQUUsQ0FBQztTQUNqRTtRQUVELElBQUksV0FBVyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsSUFBSSxZQUFZLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQ3pFLGNBQWMsQ0FDWixFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFdBQVcsQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQzFELEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsWUFBWSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FDNUQsQ0FBQztZQUNGLElBQUksUUFBUTtnQkFBRSxJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsVUFBVSxXQUFXLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7U0FDdkc7YUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBRSxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxDQUFDLGVBQWUsRUFBRSxFQUFFO1lBQzFGLGNBQWMsQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDLENBQUM7U0FDckM7UUFDRCxJQUFJLFdBQVcsRUFBRTtZQUNmLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7Z0JBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLFNBQVMsZUFBZSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUM7WUFDbkcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUMzQixJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDO2dCQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLFFBQVEsZUFBZSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUM7WUFDM0YsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1NBQ3ZEO1FBRUQsSUFBSSxRQUFRLEtBQUssSUFBSSxJQUFJLFFBQVEsS0FBSyxJQUFJLElBQUksUUFBUSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsSUFBSSxRQUFRLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ2xHLElBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQztTQUNoRDtJQUNILENBQUM7SUFFTyx3QkFBd0IsQ0FBQyxJQUF5QjtRQUN4RCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBQ2pDLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7UUFFM0IsSUFBSSxLQUFhLENBQUM7UUFFbEIsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxPQUFPLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDOUMsS0FBSyxHQUFHLFlBQVksSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ3BDLElBQUksQ0FBQyxRQUFRLElBQUksQ0FBQyxDQUFDO1lBRW5CLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDOUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsRUFBRSxNQUFNLEtBQUssRUFBRSxDQUFDLENBQUM7U0FDdkQ7YUFBTSxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLE9BQU8sRUFBRSxLQUFLLElBQUksRUFBRTtZQUNyRCxLQUFLLEdBQUcsV0FBVyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDbEMsSUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUM7WUFFbEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUM5QyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFLE9BQU8sS0FBSyxFQUFFLENBQUMsQ0FBQztTQUN4RDtRQUVELElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFDbEMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsRUFBRSxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDeEYsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsRUFBRSxHQUFHLEtBQU0sR0FBRyxDQUFDLENBQUM7UUFDckQsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7SUFDdkIsQ0FBQztJQUVPLGlCQUFpQixDQUFDLElBQW1CO1FBQzNDLHdEQUF3RDtRQUN4RCxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUUsS0FBSyxTQUFTLEVBQUU7WUFDaEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxDQUFDO1lBQ2xELE9BQU87U0FDUjtRQUVELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUU1QixJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUUsRUFBRTtZQUMxQixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxTQUFTLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxHQUFHLEVBQUUsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzVFLE9BQU87U0FDUjtRQUVELElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRSxFQUFFO1lBQzFCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sSUFBSSxDQUFDLHNCQUFzQixFQUFFLEVBQUUsRUFBRSxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDMUUsT0FBTztTQUNSO1FBRUQsMEJBQTBCO1FBQzFCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRTdDLE1BQU0sT0FBTyxHQUFHLE9BQU87YUFDcEIsWUFBWSxFQUFFO2FBQ2QsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7YUFDdkIsUUFBUSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUU1Qyx1REFBdUQ7UUFDdkQsTUFBTSxVQUFVLEdBQUcsT0FBTzthQUN2QixZQUFZLEVBQUU7YUFDZCxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQzthQUN2QixRQUFRLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBRS9DLDhGQUE4RjtRQUM5RixNQUFNLGVBQWUsR0FBRyxPQUFPLENBQUMsU0FBUyxFQUFFLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUV2RixJQUFJLENBQUMsT0FBTyxJQUFJLENBQUMsZUFBZSxJQUFJLENBQUMsVUFBVSxFQUFFO1lBQy9DLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsbUJBQW1CLENBQUM7Z0JBQUUsTUFBTSxLQUFLLEVBQUUsQ0FBQztZQUN0RSxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLENBQUM7WUFDbEQsT0FBTztTQUNSO1FBRUQsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRXJFLElBQUksY0FBYyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ3ZDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxJQUFJLEVBQUUsY0FBYyxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztTQUNyRTtJQUNILENBQUM7SUFFTyxvQkFBb0IsQ0FBQyxJQUFzQjtRQUNqRCxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtZQUN4QyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3RCLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO0lBQ25FLENBQUM7SUFFTyxZQUFZLENBQUMsSUFBYSxFQUFFLFlBQW9CO1FBQ3RELE1BQU0sRUFBRSxRQUFRLEVBQUUsR0FBRyxJQUFJLENBQUM7UUFFMUIsSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDckIsSUFBSSxDQUFDLFNBQVMsQ0FDWixJQUFJLEVBQ0osVUFBVSxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxFQUFFLEVBQ3JDLFFBQVEsRUFDUixLQUFLLEVBQ0wsV0FBVyxZQUFZLElBQUksRUFDM0IsU0FBUyxFQUNULEtBQUssRUFDTCxRQUFRLEVBQ1IsYUFBYSxZQUFZLEVBQUUsQ0FDNUIsQ0FBQztZQUNGLE9BQU87U0FDUjtRQUVELE1BQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxRQUFRLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFFL0UsSUFBSSxTQUFTLEdBQUcsWUFBWSxFQUFFO1lBQzVCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLGFBQWEsWUFBWSxFQUFFLENBQUMsQ0FBQztTQUNuRDthQUFNLElBQUksU0FBUyxHQUFHLFlBQVksRUFBRTtZQUNuQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxVQUFVLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxHQUFHLFNBQVMsQ0FBQyxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7U0FDbkY7SUFDSCxDQUFDO0lBRU8sZUFBZSxDQUFDLElBQXdDO1FBQzlELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUVsQyxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxlQUFlLEVBQUUsRUFBRTtZQUNwQyxJQUFJLENBQUMsNkJBQTZCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztZQUMxRixPQUFPO1NBQ1I7UUFFRCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQ25DLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFHLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztRQUNoRSxNQUFNLEVBQUUsUUFBUSxFQUFFLEdBQUcsSUFBSSxDQUFDO1FBRTFCLE1BQU0sT0FBTyxHQUFHLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRTlDLElBQUksU0FBUyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUMvQixNQUFNLFdBQVcsR0FBRyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDMUUsSUFBSSxXQUFXLEtBQUssT0FBTyxJQUFJLFdBQVcsS0FBSyxLQUFLLEVBQUU7Z0JBQ3BELE1BQU0sSUFBSSxLQUFLLENBQUMsZUFBZSxXQUFXLE9BQU8sT0FBTyxFQUFFLENBQUMsQ0FBQzthQUM3RDtZQUVELElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDdkIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLGdCQUFnQixFQUFFLE9BQU8sT0FBTyxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDdEUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLGtCQUFrQixJQUFJLENBQUMsT0FBTyxFQUFFLE9BQU8sT0FBTyxFQUFFLENBQUMsQ0FBQztZQUNoRixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztZQUN6QixPQUFPO1NBQ1I7UUFFRCxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsRUFBRTtZQUM1QyxNQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUNyRCxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7WUFDbEMsSUFBSSxHQUFHLENBQUMsTUFBTSxHQUFHLEtBQUs7Z0JBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQywrQkFBK0IsT0FBTyxFQUFFLENBQUMsQ0FBQztZQUNsRixNQUFNLFFBQVEsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQztZQUNwQyxNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUM3QyxNQUFNLFNBQVMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUM5QyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxVQUFVLFNBQVMsUUFBUSxHQUFHLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQztZQUM3RCxPQUFPO1NBQ1I7UUFFRCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDO1FBRXZDLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsRUFBRTtZQUNqQyxNQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUN6RCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztTQUNwQztRQUVELElBQUksbUJBQW1CLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEtBQUssRUFBRTtZQUNoRCxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztZQUN6QixPQUFPO1NBQ1I7UUFFRCxJQUNFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLENBQUM7WUFDOUQsT0FBTyxLQUFLLG1CQUFtQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsRUFDOUM7WUFDQSxJQUFJLFVBQVUsQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUMxQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRTtvQkFDakMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7b0JBQzdCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO29CQUMzQixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2lCQUMzQzs7b0JBQU0sSUFBSSxDQUFDLFFBQVEsR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDO2dCQUN4QyxPQUFPO2FBQ1I7WUFFRCx1QkFBdUI7WUFDdkIsSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsTUFBTSxDQUFDLEVBQUU7Z0JBQy9DLDZCQUE2QjtnQkFDN0IsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUM7b0JBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7Z0JBQzFELDRDQUE0QzthQUM3QztpQkFBTSxJQUFJLGFBQWEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLEVBQUU7Z0JBQ25FLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO2dCQUM3QixzQ0FBc0M7YUFDdkM7aUJBQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksYUFBYSxDQUFDLFFBQVEsQ0FBQyxFQUFFO2dCQUNuRSxNQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztnQkFDckQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBQ2hDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUM5QixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7Z0JBQ2xDLE9BQU87YUFDUjtZQUVELElBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxVQUFVLE9BQU8sRUFBRSxFQUFFLENBQUM7WUFDNUQsT0FBTztTQUNSO1FBRUQsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7UUFDekIsSUFBSSxDQUFDLFFBQVEsR0FBRyxZQUFZLENBQUM7SUFDL0IsQ0FBQztJQUVPLDBCQUEwQixDQUFDLElBQWdDO1FBQ2pFLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtZQUNuQyxNQUFNLFFBQVEsR0FBRyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDakMsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7WUFFMUYsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwQixJQUFJLENBQUMsUUFBUSxHQUFHLFNBQVMsQ0FBQztRQUM1QixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNLLHNCQUFzQixDQUM1QixJQUFhLEVBQ2IsSUFBWSxFQUNaLGlCQUE4QyxFQUM5QyxJQUFjLEVBQ2QsU0FBc0M7UUFFdEMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRztZQUMxQixTQUFTO1lBQ1QsaUJBQWlCO1lBQ2pCLElBQUk7WUFDSixVQUFVLEVBQUUsbUJBQW1CLENBQUMsSUFBSSxDQUFDO1NBQ3RDLENBQUM7UUFFRixxRkFBcUY7UUFDckYsTUFBTSxXQUFXLEdBQUcsY0FBYyxDQUFDLGlCQUFpQixDQUFFLENBQUM7UUFDdkQsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNuRCxNQUFNLElBQUksR0FBRyxpQkFBaUIsQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUUvQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQztZQUFFLE9BQU87UUFFdkQsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBRXJDLDBJQUEwSTtRQUMxSSxNQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDO1FBQ2xDLE1BQU0sT0FBTyxHQUFHLFFBQVEsQ0FBQyxTQUFTLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRWxELGtGQUFrRjtRQUNsRixJQUFJLE9BQU8sS0FBSyxTQUFTLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUMsZUFBZSxFQUFFLEVBQUU7WUFDakgsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztZQUVsQywrQ0FBK0M7WUFDL0MsSUFBSSxXQUFXLENBQUMsTUFBTSxFQUFFO2dCQUN0QixNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQzVELElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLFVBQVUsR0FBRyxRQUFRLFdBQVcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO2FBQ3BFO1lBRUQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUUxQixrRkFBa0Y7WUFDbEYsSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDckQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQzVDO1lBRUQsSUFBSSxXQUFXLENBQUMsTUFBTTtnQkFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztZQUV6RCxNQUFNLFlBQVksR0FBRyxnQkFBZ0IsSUFBSSxFQUFFLENBQUM7WUFFNUMsZ0NBQWdDO1lBQ2hDLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLGNBQWMsSUFBSSxDQUFDLFVBQVUsT0FBTyxZQUFZLEVBQUUsQ0FBQyxDQUFDO1lBQzNFLElBQUksQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLEdBQUc7Z0JBQ2xDLEtBQUssRUFBRSxJQUFJLENBQUMsVUFBVTtnQkFDdEIsSUFBSSxFQUFFLFNBQVMsQ0FBQyxNQUFNO2dCQUN0QixVQUFVLEVBQUUsUUFBUTthQUNyQixDQUFDO1lBQ0YsSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLENBQUM7WUFFckIsc0VBQXNFO1lBQ3RFLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsZUFBZSxHQUFHLFlBQVksQ0FBQztTQUMxRDtRQUVELDhGQUE4RjtRQUM5RixJQUFJLFdBQVcsQ0FBQyxJQUFJLEtBQUssT0FBTyxFQUFFO1lBQ2hDLE1BQU0sV0FBVyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNoQyxNQUFNLGdCQUFnQixHQUFHLG9CQUFvQixJQUFJLEVBQUUsQ0FBQztZQUVwRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBRWxDLGdDQUFnQztZQUNoQyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQzlCLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLGNBQWMsSUFBSSxDQUFDLFVBQVUsT0FBTyxnQkFBZ0IsRUFBRSxDQUFDLENBQUM7WUFDbkYsSUFBSSxDQUFDLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHO2dCQUN0QyxLQUFLLEVBQUUsSUFBSSxDQUFDLFVBQVU7Z0JBQ3RCLElBQUksRUFBRSxTQUFTLENBQUMsTUFBTTtnQkFDdEIsVUFBVSxFQUFFLFFBQVE7YUFDckIsQ0FBQztZQUNGLElBQUksQ0FBQyxVQUFVLElBQUksQ0FBQyxDQUFDO1lBRXJCLGtFQUFrRTtZQUNsRSxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLG1CQUFtQixHQUFHLGdCQUFnQixDQUFDO1NBQ2xFO0lBQ0gsQ0FBQztJQUVPLHlCQUF5QixDQUFDLElBQTRCO1FBQzVELElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLGVBQWUsRUFBRSxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxlQUFlLEVBQUU7WUFBRSxPQUFPO1FBRWpGLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUUxQyxJQUFJLElBQUksQ0FBQyxjQUFjLEVBQUUsRUFBRTtZQUN6QixNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUcsQ0FBQyxDQUFDO1lBQzFELE1BQU0scUJBQXFCLEdBQUcsbUJBQW1CLENBQUMsZUFBZSxDQUFDLENBQUM7WUFFbkUsSUFBSSxlQUFtQyxDQUFDO1lBRXhDLE1BQU0sT0FBTyxHQUFHLFdBQVcsQ0FBQyxlQUFlLENBQUMsQ0FBQztZQUU3QyxJQUNFLElBQUksQ0FBQyxjQUFjLEVBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUM7Z0JBQ3ZELENBQUMsT0FBTyxJQUFJLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLEVBQy9EO2dCQUNBLGVBQWUsR0FBRyxJQUFJLENBQUMsY0FBYyxFQUFHLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBRW5ELElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEdBQUc7b0JBQzFCLFlBQVksRUFBRSxlQUFlO29CQUM3QixJQUFJLEVBQUUsZUFBZTtvQkFDckIsVUFBVSxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxJQUFJLG1CQUFtQixDQUFDLGVBQWUsQ0FBQztpQkFDbEcsQ0FBQztnQkFFRixPQUFPO2FBQ1I7WUFFRCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7WUFDbkMsSUFBSSxJQUFJLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsdUJBQXVCLENBQUMsSUFBSSxPQUFPLEVBQUU7Z0JBQ2xFLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQzlDLGVBQWUsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBRTNELDJEQUEyRDtnQkFDM0QsSUFBSSxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMscUJBQXFCLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxFQUFFO29CQUNuRixJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQzdCO2dCQUNELE1BQU0sU0FBUyxHQUFHLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7b0JBQ3pDLElBQUksQ0FBQyxDQUFDLHFCQUFxQixFQUFFLEVBQUUsT0FBTyxFQUFFLENBQUMsZUFBZSxFQUFFO3dCQUFFLE9BQU8sQ0FBQyxDQUFDLHFCQUFxQixFQUFHLENBQUM7b0JBRTlGLElBQUksQ0FBQyxDQUFDLHFCQUFxQixFQUFFLEVBQUUsT0FBTyxFQUFFLENBQUMsZUFBZSxFQUFFLEVBQUU7d0JBQzFELElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLHFCQUFxQixFQUFHLEVBQUUsT0FBTyxDQUFDLENBQUMscUJBQXFCLEVBQUcsQ0FBQyxPQUFPLEVBQUUsRUFBRSxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztxQkFDeEc7O3dCQUFNLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLHFCQUFxQixFQUFHLENBQUMsQ0FBQztvQkFFcEQsTUFBTSxPQUFPLEdBQUcsYUFBYSxDQUFDLEtBQUssSUFBSSxFQUFFLENBQUM7b0JBQzFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBSSxFQUFFLGNBQWMsSUFBSSxDQUFDLFVBQVUsaUJBQWlCLE9BQU8sRUFBRSxDQUFDLENBQUM7b0JBRWhHLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLEdBQUc7d0JBQzdCLEtBQUssRUFBRSxJQUFJLENBQUMsVUFBVTt3QkFDdEIsSUFBSSxFQUFFLFNBQVMsQ0FBQyxNQUFNO3dCQUN0QixVQUFVLEVBQUUsUUFBUTtxQkFDckIsQ0FBQztvQkFFRixJQUFJLENBQUMsVUFBVSxJQUFJLENBQUMsQ0FBQztvQkFFckIsT0FBTyxPQUFPLENBQUM7Z0JBQ2pCLENBQUMsQ0FBQyxDQUFDO2dCQUVILElBQUksZUFBZSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsRUFBRTtvQkFDdkMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsQ0FBQyxFQUFFO3dCQUNsRixNQUFNLElBQUksS0FBSyxDQUFDLDBCQUEwQixDQUFDLENBQUM7cUJBQzdDO29CQUVELElBQUksQ0FBQyxzQkFBc0IsQ0FDekIsSUFBSSxFQUNKLElBQUksRUFDSixXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxFQUFpQyxFQUM3RCxlQUFlLEVBQ2YsU0FBUyxDQUNWLENBQUM7aUJBQ0g7cUJBQU07b0JBQ0wsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRzt3QkFDMUIsU0FBUzt3QkFDVCxZQUFZLEVBQUUsZUFBZTt3QkFDN0IsSUFBSSxFQUFFLGVBQWU7d0JBQ3JCLFVBQVUsRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsT0FBTyxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsSUFBSSxtQkFBbUIsQ0FBQyxlQUFlLENBQUM7cUJBQ2xHLENBQUM7aUJBQ0g7Z0JBRUQsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFO29CQUFFLGNBQWMsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDdkcsT0FBTzthQUNSO1lBRUQsTUFBTSxjQUFjLEdBQUcsSUFBSTtnQkFDekIsRUFBRSxhQUFhLEVBQUU7Z0JBQ2pCLEVBQUUsT0FBTyxFQUFFO2lCQUNWLE9BQU8sRUFBRTtpQkFDVCxLQUFLLENBQUMsbUNBQW1DLENBQUMsQ0FBQztZQUU5QyxJQUFJLElBQUksRUFBRSxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsQ0FBQyxJQUFJLGNBQWMsSUFBSSxPQUFPLEVBQUU7Z0JBQ3JGLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxlQUFlLENBQUMsQ0FBQztnQkFFL0QsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFO29CQUNwQixjQUFjLENBQ1osSUFBSSxDQUFDLFlBQVksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFFLENBQUMsQ0FBQyxTQUFTLEVBQ2xELElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQ2hELENBQUM7Z0JBQ0osT0FBTzthQUNSO1lBRUQsSUFBSSxJQUFJLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUMsSUFBSSxPQUFPLEVBQUU7Z0JBQ25FLGVBQWUsR0FBRyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBRWpELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQztnQkFDN0QsSUFBSSxPQUFPLEVBQUU7b0JBQ1gsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7b0JBRXRGLElBQUksZUFBZSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsRUFBRTt3QkFDdkMsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO3dCQUN0QyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDOzRCQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsMEJBQTBCLENBQUMsQ0FBQzt3QkFFMUcsSUFBSSxDQUFDLHNCQUFzQixDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLGVBQWUsRUFBRTs0QkFDakUsRUFBRSxDQUFDLGlCQUFpQixDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBcUIsQ0FBQzt5QkFDL0UsQ0FBQyxDQUFDO3FCQUNKO3lCQUFNO3dCQUNMLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEdBQUc7NEJBQzFCLFNBQVMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQXFCLENBQUMsQ0FBQzs0QkFDM0YsWUFBWSxFQUFFLGVBQWU7NEJBQzdCLElBQUksRUFBRSxlQUFlOzRCQUNyQixVQUFVLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLElBQUksbUJBQW1CLENBQUMsZUFBZSxDQUFDO3lCQUNsRyxDQUFDO3FCQUNIO29CQUVELElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTt3QkFBRSxjQUFjLENBQUMsZUFBZSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztvQkFDekcsT0FBTztpQkFDUjthQUNGO1lBRUQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzVCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFHLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO1lBRTlGLElBQUksSUFBSSxFQUFFLE9BQU8sRUFBRSxDQUFDLGVBQWUsRUFBRSxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0JBQ3RELElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQ3pEO2lCQUFNO2dCQUNMLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO2dCQUNyQixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUssQ0FBQyxDQUFDO2dCQUN4QixJQUFJLElBQUksRUFBRTtvQkFDUixJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxLQUFLLE1BQU0sSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLEVBQUU7d0JBQzVFLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztxQkFDMUM7b0JBQ0QsY0FBYyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUM7aUJBQ3JDO2FBQ0Y7WUFFRCxNQUFNLElBQUksR0FBRyxJQUFJLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQztZQUVuQyxJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFLEVBQUUsT0FBTyxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsSUFBSSxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUVoRyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztZQUN2QyxJQUFJLEtBQUssR0FBRyxLQUFLLENBQUM7WUFDbEIsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsdUJBQXVCLENBQUMsRUFBRTtnQkFDeEQsS0FBSyxHQUFHLE1BQU0sQ0FBQyxRQUFRLEVBQUUsS0FBSyxFQUFFLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQzthQUNoRDtZQUVELElBQUksS0FBSyxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssTUFBTSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLHNCQUFzQixDQUFDLEVBQUU7Z0JBQzVFLElBQUksQ0FBQyxJQUFJLEdBQUcsVUFBVSxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7Z0JBQ2xDLFVBQVUsR0FBRyxVQUFVLFVBQVUsRUFBRSxDQUFDO2FBQ3JDO1lBRUQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRztnQkFDMUIsS0FBSyxFQUFFLElBQUksQ0FBQyxVQUFVO2dCQUN0QixJQUFJO2dCQUNKLFVBQVU7YUFDWCxDQUFDO1lBRUYsSUFBSSxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQUUsT0FBTztZQUVuRSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxjQUFjLElBQUksQ0FBQyxVQUFVLE9BQU8sSUFBSSxLQUFLLFVBQVUsRUFBRSxDQUFDLENBQUM7WUFFL0UsSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLENBQUM7U0FDdEI7YUFBTTtZQUNMLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFO2dCQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsMENBQTBDLENBQUMsQ0FBQztZQUVyRixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxHQUFHO2dCQUMxQixLQUFLLEVBQUUsSUFBSSxDQUFDLFVBQVU7Z0JBQ3RCLElBQUksRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFDckQsVUFBVSxFQUFFLElBQUksQ0FBQyxXQUFXLEVBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQzthQUM5RCxDQUFDO1lBRUYsSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLENBQUM7U0FDdEI7SUFDSCxDQUFDO0lBRU8sMEJBQTBCLENBQUMsSUFBNEI7UUFDN0QsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRU8sMEJBQTBCLENBQUMsSUFBYztRQUMvQyxPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssY0FBYyxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDeEUsQ0FBQztJQUVPLGtCQUFrQixDQUFDLElBQWE7UUFDdEMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzVCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFdkIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksbUJBQW1CLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLE1BQU0sRUFBRTtZQUM5RSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDeEM7SUFDSCxDQUFDO0lBRU8sa0JBQWtCLENBQUMsSUFBb0IsRUFBRSxjQUFzQixDQUFDLEVBQUUsUUFBUSxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUM7UUFDdEcsSUFBSSxXQUFtQixDQUFDO1FBRXhCLE1BQU0sTUFBTSxHQUFHLE1BQU0sUUFBUSxFQUFFLENBQUM7UUFFaEMsSUFBSSxXQUFXLEtBQUssQ0FBQyxFQUFFO1lBQ3JCLFdBQVcsR0FBRyxNQUFNLENBQUM7WUFDckIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsTUFBTSxXQUFXLFlBQVksQ0FBQyxDQUFDO1NBQ3BEO2FBQU07WUFDTCxXQUFXLEdBQUcsR0FBRyxNQUFNLFVBQVUsV0FBVyxFQUFFLENBQUM7WUFDL0MsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsR0FBRyxXQUFXLGFBQWEsQ0FBQyxDQUFDO1NBQ2xEO1FBRUQsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDO1FBRTlDLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBRTlDLElBQUksYUFBYSxLQUFLLFNBQVMsRUFBRTtZQUMvQixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxNQUFNLE1BQU0sTUFBTSxDQUFDLENBQUM7WUFDeEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsTUFBTSxXQUFXLGFBQWEsQ0FBQyxDQUFDO1lBQ3BELElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUMsQ0FBQztTQUMzQzthQUFNLElBQUksYUFBYSxFQUFFLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxFQUFFO1lBQzNELElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLE1BQU0sTUFBTSxVQUFVLFdBQVcsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQ3ZFLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLE1BQU0sV0FBVyxhQUFhLENBQUMsQ0FBQztZQUNwRCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLENBQUM7WUFDMUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsS0FBSyxNQUFNLE1BQU0sQ0FBQyxDQUFDO1lBQ3ZDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLEVBQUUsV0FBVyxHQUFHLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztTQUNuRTthQUFNO1lBQ0wsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsTUFBTSxNQUFNLE9BQU8sQ0FBQyxDQUFDO1lBQ3pDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLE1BQU0sV0FBVyxhQUFhLENBQUMsQ0FBQztZQUNwRCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLENBQUM7WUFDMUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsS0FBSyxNQUFNLE1BQU0sQ0FBQyxDQUFDO1lBQ3ZDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEdBQUcsTUFBTSxRQUFRLENBQUMsQ0FBQztZQUN2QyxJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1NBQ2pDO1FBRUQsSUFBSSxXQUFXLEtBQUssQ0FBQyxFQUFFO1lBQ3JCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEdBQUcsTUFBTSxPQUFPLENBQUMsQ0FBQztTQUN2QztJQUNILENBQUM7SUFFTyxzQkFBc0IsQ0FBQyxJQUE4QjtRQUMzRCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDO1FBQ3BDLFFBQVEsSUFBSSxDQUFDLGdCQUFnQixFQUFFLEVBQUU7WUFDL0IsS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLGdCQUFnQjtnQkFDakMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUM7Z0JBQ3RDLE1BQU07WUFDUixLQUFLLEVBQUUsQ0FBQyxVQUFVLENBQUMsVUFBVTtnQkFDM0IsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLGFBQWEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO29CQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDOztvQkFDL0YsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBQzVDLE1BQU07WUFDUjtnQkFDRSxNQUFNLElBQUksS0FBSyxDQUFDLDhCQUE4QixFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQzNGO0lBQ0gsQ0FBQztJQUVPLHlCQUF5QixDQUFDLElBQTRCO1FBQzVELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUNuQyxJQUFJLElBQUksS0FBSyxTQUFTO1lBQUUsTUFBTSxLQUFLLEVBQUUsQ0FBQztRQUV0QyxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLEVBQUUsS0FBSyxnQkFBZ0IsRUFBRTtZQUNyRCxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQztnQkFBRSxNQUFNLEtBQUssQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO1lBRS9GLElBQUksQ0FBQyxjQUFjLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUUxRCxJQUFJLElBQUksQ0FBQyxjQUFjLEdBQUcsQ0FBQztnQkFBRSxNQUFNLEtBQUssQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO1lBQ3hFLE9BQU87U0FDUjtRQUVELElBQ0UsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQztZQUN6QyxDQUFDLFFBQVEsRUFBRSxnQkFBZ0IsRUFBRSxlQUFlLEVBQUUsUUFBUSxFQUFFLGdCQUFnQixFQUFFLGVBQWUsQ0FBQyxDQUFDLFFBQVEsQ0FDakcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUMvQixFQUNEO1lBQ0EsSUFBSSxJQUFJLENBQUMsY0FBYyxLQUFLLE1BQU0sRUFBRTtnQkFDbEMsTUFBTSxLQUFLLENBQUMsa0RBQWtELENBQUMsQ0FBQzthQUNqRTtZQUVELElBQUksS0FBa0IsQ0FBQztZQUN2QixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDN0MsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLGlCQUFpQixFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFnQixDQUFDO1lBQ2pILE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBRXpDLElBQUksUUFBUSxLQUFLLFNBQVMsRUFBRTtnQkFDMUIsTUFBTSxJQUFJLEtBQUssQ0FBQyx5REFBeUQsQ0FBQyxDQUFDO2FBQzVFO1lBRUQsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUN6QixJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQztvQkFBRSxNQUFNLElBQUksS0FBSyxDQUFDLGlDQUFpQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO2dCQUNyRixLQUFLLEdBQUc7b0JBQ04sSUFBSSxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUU7b0JBQ3BCLElBQUk7b0JBQ0osT0FBTyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO29CQUNoRCxTQUFTLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7b0JBQ2xELFFBQVEsRUFBRSxJQUFJO2lCQUNmLENBQUM7YUFDSDtpQkFBTTtnQkFDTCxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQztvQkFBRSxNQUFNLElBQUksS0FBSyxDQUFDLGdDQUFnQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO2dCQUVwRixLQUFLLEdBQUc7b0JBQ04sSUFBSSxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUU7b0JBQ3BCLElBQUk7b0JBQ0osT0FBTyxFQUFFLFNBQVMsQ0FBQyxLQUFLO29CQUN4QixTQUFTLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7b0JBQ2xELFFBQVEsRUFBRSxJQUFJO2lCQUNmLENBQUM7YUFDSDtZQUVELElBQUksS0FBSyxDQUFDLElBQUksS0FBSyxLQUFLLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLEVBQUU7Z0JBQy9ELEtBQUssQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO2FBQzFCO1lBRUQsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQ3JDLElBQUksUUFBUSxDQUFDLENBQUMsQ0FBQyxLQUFLLFNBQVMsRUFBRTtnQkFDN0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx1QkFBdUIsQ0FBQztvQkFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7Z0JBRTNHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtvQkFDeEMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQzt3QkFBRSxNQUFNLElBQUksS0FBSyxFQUFFLENBQUM7b0JBQ25FLE1BQU0sSUFBSSxHQUFHLENBQUMsQ0FBQyxXQUFXLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQztvQkFDeEMsTUFBTSxRQUFRLEdBQUcsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDO29CQUVwQyxRQUFRLElBQUksRUFBRTt3QkFDWixLQUFLLEtBQUs7NEJBQ1IsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQztnQ0FBRSxNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsSUFBSSwrQkFBK0IsQ0FBQyxDQUFDOzRCQUNuRixJQUFJLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQztnQ0FBRSxNQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QixDQUFDLENBQUM7NEJBQ2xHLEtBQUssQ0FBQyxHQUFHLEdBQUcsUUFBUSxDQUFDLGNBQWMsRUFBRSxDQUFDOzRCQUN0QyxNQUFNO3dCQUNSLEtBQUssYUFBYTs0QkFDaEIsSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLEtBQUs7Z0NBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxHQUFHLElBQUksOEJBQThCLENBQUMsQ0FBQzs0QkFDakYsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQztnQ0FBRSxNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsSUFBSSxnQ0FBZ0MsQ0FBQyxDQUFDOzRCQUVuRyxLQUFLLENBQUMsV0FBVyxHQUFHLFFBQVMsQ0FBQyxPQUFPLEVBQUUsS0FBSyxNQUFNLENBQUM7NEJBQ25ELE1BQU07d0JBQ1IsS0FBSyxRQUFROzRCQUNYLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQztnQ0FBRSxNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsSUFBSSwrQkFBK0IsQ0FBQyxDQUFDOzRCQUNwRixJQUFJLENBQUMsUUFBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQztnQ0FBRSxNQUFNLElBQUksS0FBSyxDQUFDLCtCQUErQixDQUFDLENBQUM7NEJBQ3JHLEtBQUssQ0FBQyxNQUFNLEdBQUcsUUFBUSxDQUFDLGNBQWMsRUFBRSxDQUFDOzRCQUN6QyxNQUFNO3dCQUNSLEtBQUssU0FBUzs0QkFDWixJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUM7Z0NBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxHQUFHLElBQUksK0JBQStCLENBQUMsQ0FBQzs0QkFDcEYsSUFBSSxDQUFDLFFBQVMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUM7Z0NBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDOzRCQUN2RyxLQUFLLENBQUMsT0FBTyxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUMsY0FBYyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7NEJBQ3hELE1BQU07d0JBQ1IsS0FBSywwQkFBMEI7NEJBQzdCLElBQ0UsUUFBUSxFQUFFLFlBQVksQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXO2dDQUN6RCxRQUFRLEVBQUUsWUFBWSxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLFlBQVksRUFDMUQ7Z0NBQ0EsTUFBTSxJQUFJLEtBQUssQ0FBQyxrREFBa0QsQ0FBQyxDQUFDOzZCQUNyRTs0QkFDRCxLQUFLLENBQUMsd0JBQXdCLEdBQUcsUUFBUSxFQUFFLFlBQVksQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUM7NEJBQzNGLE1BQU07d0JBQ1I7NEJBQ0UsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQkFBb0IsSUFBSSxFQUFFLENBQUMsQ0FBQztxQkFDL0M7Z0JBQ0gsQ0FBQyxDQUFDLENBQUM7YUFDSjtZQUVELElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUU7Z0JBQ3ZDLEtBQUssQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO2FBQzFDO1lBRUQsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU87Z0JBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQywwQ0FBMEMsQ0FBQyxDQUFDO1lBRTlHLHlCQUF5QjtZQUN6QixJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLHdCQUF3QixLQUFLLElBQUksRUFBRTtnQkFDcEUsTUFBTSxjQUFjLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUU7b0JBQ3RFLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7b0JBQ3RDLHdEQUF3RDtvQkFDeEQsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLElBQUk7d0JBQUUsT0FBTyxLQUFLLENBQUM7b0JBRWxDLGtIQUFrSDtvQkFDbEgsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLFNBQVMsRUFBRTt3QkFDdkIsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sS0FBSyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztxQkFDaEc7b0JBRUQsT0FBTyxDQUNMLENBQUMsQ0FBQyxPQUFPLEtBQUssS0FBSyxDQUFDLE9BQU87d0JBQzNCLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQzt3QkFDN0IsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQ3BFLENBQUM7Z0JBQ0osQ0FBQyxDQUFDLENBQUM7Z0JBRUgsSUFBSSxjQUFjLEVBQUU7b0JBQ2xCLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxTQUFTO3dCQUM1QixNQUFNLEtBQUssQ0FDVCwrQkFBK0IsSUFBSTs2QkFDaEMsV0FBVyxFQUFFOzZCQUNiLE9BQU8sRUFBRSxzQ0FBc0MsY0FBYyxHQUFHLENBQ3BFLENBQUM7b0JBRUosTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUU7d0JBQ2pFLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7d0JBQ3RDLHdEQUF3RDt3QkFDeEQsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLElBQUk7NEJBQUUsT0FBTyxLQUFLLENBQUM7d0JBRWxDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxVQUFVLENBQUMsS0FBSyxDQUFDLE1BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEtBQUssS0FBSyxDQUFDLE1BQU0sQ0FBQztvQkFDdkUsQ0FBQyxDQUFDLENBQUM7b0JBRUgsSUFBSSxTQUFTLEVBQUU7d0JBQ2IsTUFBTSxLQUFLLENBQUMsbUJBQW1CLEtBQUssQ0FBQyxNQUFNLDhDQUE4QyxTQUFTLEdBQUcsQ0FBQyxDQUFDO3FCQUN4RztpQkFDRjtnQkFDRCx5QkFBeUI7YUFDMUI7aUJBQU0sSUFBSSxLQUFLLENBQUMsd0JBQXdCLEtBQUssSUFBSSxFQUFFO2dCQUNsRCw0RUFBNEU7Z0JBQzVFLE1BQU0sY0FBYyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFO29CQUN0RSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO29CQUN0Qyx3REFBd0Q7b0JBQ3hELElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxJQUFJO3dCQUFFLE9BQU8sS0FBSyxDQUFDO29CQUVsQyx5QkFBeUI7b0JBQ3pCLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxTQUFTO3dCQUFFLE9BQU8sS0FBSyxDQUFDO29CQUV0QyxPQUFPLENBQ0wsQ0FBQyxDQUFDLE1BQU0sS0FBSyxTQUFTO3dCQUN0QixDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQ3ZHLENBQUM7Z0JBQ0osQ0FBQyxDQUFDLENBQUM7Z0JBRUgsSUFBSSxjQUFjLEVBQUU7b0JBQ2xCLE1BQU0sS0FBSyxDQUNULElBQUksSUFBSTt5QkFDTCxXQUFXLEVBQUU7eUJBQ2IsT0FBTyxFQUFFLHlDQUF5QyxjQUFjLE9BQU8sY0FBYyw0QkFBNEIsSUFBSTt5QkFDckgsV0FBVyxFQUFFO3lCQUNiLE9BQU8sRUFBRSxrQ0FBa0MsQ0FDL0MsQ0FBQztpQkFDSDtnQkFFRCxNQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFDMUQsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUU7b0JBQ2pFLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7b0JBRXRDLHdEQUF3RDtvQkFDeEQsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLElBQUk7d0JBQUUsT0FBTyxLQUFLLENBQUM7b0JBRWxDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsS0FBSyxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7Z0JBQ3pFLENBQUMsQ0FBQyxDQUFDO2dCQUVILElBQUksU0FBUyxFQUFFO29CQUNiLE1BQU0sS0FBSyxDQUNULG9CQUFvQixJQUFJO3lCQUNyQixXQUFXLEVBQUU7eUJBQ2IsT0FBTyxFQUFFLDhDQUE4QyxTQUFTLGlEQUFpRCxDQUNySCxDQUFDO2lCQUNIO2FBQ0Y7WUFFRCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQztTQUN6RDthQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxJQUFJLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxPQUFPLEVBQUUsS0FBSyxhQUFhLEVBQUU7WUFDdkcsSUFBSSxJQUFJLENBQUMsY0FBYyxLQUFLLE1BQU0sRUFBRTtnQkFDbEMsTUFBTSxLQUFLLENBQUMsb0NBQW9DLENBQUMsQ0FBQzthQUNuRDtZQUVELE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBQzdDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEVBQUU7Z0JBQ3RELE1BQU0sS0FBSyxDQUFDLGtEQUFrRCxDQUFDLENBQUM7YUFDakU7WUFFRCxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHO2dCQUMxQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRTtnQkFDbEMsSUFBSSxFQUFFLEVBQUU7Z0JBQ1IsSUFBSSxFQUFFLElBQUk7cUJBQ1AsU0FBUyxFQUFFO3FCQUNYLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDO3FCQUM5QixJQUFJLENBQUMsRUFBRSxDQUFDO2dCQUNYLFlBQVksRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQzthQUMxRCxDQUFDO1lBRUYsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztZQUV4RCxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7Z0JBQzVDLE1BQU0sSUFBSSxHQUFHLENBQUM7cUJBQ1gsU0FBUyxFQUFFO3FCQUNYLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDO3FCQUM5QixJQUFJLEVBQUUsQ0FBQztnQkFFVixNQUFNLElBQUksR0FBRyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQ3pCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7Z0JBQzNDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBQ3hDLENBQUMsQ0FBQyxDQUFDO1NBQ0o7YUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsT0FBTyxFQUFFLEtBQUssYUFBYSxFQUFFO1lBQ3hHLElBQUksSUFBSSxDQUFDLGdCQUFnQixFQUFFLEVBQUUsTUFBTSxLQUFLLENBQUM7Z0JBQUUsTUFBTSxLQUFLLENBQUMsMENBQTBDLENBQUMsQ0FBQztZQUVuRyxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUUsRUFBRSxNQUFNLEtBQUssQ0FBQztnQkFBRSxNQUFNLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDO1lBRXpGLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDO2dCQUM5RCxNQUFNLEtBQUssQ0FBQywrQ0FBK0MsQ0FBQyxDQUFDO1lBRS9ELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztZQUNwRSxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDMUMsTUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUU1RCxJQUFJLElBQUksR0FBRyxDQUFDLElBQUksSUFBSSxHQUFHLEdBQUc7Z0JBQ3hCLE1BQU0sS0FBSyxDQUFDLDBGQUEwRixDQUFDLENBQUM7WUFFMUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxDQUFDO1NBQ3JEO2FBQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE9BQU8sRUFBRSxLQUFLLG9CQUFvQixFQUFFO1lBQy9HLElBQUksSUFBSSxDQUFDLGdCQUFnQixFQUFFLEVBQUUsTUFBTSxLQUFLLENBQUM7Z0JBQUUsTUFBTSxLQUFLLENBQUMsMENBQTBDLENBQUMsQ0FBQztZQUVuRyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7WUFDcEUsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBRTFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxDQUFDO1NBQy9DO2FBQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE9BQU8sRUFBRSxLQUFLLGFBQWEsRUFBRTtZQUN4RyxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFLE1BQU0sS0FBSyxDQUFDO2dCQUFFLE1BQU0sS0FBSyxDQUFDLDBDQUEwQyxDQUFDLENBQUM7WUFFbkcsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLEVBQUU7Z0JBQzFGLE1BQU0sS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7YUFDbkU7WUFFRCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxFQUFFLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQy9FLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztZQUVwRSw4REFBOEQ7WUFDOUQsTUFBTSxJQUFJLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLE1BQU0sQ0FBQztZQUV6RCxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLENBQUM7WUFDNUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRztnQkFDaEQsSUFBSTtnQkFDSixJQUFJO2dCQUNKLFFBQVEsRUFBRSxJQUFJO2FBQ2YsQ0FBQztTQUNIO2FBQU07WUFDTCxNQUFNLElBQUksS0FBSyxFQUFFLENBQUM7U0FDbkI7SUFDSCxDQUFDO0lBRU8sNEJBQTRCLENBQUMsSUFBYTtRQUNoRCxJQUFJLEtBQUssR0FBRyxFQUFFLENBQUM7UUFDZixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUN6QyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxFQUFFLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztZQUUvRSxNQUFNLENBQUMsZUFBZSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3JDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLG1CQUFtQixDQUFDLEVBQUU7b0JBQy9DLEtBQUssR0FBRyxJQUFJLENBQUMsNEJBQTRCLENBQUMsQ0FBQyxDQUFDLHFCQUFxQixFQUFFLENBQUMsQ0FBQztpQkFDdEU7WUFDSCxDQUFDLENBQUMsQ0FBQztTQUNKOztZQUFNLE9BQU8sSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFFL0MsSUFBSSxLQUFLLEtBQUssRUFBRTtZQUFFLE1BQU0sS0FBSyxFQUFFLENBQUM7UUFDaEMsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRU8sNkJBQTZCLENBQUMsSUFBYSxFQUFFLFFBQWtCO1FBQ3JFLE1BQU0sSUFBSSxHQUFHLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzNDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsZUFBZSxFQUFFO1lBQUUsTUFBTSxLQUFLLEVBQUUsQ0FBQztRQUVyRCxNQUFNLHNCQUFzQixHQUFHLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUV2RSxJQUFJLE1BQU0sQ0FBQyxzQkFBc0IsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLEVBQUU7WUFDbEYsTUFBTSxLQUFLLENBQUMsVUFBVSxJQUFJLENBQUMsT0FBTyxFQUFFLHdFQUF3RSxDQUFDLENBQUM7U0FDL0c7UUFFRCxJQUFJLElBQUksS0FBSyxRQUFRLEVBQUU7WUFDckIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN2QixPQUFPO1NBQ1I7UUFFRCxJQUFJLElBQUksS0FBSyxRQUFRLEVBQUU7WUFDckIsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLHNCQUFzQixDQUFDLENBQUM7WUFDN0MsSUFBSSxHQUFHLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUM3QixJQUFJLEdBQUcsQ0FBQyxNQUFNLEdBQUcsQ0FBQztnQkFBRSxHQUFHLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztZQUNwQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxVQUFVLEdBQUcsRUFBRSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQzNDLE9BQU87U0FDUjtRQUVELElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFO1lBQ2hDLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFFLENBQUM7WUFDbEMsTUFBTSxDQUFDLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUNqQyxNQUFNLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBRWpDLE1BQU0sV0FBVyxHQUFHLHNCQUFzQixDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7WUFFMUUsSUFBSSxXQUFXLEdBQUcsQ0FBQztnQkFDakIsTUFBTSxLQUFLLENBQUMsU0FBUyxJQUFJLENBQUMsT0FBTyxFQUFFLDZCQUE2QixJQUFJLG9DQUFvQyxDQUFDLENBQUM7WUFFNUcsTUFBTSxRQUFRLEdBQUcsc0JBQXNCLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQztZQUV2RixNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFcEMsSUFBSSxhQUFhLENBQUMsUUFBUSxDQUFDLEVBQUU7Z0JBQzNCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sVUFBVSxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7YUFDaEQ7O2dCQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFVBQVUsVUFBVSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBRTVGLE9BQU87U0FDUjtRQUVELElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUMxQixNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzVDLE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1lBQzdDLE1BQU0sUUFBUSxHQUFHLENBQUMsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO1lBRWhDLElBQUksS0FBSyxHQUFHLFFBQVEsRUFBRTtnQkFDcEIsTUFBTSxLQUFLLENBQUMsU0FBUyxLQUFLLHFCQUFxQixJQUFJLGtCQUFrQixRQUFRLEVBQUUsQ0FBQyxDQUFDO2FBQ2xGO1lBRUQsSUFBSSxhQUFhLENBQUMsUUFBUSxDQUFDO2dCQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sS0FBSyxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7O2dCQUNsRSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxVQUFVLEtBQUssQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztTQUN6RjtJQUNILENBQUM7SUFFTyxjQUFjLENBQUMsSUFBMEM7UUFDL0QsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLGFBQWEsRUFBRTtZQUMxRCxNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDdkUsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsVUFBVSxHQUFHLFFBQVEsSUFBSSxDQUFDLGNBQWMsRUFBRSxHQUFHLEVBQUUsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ2pGO2FBQU07WUFDTCxNQUFNLHNCQUFzQixHQUFHLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN2RSxJQUFJLE1BQU0sQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtnQkFDcEUsTUFBTSxLQUFLLENBQ1QsVUFBVSxJQUFJLENBQUMsT0FBTyxFQUFFLG1GQUFtRixzQkFBc0IsSUFBSSxDQUN0SSxDQUFDO2FBQ0g7WUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLElBQUksQ0FBQyxPQUFPLEVBQUUsRUFBRSxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUM1RDtJQUNILENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ssZUFBZSxDQUFDLEtBQTRCLEVBQUUsUUFBa0I7UUFDdEUsb0VBQW9FO1FBQ3BFLElBQ0UsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUNSLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsQ0FBQztZQUN2RCxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxFQUFFLEtBQUssY0FBYyxFQUNuRDtZQUNBLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUM7Z0JBQzFELE1BQU0sS0FBSyxDQUFDLGVBQWUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDN0UsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUM7Z0JBQ2hELE1BQU0sS0FBSyxDQUFDLGVBQWUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFFN0UsTUFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ3BELElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUM5QixNQUFNLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixFQUFFLENBQUMsQ0FBQztnQkFDL0YsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxVQUFVLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUM7YUFDdkc7aUJBQU0sSUFBSSxVQUFVLEtBQUssUUFBUSxFQUFFO2dCQUNsQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxhQUFhLENBQUMsQ0FBQzthQUN4Qzs7Z0JBQU0sTUFBTSxJQUFJLEtBQUssQ0FBQyxrQkFBa0IsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQztZQUUvRCxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNuQixPQUFPO1NBQ1I7UUFFRCxJQUNFLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDUixLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUM7WUFDdkQsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxLQUFLLEtBQUs7WUFDMUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDO1lBQ3hELEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsQ0FBQztZQUN4RCxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLEtBQUssaUJBQWlCO1lBQ3hDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsS0FBSyxRQUFRLEVBQy9CO1lBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsZ0JBQWdCLEVBQUUsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3hELEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ25CLE9BQU87U0FDUjtRQUVELDRCQUE0QjtRQUM1QixJQUNFLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDUixLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUM7WUFDdkQsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxLQUFLLFVBQVUsRUFDL0M7WUFDQSw0QkFBNEI7WUFDNUIsSUFDRSxLQUFLLENBQUMsQ0FBQyxDQUFDO2dCQUNSLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsQ0FBQztnQkFDdkQsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxLQUFLLFFBQVEsRUFDN0M7Z0JBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsa0JBQWtCLEVBQUUsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUMxRCxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDbkIsT0FBTzthQUNSO1lBRUQseUNBQXlDO1lBQ3pDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsdUJBQXVCLENBQUM7Z0JBQ3pELE1BQU0sS0FBSyxDQUFDLGVBQWUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDN0UsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMscUJBQXFCLEVBQUcsQ0FBQyxDQUFDO1lBQ3BELElBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsQ0FBQztZQUU5QyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNuQixPQUFPO1NBQ1I7UUFFRCxtQ0FBbUM7UUFDbkMsSUFDRSxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQ1IsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDO1lBQ3ZELEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLEVBQUUsS0FBSyxnQkFBZ0IsRUFDckQ7WUFDQSx5Q0FBeUM7WUFDekMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx1QkFBdUIsQ0FBQztnQkFDekQsTUFBTSxLQUFLLENBQUMsZUFBZSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQztZQUU3RSxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMscUJBQXFCLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxlQUFlLEVBQUUsQ0FBQztZQUU1RSxJQUFJLEtBQUssS0FBSyxTQUFTO2dCQUFFLE1BQU0sS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7WUFDaEYsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMscUJBQXFCLEVBQUcsQ0FBQyxDQUFDO1lBRXBELElBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsQ0FBQztZQUVoRCxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNuQixPQUFPO1NBQ1I7UUFFRCxpQ0FBaUM7UUFDakMsSUFDRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUM7WUFDdkQsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsRUFDbkQ7WUFDQSxNQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDbEQsTUFBTSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRW5ELElBQUksRUFBRSxHQUFHLE1BQU0sQ0FBQztZQUNoQixJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUM7Z0JBQUUsRUFBRSxHQUFHLEtBQUssQ0FBQztZQUVoQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsU0FBUyxJQUFJLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUVoRCxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNuQixPQUFPO1NBQ1I7UUFFRCw0QkFBNEI7UUFDNUIsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxFQUFFO1lBQzdHLE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUU5QyxJQUFJLElBQXdCLENBQUM7WUFFN0Isb0NBQW9DO1lBQ3BDLElBQ0UsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQztnQkFDN0MsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDO2dCQUN2RCxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLEtBQUssT0FBTyxFQUM5QjtnQkFDQSxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUM3QyxjQUFjLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDakQ7WUFDRCx3Q0FBd0M7aUJBQ25DLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxLQUFLLE9BQU8sRUFBRTtnQkFDbEcsSUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDO2FBQ2hDO2lCQUFNO2dCQUNMLE1BQU0sS0FBSyxDQUFDLDhCQUE4QixLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDO2FBQ2pFO1lBRUQsSUFBSSxNQUFjLENBQUM7WUFFbkIsSUFBSSxRQUFRLEtBQUssU0FBUyxFQUFFO2dCQUMxQixJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUMzQixjQUFjLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUN2RCxNQUFNLEdBQUcsT0FBTyxDQUFDO2FBQ2xCO2lCQUFNO2dCQUNMLE1BQU0sR0FBRyxNQUFNLENBQUM7YUFDakI7WUFFRCxJQUFJLElBQUksS0FBSyxTQUFTLEVBQUU7Z0JBQ3RCLE1BQU0sSUFBSSxJQUFJLElBQUksRUFBRSxDQUFDO2FBQ3RCO2lCQUFNO2dCQUNMLE1BQU0sSUFBSSxHQUFHLENBQUM7YUFDZjtZQUVELElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRXJELEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLElBQUksS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFNUMsT0FBTztTQUNSO1FBRUQsc0JBQXNCO1FBQ3RCLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsRUFBRTtZQUM1RyxNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDOUMsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQztnQkFBRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM1RixNQUFNLEVBQUUsWUFBWSxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUUzQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDO2dCQUM1RyxNQUFNLEtBQUssQ0FBQyxlQUFlLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBRTdFLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxLQUFLLEtBQUs7Z0JBQzVDLE1BQU0sS0FBSyxDQUFDLDRCQUE0QixLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBRTlFLE1BQU0sUUFBUSxHQUFHLG1CQUFtQixDQUFDLFlBQVksQ0FBQztpQkFDL0MsT0FBTyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUM7aUJBQzNCLE9BQU8sQ0FBQyxVQUFVLEVBQUUsU0FBUyxDQUFDO2lCQUM5QixPQUFPLENBQUMsY0FBYyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBRXJDLE1BQU0sU0FBUyxHQUFHLEdBQUcsSUFBSSxHQUFHLFFBQVEsRUFBRSxDQUFDO1lBRXZDLE1BQU0sUUFBUSxHQUFHLElBQUEsc0JBQVUsRUFBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUVoRSxJQUFJLENBQUMsUUFBUSxHQUFHLFlBQVksQ0FBQztZQUM3QixJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxVQUFVLFFBQVEsT0FBTyxTQUFTLEVBQUUsQ0FBQyxDQUFDO1lBQzlELElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDN0MsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFFbEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFFL0IsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDbkIsT0FBTztTQUNSO1FBRUQsOERBQThEO1FBQzlELElBQ0UsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDO1lBQ3ZELElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLEVBQ25EO1lBQ0EsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQzlDLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFNUM7OztlQUdHO1lBQ0gsTUFBTSxZQUFZLEdBQUcsV0FBVyxDQUFDLEdBQUcsS0FBSyxTQUFTLElBQUksV0FBVyxDQUFDLElBQUksS0FBSyxPQUFPLENBQUM7WUFFbkYsNEZBQTRGO1lBQzVGLElBQUksZUFBZSxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFM0MsSUFBSSxLQUFLLENBQUMsZUFBZSxHQUFHLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxlQUFlLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLEVBQUU7Z0JBQ2pHLGVBQWUsSUFBSSxDQUFDLENBQUM7YUFDdEI7WUFFRCxNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsZUFBZSxDQUFvRCxDQUFDO1lBRTdGLGlEQUFpRDtZQUNqRCxJQUFJLE1BQWMsQ0FBQztZQUVuQixJQUFJLFVBQVUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsQ0FBQztnQkFBRSxNQUFNLEdBQUcsVUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQzNHLElBQUksVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQyxFQUFFO2dCQUNuRCxNQUFNLEdBQUksVUFBVSxDQUFDLGFBQWEsRUFBa0MsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQzthQUM5RjtZQUVELE1BQU0sWUFBWSxHQUFHLFVBQVUsQ0FBQyxPQUFPLEVBQUUsS0FBSyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxFQUFFLENBQUM7WUFFdEUseUVBQXlFO1lBQ3pFLElBQ0UsTUFBTyxLQUFLLE9BQU87Z0JBQ25CLFlBQVk7Z0JBQ1osV0FBVyxDQUFDLFNBQVMsQ0FBQyxJQUFJLEtBQUssTUFBTTtnQkFDckMsQ0FBQyxDQUNDLFdBQVcsQ0FBQyxJQUFJLEtBQUssS0FBSztvQkFDMUIsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUM7b0JBQzFDLENBQUMsbUJBQW1CLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FDMUQsRUFDRDtnQkFDQSxJQUFJLENBQUMsbUJBQW1CLENBQUM7b0JBQ3ZCLElBQUksRUFBRSxVQUFVO29CQUNoQixNQUFNLEVBQUUsTUFBTyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQVE1QjtpQkFDWCxDQUFDLENBQUM7YUFDSjs7Z0JBQU0sSUFBSSxDQUFDLFFBQVEsR0FBRyxXQUFXLENBQUMsU0FBUyxDQUFDO1lBRTdDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLGVBQWUsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNyQyxPQUFPO1NBQ1I7UUFFRCw0Q0FBNEM7UUFDNUMsSUFDRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUM7WUFDdkQsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsRUFDakU7WUFDQSxNQUFNLEVBQUUsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7WUFFNUMsOEVBQThFO1lBQzlFLElBQUksRUFBRSxLQUFLLEtBQUssSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssU0FBUyxFQUFFO2dCQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO2dCQUMxRCxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDbkIsT0FBTzthQUNSO1lBRUQsOEVBQThFO1lBQzlFLElBQUksRUFBRSxLQUFLLEtBQUssSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssU0FBUyxFQUFFO2dCQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxxQkFBcUIsRUFBRSxXQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7Z0JBQ3BFLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUNuQixPQUFPO2FBQ1I7WUFFRCx1Q0FBdUM7WUFDdkMsSUFBSSxFQUFFLEtBQUssS0FBSyxFQUFFO2dCQUNoQix1RkFBdUY7Z0JBQ3ZGLDJGQUEyRjtnQkFDM0YsZUFBZTtnQkFDZixJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLEVBQUUsS0FBSyxTQUFTLEVBQUU7b0JBQzdHLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLGtDQUFrQyxFQUFFLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFDN0UsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7b0JBQ25CLE9BQU87aUJBQ1I7Z0JBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUscUJBQXFCLEVBQUUsV0FBVyxDQUFDLFdBQVcsQ0FBQyxDQUFDO2dCQUNwRSxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDbkIsT0FBTzthQUNSO1lBRUQsK0VBQStFO1lBQy9FLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUM7Z0JBQzFELE1BQU0sS0FBSyxDQUFDLGVBQWUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFFN0UsSUFBSSxDQUFDLHNCQUFzQixDQUN6QixLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQ1IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsRUFDbEQsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxFQUNoQyxLQUFLLEVBQ0wsSUFBSSxDQUNMLENBQUM7WUFFRixLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNuQixPQUFPO1NBQ1I7UUFFRCxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsRUFBRTtZQUM1RyxNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDcEQsSUFBSSxDQUFDLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3JDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ3BCO0lBQ0gsQ0FBQztJQUVPLHFCQUFxQixDQUFDLElBQXVCO1FBQ25ELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUU1QixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDbEMsSUFBSSxVQUFrQixDQUFDO1FBQ3ZCLElBQUksSUFBSSxFQUFFLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDLEVBQUU7WUFDeEQsVUFBVSxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUMzQzthQUFNLElBQUksSUFBSSxFQUFFLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ2pELFVBQVUsR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7WUFFNUIsNkJBQTZCO1lBQzdCLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDaEYsSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3hDLE9BQU87YUFDUjtZQUVELHVCQUF1QjtZQUN2QixJQUFJLHVCQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxFQUFFO2dCQUMxRixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUN6QixPQUFPO2FBQ1I7WUFFRCx5REFBeUQ7WUFDekQsSUFBSSxXQUFXLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxFQUFFO2dCQUNwQyxNQUFNLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUMsQ0FBQztnQkFFM0YsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksRUFBRSxVQUFVLEVBQUUsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBQzlGLE9BQU87YUFDUjtZQUVELElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssVUFBVSxDQUFDLEtBQUssU0FBUyxFQUFFO2dCQUNyRSxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDaEQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxtQkFBbUIsQ0FBQztvQkFBRSxNQUFNLEtBQUssRUFBRSxDQUFDO2dCQUN6RSxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO2dCQUNyQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2FBQzFDO1NBQ0Y7O1lBQU0sTUFBTSxJQUFJLEtBQUssQ0FBQyx1Q0FBdUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxJQUFJLElBQUksRUFBRSxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFFeEcsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUNsQyxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxVQUFVLENBQUMsQ0FBQztRQUN2RSxJQUFJLENBQUMsVUFBVTtZQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsc0JBQXNCLFVBQVUsRUFBRSxDQUFDLENBQUM7UUFFckUsSUFBSSxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDM0QsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztZQUNuQyxJQUFJLENBQUMsUUFBUSxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1lBQ3hDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDcEIsSUFBSSxDQUFDLFFBQVEsR0FBRyxZQUFZLENBQUM7WUFDN0IsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyxNQUFNLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxFQUFFO2dCQUM3RSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBQ3JDLElBQUksYUFBYSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7b0JBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUN2RTtZQUNELGNBQWMsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDekQsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsUUFBUSxHQUFHLFdBQVcsQ0FBQztRQUM1QixNQUFNLGFBQWEsR0FBRyxtQkFBbUIsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRW5FLElBQUksVUFBVSxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO1FBQ3pDLElBQUksYUFBYSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsa0JBQWtCLENBQUMsRUFBRTtZQUMzRSxVQUFVLEdBQUcsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxVQUFVLGFBQWEsRUFBRSxFQUFFLENBQUM7U0FDaEU7UUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxXQUFXLFVBQVUsRUFBRSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBQ3JELElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLElBQUksQ0FBQztZQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQy9HLENBQUM7SUFFTyxxQkFBcUIsQ0FBQyxRQUF1QjtRQUNuRCxJQUFJLFFBQVEsR0FBZSxFQUFFLENBQUM7UUFDOUIsSUFBSSxJQUF3QixDQUFDO1FBRTdCLElBQUksUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ2hELFFBQVEsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7Z0JBQzdDLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztZQUN2QyxDQUFDLENBQUMsQ0FBQztTQUNKO2FBQU0sSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDdEIsTUFBTSxHQUFHLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLGlCQUFpQixFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDekQsUUFBUSxHQUFHLEdBQUcsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztTQUN2RztRQUVELElBQUksVUFBVSxHQUFhLFNBQVMsQ0FBQyxJQUFJLENBQUM7UUFDMUMsSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDaEQsTUFBTSxHQUFHLEdBQUcsUUFBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLGlCQUFpQixFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDMUQsSUFBSSxHQUFJLEdBQUcsQ0FBQyxjQUFjLEVBQTJCLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDaEUsVUFBVSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUM7U0FDcEQ7YUFBTSxJQUFJLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUN0QixVQUFVLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztTQUN0RDtRQUVELE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxDQUFDO0lBQ3hDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssc0JBQXNCLENBQUMsSUFBeUIsRUFBRSxRQUFrQjtRQUMxRSxxRUFBcUU7UUFDckUsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLEVBQUU7WUFDN0MsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBQ2xDLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDLEVBQUU7Z0JBQ3ZELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFFaEQsSUFBSSxVQUFVLEtBQUssU0FBUyxFQUFFO29CQUM1QixJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ3BDLE9BQU87aUJBQ1I7YUFDRjtTQUNGO1FBRUQsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFdEQsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsdUJBQXVCLENBQUMsRUFBRTtZQUN0RCxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGdCQUFnQixDQUFDO2dCQUM5RCxNQUFNLEtBQUssQ0FBQyxpQ0FBaUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLFdBQVcsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUNyRixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDO1NBQ3hDO1FBRUQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzVCLElBQUksV0FBb0QsQ0FBQztRQUV6RCxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxLQUFLLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFO1lBQ3hELHVGQUF1RjtZQUN2Riw0RkFBNEY7WUFDNUYsSUFDRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUM7Z0JBQ3ZELEtBQUssQ0FBQyxDQUFDLENBQUM7Z0JBQ1IsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLENBQUM7Z0JBQzFHLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLEVBQ25EO2dCQUNBLFdBQVcsR0FBRyxDQUNaLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQ3JDLENBQUM7YUFDbEM7WUFDRCxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQztTQUN2QztRQUVEOzs7YUFHSztRQUNMLE1BQU0sU0FBUyxHQUErQixFQUFFLENBQUM7UUFFakQsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDekMsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLEtBQUssUUFBUSxFQUFFO2dCQUMvQixJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx1QkFBdUIsQ0FBQyxFQUFFO29CQUMxRCxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyw0QkFBNEIsRUFBRSxDQUFDLENBQUM7b0JBQzFELElBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsQ0FBQztvQkFDaEQsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7aUJBQ3BCOztvQkFBTSxNQUFNLEtBQUssQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDO2FBQy9EO1lBQ0QsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLEtBQUssY0FBYyxFQUFFO2dCQUNyQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsQ0FBQyxFQUFFO29CQUMzRCxNQUFNLEVBQUUsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxFQUFnQixDQUFDO29CQUUxRCxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLFlBQVksQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQztvQkFFcEUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7aUJBQ3BCO2FBQ0Y7WUFFRCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRTFDLElBQUksU0FBUyxFQUFFLElBQUksS0FBSyxVQUFVLEVBQUU7Z0JBQ2xDLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDLEVBQUU7b0JBQzNELE1BQU0sUUFBUSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztvQkFFbEQsUUFBUSxRQUFRLEVBQUU7d0JBQ2hCLEtBQUssaUJBQWlCOzRCQUNwQixJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQztnQ0FDaEQsTUFBTSxLQUFLLENBQUMsMENBQTBDLENBQUMsQ0FBQzs0QkFDMUQsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsNkJBQTZCLElBQUksQ0FBQyxPQUFPLEVBQUUsRUFBRSxFQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQzs0QkFDcEYsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7NEJBQ25CLE1BQU07d0JBQ1IsS0FBSyxjQUFjOzRCQUNqQixJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQztnQ0FBRSxNQUFNLEtBQUssQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFDOzRCQUN4RyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSwwQkFBMEIsSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLEVBQUUsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDOzRCQUNqRixLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQzs0QkFDbkIsTUFBTTt3QkFDUixLQUFLLFFBQVE7NEJBQ1gsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsQ0FBQztnQ0FBRSxNQUFNLEtBQUssRUFBRSxDQUFDOzRCQUM1RSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDO2dDQUFFLE1BQU0sS0FBSyxFQUFFLENBQUM7NEJBRTVFLGdEQUFnRDs0QkFDaEQsTUFBTSxhQUFhLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUM7NEJBQ3pGLGdEQUFnRDs0QkFDaEQsTUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUM7NEJBQ3JGLElBQUksQ0FBQyxJQUFJLENBQ1AsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUNSLGtCQUFrQixhQUFhLElBQUksV0FBVyxLQUFLLElBQUksQ0FBQyxPQUFPLEVBQUUsRUFBRSxFQUNuRSxTQUFTLENBQUMsTUFBTSxDQUNqQixDQUFDOzRCQUNGLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDOzRCQUVuQixNQUFNO3dCQUNSOzRCQUNFLE1BQU0sS0FBSyxDQUFDLDZCQUE2QixRQUFRLEVBQUUsQ0FBQyxDQUFDO3FCQUN4RDtpQkFDRjthQUNGO1lBRUQsSUFBSSxTQUFTLEVBQUUsSUFBSSxLQUFLLE1BQU0sRUFBRTtnQkFDOUIsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUMsRUFBRTtvQkFDM0QsTUFBTSxRQUFRLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO29CQUVsRCxRQUFRLFFBQVEsRUFBRTt3QkFDaEIsS0FBSyxTQUFTOzRCQUNaLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDO2dDQUFFLE1BQU0sS0FBSyxDQUFDLGlDQUFpQyxDQUFDLENBQUM7NEJBQ25HLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLHlCQUF5QixJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsRUFBRSxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7NEJBQ2hGLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDOzRCQUNuQixNQUFNO3dCQUNSLEtBQUssU0FBUzs0QkFDWixJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQztnQ0FBRSxNQUFNLEtBQUssQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDOzRCQUNuRyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSw4QkFBOEIsSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLEVBQUUsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDOzRCQUNyRixLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQzs0QkFDbkIsTUFBTTt3QkFDUjs0QkFDRSxNQUFNLEtBQUssQ0FBQyx5QkFBeUIsUUFBUSxFQUFFLENBQUMsQ0FBQztxQkFDcEQ7aUJBQ0Y7YUFDRjtZQUVELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUU1QixJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUUsRUFBRTtnQkFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsU0FBUyxJQUFJLENBQUMsc0JBQXNCLEVBQUUsR0FBRyxFQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUM3RTtZQUVELElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRSxFQUFFO2dCQUMxQixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxFQUFFLEVBQUUsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQzNFO1lBRUQscURBQXFEO1lBQ3JELElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxLQUFLLGlCQUFpQixFQUFFO2dCQUN4QyxNQUFNLEtBQUssR0FBOEI7b0JBQ3ZDLE9BQU8sRUFBRSxTQUFTO29CQUNsQixPQUFPLEVBQUUsS0FBSztvQkFDZCxlQUFlLEVBQUUsUUFBUTtvQkFDekIsV0FBVyxFQUFFLE1BQU07b0JBQ25CLGFBQWEsRUFBRSxPQUFPO29CQUN0QixXQUFXLEVBQUUsTUFBTTtvQkFDbkIsZUFBZSxFQUFFLE1BQU07aUJBQ3hCLENBQUM7Z0JBRUYsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsQ0FBQztvQkFDMUQsTUFBTSxLQUFLLENBQUMsZUFBZSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQztnQkFDN0UsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUVoRCxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztvQkFBRSxNQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QixNQUFNLEVBQUUsQ0FBQyxDQUFDO2dCQUMxRSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDMUQsT0FBTzthQUNSO1lBRUQsK0JBQStCO1lBQy9CLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxLQUFLLFNBQVMsRUFBRTtnQkFDaEMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsQ0FBQztvQkFDMUQsTUFBTSxLQUFLLENBQUMsZUFBZSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQztnQkFDN0UsSUFBSSxDQUFDLHNCQUFzQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO2dCQUMxRyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFFbkIsOENBQThDO2FBQy9DO2lCQUFNLElBQ0wsS0FBSyxDQUFDLENBQUMsQ0FBQztnQkFDUixLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDO2dCQUM3QyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFDbEMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQ2xEO2dCQUNBLE1BQU0sUUFBUSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDMUIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBRWhELEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUVuQix1QkFBdUI7YUFDeEI7aUJBQU0sSUFDTCxLQUFLLENBQUMsQ0FBQyxDQUFDO2dCQUNSLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUM7Z0JBQzdDLHVCQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxFQUM5RjtnQkFDQSxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUM3QixLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFFbkIsNEJBQTRCO2FBQzdCO2lCQUFNLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsRUFBRTtnQkFDOUMsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztnQkFFbEQsTUFBTSxjQUFjLEdBQ2xCLFFBQVEsQ0FBQyxJQUFJLEtBQUssYUFBYTtvQkFDL0IsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDO29CQUN2RCxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLEtBQUssUUFBUSxDQUFDO2dCQUVsQyxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO2dCQUVsRCxpRkFBaUY7Z0JBQ2pGLElBQUksY0FBYyxFQUFFO29CQUNsQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztpQkFDMUI7Z0JBQ0QsOEVBQThFO3FCQUN6RSxJQUFJLEtBQUssSUFBSSxLQUFLLENBQUMsS0FBSyxLQUFLLFNBQVMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRTtvQkFDNUcsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsRUFBRSxDQUFDLE9BQU8sRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO29CQUUzRyxNQUFNLEVBQUUsaUJBQWlCLEVBQUUsR0FBRyxXQUFXLENBQUM7b0JBRTFDLG9HQUFvRztvQkFDcEcsTUFBTSxXQUFXLEdBQ2YsaUJBQWlCO3dCQUNqQixpQkFBaUIsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsQ0FBQzt3QkFDaEUsY0FBYyxDQUFDLGlCQUFpQixDQUFDO3dCQUNqQyxJQUFJLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxpQkFBaUIsQ0FBRSxDQUFDO3dCQUNyRCxJQUFJLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxpQkFBaUIsQ0FBRSxDQUFDLENBQUMsSUFBSSxLQUFLLEtBQUs7d0JBQ3BFLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxpQkFBaUIsQ0FBRSxDQUFDLENBQUMsU0FBUyxDQUFDO3dCQUNwRixDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsY0FBYyxDQUFDLGlCQUFpQixDQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7b0JBRXRHLElBQUksQ0FBQyxXQUFXLEVBQUU7d0JBQ2hCLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztxQkFDdkY7eUJBQU07d0JBQ0wsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxpQkFBaUIsQ0FBRSxDQUFDLENBQUMsU0FBUyxDQUFDO3FCQUNqRjtvQkFFRCxXQUFXLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUV4RCxnQ0FBZ0M7aUJBQ2pDO3FCQUFNO29CQUNMLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQ3hCO2FBQ0Y7U0FDRjtRQUVELHVEQUF1RDtRQUN2RCxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUMsRUFBRTtZQUN2RSxNQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDbEQsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7Z0JBQ3RELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzdDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQ3BCO1NBQ0Y7UUFFRCxvRkFBb0Y7UUFDcEYsSUFBSSxZQUF1QyxDQUFDO1FBRTVDLDJGQUEyRjtRQUMzRixNQUFNLGNBQWMsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzNDLG9FQUFvRTtZQUNwRSw4RkFBOEY7WUFDOUYsSUFBSSxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDO2dCQUFFLE9BQU8sS0FBSyxDQUFDO1lBQ3BGLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUV6QixxREFBcUQ7WUFDckQsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx1QkFBdUIsQ0FBQyxFQUFFO2dCQUM3RSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxxQkFBcUIsRUFBRyxDQUFDLENBQUM7Z0JBQzdDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxVQUFVLENBQUMsQ0FBQztnQkFDdkMsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxDQUFDO2dCQUMvQyxPQUFPLEtBQUssQ0FBQzthQUNkO1lBRUQsd0JBQXdCO1lBQ3hCLElBQ0UsV0FBVyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7Z0JBQzFCLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHVCQUF1QixDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDLENBQUMsRUFDckc7Z0JBQ0EsZ0RBQWdEO2dCQUNoRCxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx1QkFBdUIsQ0FBQztvQkFBRSxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxxQkFBcUIsRUFBRyxDQUFDLENBQUM7Z0JBQ2hHLHFEQUFxRDtnQkFDckQsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUMsRUFBRTtvQkFDcEQsTUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO29CQUN6QixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztvQkFFbkUsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRTt3QkFDckQsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQzt3QkFDbkMsSUFBSSxDQUFDLFFBQVEsR0FBRyxTQUFTLENBQUM7d0JBQzFCLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQ3ZELElBQUksQ0FBQyxRQUFRLEdBQUcsWUFBWSxDQUFDO3dCQUU3QixNQUFNLGFBQWEsR0FBRyxTQUFTLENBQUMsSUFBSSxLQUFLLFFBQVEsSUFBSSxTQUFTLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLFNBQVMsQ0FBQzt3QkFDOUYsTUFBTSxxQkFBcUIsR0FBRyxTQUFTLENBQUMsSUFBSSxLQUFLLGFBQWEsSUFBSSxJQUFJLEtBQUssUUFBUSxDQUFDO3dCQUNwRixJQUFJLENBQUMsYUFBYSxJQUFJLFNBQVMsRUFBRTs0QkFDL0IsSUFBSSxDQUFDLHFCQUFxQixFQUFFO2dDQUMxQixJQUFJLENBQUMsd0JBQXdCLENBQUMsWUFBYSxFQUFFLFNBQVMsRUFBRSxXQUFXLElBQUksSUFBSSxDQUFDLENBQUM7NkJBQzlFOztnQ0FBTSxJQUFJLENBQUMsUUFBUSxHQUFHLFNBQVMsQ0FBQzs0QkFFakMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQzs0QkFDbEMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7NEJBRXJCLE9BQU8sS0FBSyxDQUFDO3lCQUNkO3FCQUNGO29CQUNELFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7aUJBQzNDO2dCQUVELFlBQVksR0FBRyxDQUFDLENBQUM7Z0JBRWpCLE1BQU0sYUFBYSxHQUFHLENBQUMsS0FBSyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7Z0JBRXBFLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxHQUFHLEVBQUU7b0JBQ3ZELElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxZQUFhLEVBQUUsU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLFdBQVcsSUFBSSxJQUFJLEVBQUUsYUFBYSxDQUFDLENBQUM7Z0JBQ3RHLENBQUMsQ0FBQyxDQUFDO2dCQUVILElBQUksQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLEVBQUU7b0JBQzlCLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxZQUFhLEVBQUUsU0FBUyxFQUFFLFdBQVcsSUFBSSxJQUFJLEVBQUUsYUFBYSxDQUFDLENBQUM7b0JBRTVGLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO2lCQUN0QjtnQkFFRCxPQUFPLEtBQUssQ0FBQzthQUNkO1lBRUQsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLEVBQUU7Z0JBQzFDLE1BQU0sSUFBSSxHQUFHLENBQUMsQ0FBQyxhQUFhLEVBQUUsQ0FBQztnQkFDL0IsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsQ0FBQztvQkFDdEQsTUFBTSxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUMsV0FBVyxFQUFFLEtBQUssQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQztnQkFFaEUsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUVoRCw2QkFBNkI7Z0JBQzdCLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRTtvQkFDOUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ3JDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO29CQUNyQixPQUFPLEtBQUssQ0FBQztpQkFDZDtnQkFFRCw4RUFBOEU7Z0JBQzlFLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7Z0JBQ2xDLENBQUMsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDckQsSUFBSSxDQUFDLFFBQVEsR0FBRyxXQUFXLENBQUM7Z0JBQzVCLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxVQUFVLENBQUMsQ0FBQztnQkFDMUQsT0FBTyxLQUFLLENBQUM7YUFDZDtZQUVELHNFQUFzRTtZQUN0RSxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsQ0FBQyxFQUFFO2dCQUNwRCxJQUFJLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRTtvQkFDbkUsTUFBTSxNQUFNLEdBQUcsQ0FBQyxDQUFDLDBCQUEwQixDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLENBQUM7b0JBQ3RFLE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztvQkFDcEMsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQztvQkFDcEUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsR0FBRyxTQUFTLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQztvQkFDaEQsT0FBTyxLQUFLLENBQUM7aUJBQ2Q7Z0JBRUQsdURBQXVEO2dCQUN2RCxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsQ0FBQyxFQUFFO29CQUNwRCxNQUFNLFFBQVEsR0FBRyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7b0JBQzNDLElBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFO3dCQUMvQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUN0QyxPQUFPLEtBQUssQ0FBQztxQkFDZDtpQkFDRjtnQkFFRCxJQUFJLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUM7b0JBQUUsT0FBTyxLQUFLLENBQUM7Z0JBQ3BGLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztnQkFDekUsT0FBTyxLQUFLLENBQUM7YUFDZDtZQUVELE1BQU0sV0FBVyxHQUFHLG1CQUFtQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUV2RCxvRkFBb0Y7WUFDcEYsSUFBSSxXQUFXLENBQUMsVUFBVSxDQUFDLGlCQUFpQixDQUFDLEVBQUU7Z0JBQzdDLElBQUksQ0FBQyxDQUFDLHFCQUFxQixFQUFFLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLEVBQUU7b0JBQ25FLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsR0FBRyxFQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxxQkFBcUIsRUFBRSxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUU7d0JBQ3BHLElBQUksRUFBRSxNQUFNO3dCQUNaLElBQUksRUFBRSxXQUFXLENBQUMsT0FBTyxDQUFDLGtCQUFrQixFQUFFLEVBQUUsQ0FBQztxQkFDbEQsQ0FBQyxDQUFDO2lCQUNKO3FCQUFNLElBQUksQ0FBQyxDQUFDLHFCQUFxQixFQUFFLEVBQUU7b0JBQ3BDLE1BQU0sTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUM5RSxNQUFNLEtBQUssR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBRSxDQUFDLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDN0UsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7b0JBRXJDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLHFCQUFxQixFQUFHLENBQUMsQ0FBQztvQkFDN0MsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsR0FBRyxNQUFNLE1BQU0sS0FBSyxFQUFFLEVBQUU7d0JBQ25DLElBQUksRUFBRSxNQUFNO3dCQUNaLElBQUksRUFBRSxXQUFXLENBQUMsT0FBTyxDQUFDLGtCQUFrQixFQUFFLEVBQUUsQ0FBQztxQkFDbEQsQ0FBQyxDQUFDO2lCQUNKO2dCQUVELE9BQU8sS0FBSyxDQUFDO2FBQ2Q7WUFFRCxPQUFPLElBQUksQ0FBQztRQUNkLENBQUMsQ0FBQyxDQUFDO1FBRUgsOERBQThEO1FBQzlELElBQUksU0FBUyxDQUFDLE1BQU0sRUFBRTtZQUNwQixJQUFJLENBQUMsd0JBQXdCLENBQUMsWUFBYSxFQUFFLFNBQVMsRUFBRSxXQUFXLElBQUksSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1NBQ3hGO1FBRUQsSUFBSSxjQUFjLENBQUMsTUFBTTtZQUN2QixNQUFNLEtBQUssQ0FDVCxhQUFhLG1CQUFtQixDQUM5QixJQUFJLENBQUMsUUFBUSxDQUNkLFlBQVksSUFBSSxDQUFDLFdBQVcsRUFBRSxNQUFNLElBQUksQ0FBQyxPQUFPLEVBQUUsYUFBYSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsRUFBRSxDQUNoRyxDQUFDO0lBQ04sQ0FBQztJQUVPLGlCQUFpQixDQUFDLEVBQWlEO1FBQ3pFLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztRQUN6RCxJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDLFdBQVcsRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFFLENBQUM7UUFFL0YsTUFBTSxTQUFTLEdBQUcsRUFBRTthQUNqQixZQUFZLEVBQUU7YUFDZCxhQUFhLEVBQUU7YUFDZixHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBRWhELE1BQU0sZ0JBQWdCLEdBQUcsRUFBRSxDQUFDLGlCQUFpQixFQUFFLEVBQUUsT0FBTyxFQUFFLElBQUksTUFBTSxDQUFDO1FBQ3JFLE1BQU0sYUFBYSxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsT0FBTyxFQUFFLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxnQkFBZ0IsRUFBRSxDQUFDLENBQUM7UUFFM0YsSUFBSSxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxLQUFLLEVBQUUsRUFBRTtZQUN0QyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3pCLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzFELFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQzVCLE1BQU0sT0FBTyxHQUFHLElBQUk7cUJBQ2pCLElBQUksRUFBRTtxQkFDTixPQUFPLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQztxQkFDdEIsT0FBTyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUM7cUJBQ3BCLE9BQU8sQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7Z0JBQ3RCLElBQUksT0FBTyxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7b0JBQ25FLGFBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQy9DLENBQUMsQ0FBQyxDQUFDO1NBQ0o7UUFFRCxPQUFPLGFBQWEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxLQUFLO1lBQUUsYUFBYSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRTNELElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxFQUFFLEdBQUcsYUFBYSxDQUFDLENBQUM7UUFFckMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztRQUNyRCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUM7UUFDbEUsSUFBSSxDQUFDLGNBQWMsR0FBRyxFQUFFLENBQUM7UUFFekIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLEVBQUUsa0JBQWtCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBRXBFLElBQUksUUFBUSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ2xCLE1BQU0sTUFBTSxHQUFHLElBQUksS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUM7UUFDaEQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO1lBQ25CLElBQUksQ0FBQyxDQUFDLFdBQVcsRUFBRSxLQUFLLFNBQVM7Z0JBQUUsTUFBTSxJQUFJLEtBQUssRUFBRSxDQUFDO1lBRXJELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7WUFFMUQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRztnQkFDL0MsS0FBSyxFQUFFLFFBQVE7Z0JBQ2YsSUFBSTtnQkFDSixVQUFVLEVBQUUsQ0FBQyxDQUFDLFdBQVcsRUFBRyxDQUFDLE9BQU8sRUFBRTthQUN2QyxDQUFDO1lBQ0YsUUFBUSxJQUFJLENBQUMsQ0FBQztRQUNoQixDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUM7UUFFdEMsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDbkQsTUFBTSxZQUFZLEdBQUcsSUFBSSxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxTQUFTLENBQUM7UUFFOUQsSUFBSSxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxLQUFLLEtBQUssWUFBWSxFQUFFLEVBQUU7WUFDcEQsV0FBVyxDQUFDLEdBQUcsRUFBRSxDQUFDO1NBQ25CO1FBRUQsSUFBSSxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssWUFBWSxFQUFFLENBQUMsRUFBRTtZQUNoRSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsR0FBRyxZQUFZLEdBQUcsQ0FBQyxDQUFDO1NBQ2pFO1FBRUQsSUFBSSxnQkFBZ0IsS0FBSyxNQUFNLElBQUksSUFBSSxDQUFDLFVBQVUsR0FBRyxDQUFDLEVBQUU7WUFDdEQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxFQUFFLG9DQUFvQyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1lBRWxHLElBQUksSUFBSSxDQUFDLFVBQVUsR0FBRyxDQUFDLEVBQUU7Z0JBQ3ZCLElBQUksQ0FBQyxTQUFTLENBQ1osSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksRUFDM0IsMkNBQTJDLEVBQzNDLFFBQVEsSUFBSSxDQUFDLFVBQVUsR0FBRyxDQUFDLEVBQUUsQ0FDOUIsQ0FBQzthQUNIO1NBQ0Y7UUFFRCxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFFckQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEdBQUc7WUFDNUMsS0FBSyxFQUFFLFVBQVU7WUFDakIsR0FBRyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLE1BQU07WUFDMUMsS0FBSyxFQUFFLEVBQUU7U0FDVixDQUFDO1FBRUYsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQztRQUN6QyxNQUFNLGdCQUFnQixHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXJFLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO1lBQ2hELGdCQUFnQixDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBTSxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUM5RixDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxjQUFjLEdBQUcsU0FBUyxDQUFDO1FBQ2hDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDaEUsQ0FBQztJQUVPLGlCQUFpQixDQUFDLEVBQXdCO1FBQ2hELElBQUksSUFBSSxDQUFDLGtCQUFrQjtZQUFFLE1BQU0sS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7UUFFcEYsSUFBSSxDQUFDLGNBQWMsR0FBRyxPQUFPLENBQUM7UUFDOUIsSUFBSSxFQUFFLENBQUMsYUFBYSxFQUFFLENBQUMsTUFBTSxHQUFHLENBQUM7WUFBRSxNQUFNLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDO1FBQ3JGLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUM7UUFDdEMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsY0FBYyxFQUFFLEVBQUUsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQ3ZELElBQUksQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLENBQUM7UUFDL0IsSUFBSSxDQUFDLGNBQWMsR0FBRyxVQUFVLENBQUM7SUFDbkMsQ0FBQztJQUVPLGFBQWEsQ0FBQyxJQUFhLEVBQUUsS0FBYTtRQUNoRCxJQUFJLElBQUksQ0FBQyxxQkFBcUI7WUFBRSxPQUFPO1FBRXZDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsT0FBTyxLQUFLLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUU1RCxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFO1lBQ2hELElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUUsNEJBQTRCLEtBQUssT0FBTyxDQUFDLENBQUM7U0FDMUY7O1lBQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLEdBQUcsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLGVBQWUsS0FBSyxPQUFPLENBQUMsQ0FBQztJQUMzRyxDQUFDO0lBRU8scUJBQXFCLENBQUMsRUFBd0I7UUFDcEQsSUFBSSxJQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLElBQUksSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksS0FBSyxZQUFZLEVBQUU7WUFDN0csSUFBSSxDQUFDLGlCQUFpQixDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQzNCLE9BQU87U0FDUjtRQUVELElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFLE1BQU0sSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDakQsSUFBSSxJQUFJLENBQUMsY0FBYyxLQUFLLE1BQU0sRUFBRTtZQUNsQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsRUFBRSxjQUFjLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO1NBQ2xFO2FBQU07WUFDTCxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsRUFBRSxVQUFVLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO1NBQzlEO1FBRUQsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7UUFDdkQsTUFBTSxhQUFhLEdBQUcsbUJBQW1CLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7YUFDM0UsT0FBTyxDQUFDLG1CQUFtQixFQUFFLFFBQVEsQ0FBQzthQUN0QyxPQUFPLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBRWpDLElBQUksYUFBYSxLQUFLLE1BQU07WUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsRUFBRSwwQkFBMEIsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1FBRWhHLE1BQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxNQUFNLENBQUM7UUFFM0MsTUFBTSxJQUFJLEdBQXFELEVBQUUsQ0FBQztRQUVsRSxJQUFJLGNBQWMsR0FDaEIsUUFBUSxHQUFHLEVBQUUsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1FBQ3JHLElBQUksU0FBUyxHQUFHLENBQUMsQ0FBQztRQUVsQixJQUFJLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUMxRCxJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUUsQ0FBQyxXQUFXLEVBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1lBRXpELElBQUksQ0FBQyxDQUFDLFdBQVcsRUFBRSxFQUFFLE9BQU8sRUFBRSxLQUFLLFNBQVMsRUFBRTtnQkFDNUMsSUFBSSxHQUFHLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLENBQUM7YUFDMUM7WUFDRCxNQUFNLE9BQU8sR0FBRyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUUxQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLEVBQUUsS0FBSyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1lBRWhFLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNoQyxJQUFJLElBQUksQ0FBQyxjQUFjLEtBQUssTUFBTTtvQkFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsY0FBYyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxDQUFDOztvQkFDN0YsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsd0JBQXdCLENBQUMsY0FBYyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQzthQUN4RTtZQUVELElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUNuQixJQUFJLElBQUksQ0FBQyxjQUFjLEtBQUssTUFBTSxFQUFFO29CQUNsQyxJQUFJLENBQUMsY0FBYyxFQUFFLGdCQUFnQixDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQzt3QkFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztpQkFDcEY7cUJBQU07b0JBQ0wsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7b0JBQ3pCLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLFNBQVMsbUJBQW1CLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2lCQUM1RDthQUNGO2lCQUFNLElBQUksU0FBUyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDdEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztnQkFDbkMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLFNBQVMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQzVDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO2dCQUN0QixJQUFJLE9BQU8sS0FBSyxLQUFLLEVBQUU7b0JBQ3JCLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxnQkFBZ0IsRUFBRSxPQUFPLE9BQU8sRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO29CQUNuRSxJQUFJLENBQUMsUUFBUSxDQUNYLENBQUMsRUFDRCxRQUFRLEVBQ1IsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBRSxTQUN6QyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFDekIsY0FBYyxPQUFPLGNBQWMsQ0FDcEMsQ0FBQztpQkFDSDthQUNGO2lCQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLE9BQU8sS0FBSyxRQUFRLEVBQUU7Z0JBQzVELElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsT0FBTyxPQUFPLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDbEcsSUFBSSxDQUFDLFFBQVEsQ0FDWCxDQUFDLEVBQ0QsUUFBUSxFQUNSLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLEVBQUUsU0FBUyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxjQUFjLE9BQU8sRUFBRSxDQUN2RyxDQUFDO2FBQ0g7WUFFRCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQztnQkFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUVsRCxJQUFJLENBQUMsSUFBSSxDQUFDO2dCQUNSLElBQUksRUFBRSxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxFQUFFO2dCQUMvQixJQUFJO2dCQUNKLElBQUksRUFBRSxFQUFFO2FBQ1QsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7UUFFSCxvRUFBb0U7UUFDcEUsTUFBTSxhQUFhLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDMUUsSUFBSSxhQUFhLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUM1QixJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7Z0JBQ3BCLElBQUksRUFBRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSTtnQkFDakMsUUFBUSxFQUFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLElBQUksU0FBUztnQkFDdEQsSUFBSSxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUU7Z0JBQ3BCLElBQUksRUFBRSxFQUFFO2dCQUNSLE9BQU8sRUFBRSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRTtnQkFDdkMsTUFBTSxFQUFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNO2FBQ3RDLENBQUMsQ0FBQztTQUNKO1FBRUQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsY0FBYyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDbEYsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsV0FBVyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUU1RCxJQUFJLGFBQWEsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLGtCQUFrQixDQUFDLEVBQUU7WUFDM0UsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFVBQVUsYUFBYSxFQUFFLEVBQUUsQ0FBQztZQUNsRSxJQUFJLENBQUMsYUFBYSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDdkM7O1lBQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFFMUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxVQUFVLEVBQUUsU0FBUyxDQUFDLElBQUksQ0FBQztZQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxFQUFFLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNqRixJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDdEMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUF1Qk8sYUFBYSxDQUFDLElBQXVCO1FBQzNDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUVoRCxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxJQUFJLFFBQVEsQ0FBQztRQUU1RCxJQUFJLFVBQVUsS0FBSyxRQUFRLEVBQUU7WUFDM0IsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQ2pDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFMUIsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLGVBQWUsRUFBRTtnQkFDdkQsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxzQkFBc0IsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLFFBQVEsRUFBRTtnQkFDakUsQ0FBQyxDQUFDLFNBQVMsQ0FBQztZQUVkLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxZQUFZLENBQUMsQ0FBQztZQUU1QyxPQUFPO1NBQ1I7UUFFRCxJQUFJLFVBQVUsS0FBSyxNQUFNLEVBQUU7WUFDekIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN6QyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1lBQzNCLE1BQU0sTUFBTSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUM7WUFFbEQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFFNUIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxFQUFFO2dCQUNoRixJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsVUFBVSxJQUFJLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQzthQUMvRDtZQUVELE9BQU87U0FDUjtRQUVELElBQUksSUFBSSxDQUFDLGNBQWMsS0FBSyxNQUFNLElBQUksVUFBVSxLQUFLLEtBQUssRUFBRTtZQUMxRCxNQUFNLEtBQUssQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDO1NBQ2pEO1FBRUQsTUFBTSxNQUFNLEdBQUcsdUJBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLFVBQVUsQ0FBRSxDQUFDO1FBQ2hFLElBQUksSUFBSSxHQUFhLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFbEMsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRSxFQUFFLE9BQU8sRUFBRSxFQUFFLGlCQUFpQixFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxjQUFjLEVBQUUsQ0FBQztRQUVoRyxNQUFNLFFBQVEsR0FBYyxFQUFFLENBQUM7UUFDL0IsSUFBSSxXQUFXLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsbUJBQW1CLENBQUMsRUFBRTtZQUMxRCxXQUFXLENBQUMsYUFBYSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDeEU7UUFFRCxJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFO1lBQ3JCLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7WUFDbEMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDbkMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDcEIsSUFBSSxXQUFXO29CQUFFLGNBQWMsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNoRixDQUFDLENBQUMsQ0FBQztZQUNILElBQUksQ0FBQyxRQUFRLEdBQUcsV0FBVyxDQUFDO1NBQzdCO2FBQU0sSUFBSSxNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRTtZQUM1QixJQUFJLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ2pFO2FBQU07WUFDTCxJQUFJO2lCQUNELFlBQVksRUFBRTtpQkFDZCxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7aUJBQ3RCLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDaEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDcEIsSUFBSSxXQUFXO29CQUFFLGNBQWMsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNsRyxDQUFDLENBQUMsQ0FBQztZQUVMLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUNoQixJQUFJO2lCQUNELFlBQVksRUFBRTtpQkFDZCxLQUFLLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO2lCQUN6QixHQUFHLENBQUMsQ0FBQyxZQUFZLEVBQUUsRUFBRTtnQkFDcEIsTUFBTSxnQkFBZ0IsR0FBRyxZQUFZLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBRWhELElBQUksZ0JBQWdCLENBQUMsZUFBZSxFQUFFLEVBQUU7b0JBQ3RDLE9BQU8sZ0JBQWdCLENBQUMsc0JBQXNCLEVBQUUsQ0FBQyxPQUFPLEVBQVksQ0FBQztpQkFDdEU7Z0JBQ0QsSUFBSSxnQkFBZ0IsQ0FBQyxlQUFlLEVBQUUsRUFBRTtvQkFDdEMsT0FBTyxnQkFBZ0IsQ0FBQyxzQkFBc0IsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDO2lCQUN2RTtnQkFFRCxNQUFNLEtBQUssQ0FBQyxrQkFBa0IsWUFBWSxDQUFDLE9BQU8sRUFBRSx3QkFBd0IsQ0FBQyxDQUFDO1lBQ2hGLENBQUMsQ0FBQyxDQUNMLENBQUM7U0FDSDtRQUVELElBQUksYUFBYSxHQUFHLE1BQU0sQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsSUFBSSxNQUFNLENBQUM7UUFFdEYsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUM7WUFBRSxhQUFhLEdBQUcsVUFBVSxDQUFDO1FBRTVELElBQUksVUFBb0IsQ0FBQztRQUV6QixJQUFJLGFBQWEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDaEMsVUFBVSxHQUFHLEVBQUUsSUFBSSxFQUFFLGNBQWMsRUFBRSxJQUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxhQUFhLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7U0FDdEc7YUFBTSxJQUFJLGFBQWEsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDMUMsVUFBVSxHQUFHO2dCQUNYLElBQUksRUFBRSxhQUFhO2dCQUNuQixNQUFNLEVBQUUsTUFBTSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzlDLElBQUksRUFBRSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLGFBQWEsQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxFQUFFO2FBQ3BFLENBQUM7U0FDSDthQUFNO1lBQ0wsVUFBVSxHQUFHLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsYUFBYSxFQUFjLENBQUM7U0FDaEU7UUFFRCxJQUFJLFVBQVUsQ0FBQyxVQUFVLEVBQUUsU0FBUyxDQUFDLEdBQUcsQ0FBQztZQUFFLFVBQVUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBRXpGLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFFNUQsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQztRQUU5RCxJQUFJLFVBQVUsS0FBSyxZQUFZLEVBQUU7WUFDL0IsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO1lBQ2hDLElBQUksQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsbUJBQW1CLENBQUMsRUFBRTtnQkFDdEQsTUFBTSxLQUFLLENBQUMsR0FBRyxVQUFVLHFEQUFxRCxDQUFDLENBQUM7YUFDakY7WUFDRCxNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsT0FBTyxFQUFFLENBQUM7WUFFOUIsTUFBTSxRQUFRLEdBQUcsR0FBRyxJQUFJLFdBQVcsQ0FBQztZQUNwQyxNQUFNLE1BQU0sR0FBRyxHQUFHLElBQUksU0FBUyxDQUFDO1lBRWhDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLEVBQUUsR0FBRyxRQUFRLFFBQVEsQ0FBQyxDQUFDO1lBQzNGLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLFNBQVMsQ0FBQyxLQUFLLEVBQUUsR0FBRyxNQUFNLFVBQVUsQ0FBQyxDQUFDO1lBRTFFLElBQUksQ0FBQyxRQUFRLEdBQUcsY0FBYyxDQUFDO1NBQ2hDO1FBRUQsSUFBSSxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ2pELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUNoQyxJQUFJLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLG1CQUFtQixDQUFDLEVBQUU7Z0JBQ3RELE1BQU0sS0FBSyxDQUFDLEdBQUcsVUFBVSxxREFBcUQsQ0FBQyxDQUFDO2FBQ2pGO1lBQ0QsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBRTlCLE1BQU0sR0FBRyxHQUFHLEdBQUcsSUFBSSxNQUFNLENBQUM7WUFDMUIsTUFBTSxJQUFJLEdBQUcsR0FBRyxJQUFJLE9BQU8sQ0FBQztZQUU1QixJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxTQUFTLENBQUMsTUFBTSxFQUFFLEdBQUcsR0FBRyxVQUFVLENBQUMsQ0FBQztZQUNyRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxTQUFTLENBQUMsTUFBTSxFQUFFLEdBQUcsSUFBSSxVQUFVLENBQUMsQ0FBQztZQUV2RSxJQUFJLENBQUMsUUFBUSxHQUFHLGNBQWMsQ0FBQztTQUNoQztRQUVELElBQUksVUFBVSxLQUFLLFNBQVMsRUFBRTtZQUM1QixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDaEMsSUFBSSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFO2dCQUN0RCxNQUFNLEtBQUssQ0FBQyxHQUFHLFVBQVUscURBQXFELENBQUMsQ0FBQzthQUNqRjtZQUNELE1BQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUU5QixNQUFNLFdBQVcsR0FBRyxHQUFHLElBQUksY0FBYyxDQUFDO1lBQzFDLE1BQU0sWUFBWSxHQUFHLEdBQUcsSUFBSSxlQUFlLENBQUM7WUFDNUMsTUFBTSxhQUFhLEdBQUcsR0FBRyxJQUFJLGdCQUFnQixDQUFDO1lBQzlDLE1BQU0sWUFBWSxHQUFHLEdBQUcsSUFBSSxlQUFlLENBQUM7WUFFNUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxZQUFZLEVBQUUsU0FBUyxDQUFDLE1BQU0sRUFBRSxHQUFHLFlBQVksVUFBVSxDQUFDLENBQUM7WUFDdkYsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxhQUFhLEVBQUUsU0FBUyxDQUFDLE1BQU0sRUFBRSxHQUFHLGFBQWEsVUFBVSxDQUFDLENBQUM7WUFDekYsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxXQUFXLEVBQUUsU0FBUyxDQUFDLE1BQU0sRUFBRSxHQUFHLFdBQVcsVUFBVSxDQUFDLENBQUM7WUFDckYsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxZQUFZLEVBQUUsU0FBUyxDQUFDLE1BQU0sRUFBRSxHQUFHLFlBQVksVUFBVSxDQUFDLENBQUM7WUFFdkYsSUFBSSxDQUFDLFFBQVEsR0FBRyxjQUFjLENBQUM7U0FDaEM7UUFFRCxJQUFJLGNBQWMsQ0FBQyxJQUFJLEtBQUssTUFBTSxJQUFJLGNBQWMsQ0FBQyxJQUFJLEtBQUssY0FBYyxFQUFFO1lBQzVFLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUNoQyxJQUFJLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLG1CQUFtQixDQUFDLEVBQUU7Z0JBQ3RELE1BQU0sS0FBSyxDQUFDLEdBQUcsVUFBVSxxREFBcUQsQ0FBQyxDQUFDO2FBQ2pGO1lBQ0QsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBRTlCLE1BQU0sQ0FBQyxHQUFHLEdBQUcsSUFBSSxJQUFJLENBQUM7WUFDdEIsTUFBTSxDQUFDLEdBQUcsR0FBRyxJQUFJLElBQUksQ0FBQztZQUV0QixJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxTQUFTLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1lBQzFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLG9CQUFvQixDQUFDLENBQUM7WUFFMUUsSUFBSSxDQUFDLFFBQVEsR0FBRyxjQUFjLENBQUM7U0FDaEM7SUFDSCxDQUFDO0lBRU8sZ0JBQWdCLENBQUMsSUFBYSxFQUFFLElBQVksRUFBRSxJQUFjLEVBQUUsT0FBZ0I7UUFDcEYsTUFBTSxjQUFjLEdBQUcsR0FBRyxJQUFJLEtBQUssbUJBQW1CLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztRQUMvRCxlQUFlO1FBQ2YsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRztZQUMxQixLQUFLLEVBQUUsSUFBSSxDQUFDLFVBQVU7WUFDdEIsSUFBSTtZQUNKLFVBQVUsRUFBRSxtQkFBbUIsQ0FBQyxJQUFJLENBQUM7WUFDckMsT0FBTztTQUNSLENBQUM7UUFDRixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxjQUFjLElBQUksQ0FBQyxVQUFVLE9BQU8sT0FBTyxJQUFJLGNBQWMsRUFBRSxDQUFDLENBQUM7UUFDckYsSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVPLFNBQVMsQ0FBQyxJQUFhLEVBQUUsSUFBWTtRQUMzQyxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3hDLElBQUksQ0FBQyxLQUFLO1lBQUUsTUFBTSxLQUFLLENBQUMsb0JBQW9CLElBQUksRUFBRSxDQUFDLENBQUM7UUFFcEQsY0FBYyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUVoRCxNQUFNLGNBQWMsR0FBRyxHQUFHLElBQUksS0FBSyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQztRQUV4RSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxjQUFjLEtBQUssQ0FBQyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sSUFBSSxjQUFjLEVBQUUsQ0FBQyxDQUFDO0lBQ3pGLENBQUM7SUFFTyxRQUFRLENBQUMsSUFBYSxFQUFFLElBQVk7UUFDMUMsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN4QyxJQUFJLENBQUMsS0FBSztZQUFFLE1BQU0sS0FBSyxDQUFDLG9CQUFvQixJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBRXBELElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLGFBQWEsS0FBSyxDQUFDLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxJQUFJLElBQUksRUFBRSxDQUFDLENBQUM7UUFDNUUsSUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDO0lBQzdCLENBQUM7SUFFTyxrQkFBa0IsQ0FDeEIsSUFBYSxFQUNiLElBQVksRUFDWixNQUFlLEVBQ2YsUUFBb0IsRUFDcEIsVUFBb0IsRUFDcEIsVUFBbUI7UUFFbkIsTUFBTSxjQUFjLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVuRSxJQUFJLElBQUksQ0FBQyxjQUFjLEtBQUssT0FBTztZQUFFLE1BQU0sS0FBSyxDQUFDLHVEQUF1RCxDQUFDLENBQUM7UUFDMUcsSUFBSSxJQUFJLENBQUMsY0FBYyxLQUFLLE1BQU07WUFBRSxNQUFNLEtBQUssQ0FBQyxtREFBbUQsQ0FBQyxDQUFDO1FBRXJHLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsdUJBQXVCLENBQUM7WUFDdkQsTUFBTSxJQUFJLEtBQUssQ0FBQyw4Q0FBOEMsQ0FBQyxDQUFDO1FBRWxFLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsb0JBQW9CLEVBQUUsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLG1CQUFtQixFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3ZGLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDckMsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzFCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7U0FDOUI7YUFBTSxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDbEMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLEtBQUssQ0FBQztTQUMvQjtRQUVELElBQUksT0FBTyxHQUFHLEVBQUUsQ0FBQztRQUVqQixNQUFNLENBQUMsYUFBYSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDbkMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQztnQkFBRSxNQUFNLEtBQUssRUFBRSxDQUFDO1lBQy9ELE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxXQUFXLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQztZQUV2QyxJQUFJLEdBQUcsS0FBSyxZQUFZLEVBQUU7Z0JBQ3hCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7Z0JBQzlCLE9BQU87YUFDUjtZQUVELElBQUksR0FBRyxLQUFLLFlBQVksRUFBRTtnQkFDeEIsTUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDO2dCQUNoQyxJQUFJLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHNCQUFzQixDQUFDO29CQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsNkJBQTZCLENBQUMsQ0FBQztnQkFFeEcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFTLEVBQUUsRUFBRTtvQkFDMUMsSUFBSSxTQUFTLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRTt3QkFDMUcsSUFBSSxTQUFTLEdBQWUsRUFBRSxDQUFDO3dCQUMvQixJQUFJLHFCQUFxQixHQUFhLFNBQVMsQ0FBQyxJQUFJLENBQUM7d0JBQ3JELE1BQU0sT0FBTyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFFNUIsSUFBSSxPQUFPLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBRTs0QkFDN0IsU0FBUyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUM7NEJBQ3pCLHFCQUFxQixHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUM7eUJBQ3pDO3dCQUNELElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxTQUFTLEVBQUUscUJBQXFCLENBQUMsQ0FBQztxQkFDcEY7Z0JBQ0gsQ0FBQyxDQUFDLENBQUM7YUFDSjtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUg7O1VBRUU7UUFFRixRQUFRLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxFQUFFO1lBQ3RDLEtBQUssS0FBSyxDQUFDO1lBQ1gsS0FBSyxTQUFTO2dCQUNaLE9BQU8sR0FBRyxlQUFlLENBQUMsU0FBUyxDQUFDO2dCQUNwQyxNQUFNO1lBQ1IsS0FBSyxPQUFPLENBQUM7WUFDYixLQUFLLGVBQWU7Z0JBQ2xCLE9BQU8sR0FBRyxlQUFlLENBQUMsZUFBZSxDQUFDO2dCQUMxQyxNQUFNO1lBQ1IsS0FBSyxNQUFNLENBQUM7WUFDWixLQUFLLFlBQVksQ0FBQztZQUNsQixLQUFLLFNBQVM7Z0JBQ1osT0FBTyxHQUFHLGVBQWUsQ0FBQyxpQkFBaUIsQ0FBQztnQkFDNUMsTUFBTTtZQUNSLEtBQUssTUFBTSxDQUFDO1lBQ1osS0FBSyxlQUFlLENBQUM7WUFDckIsS0FBSyxhQUFhO2dCQUNoQixPQUFPLEdBQUcsZUFBZSxDQUFDLGFBQWEsQ0FBQztnQkFDeEMsTUFBTTtZQUNSLEtBQUssTUFBTSxDQUFDO1lBQ1osS0FBSyxhQUFhO2dCQUNoQixPQUFPLEdBQUcsZUFBZSxDQUFDLGFBQWEsQ0FBQztnQkFDeEMsTUFBTTtZQUNSLEtBQUssUUFBUSxDQUFDO1lBQ2QsS0FBSyx3QkFBd0IsQ0FBQztZQUM5QixLQUFLLHVCQUF1QjtnQkFDMUIsT0FBTyxHQUFHLGVBQWUsQ0FBQyxpQkFBaUIsQ0FBQztnQkFDNUMsTUFBTTtZQUNSO2dCQUNFLE1BQU0sSUFBSSxLQUFLLENBQUMsNEJBQTRCLElBQUksRUFBRSxDQUFDLENBQUM7U0FDdkQ7UUFFRCxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDeEUsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEtBQUssS0FBSztZQUFFLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7UUFDbEUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsT0FBTyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBQ3RDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLHFCQUFxQixDQUFDLENBQUM7UUFFM0MsTUFBTSxRQUFRLEdBQUcsTUFBTTthQUNwQixhQUFhLEVBQUU7YUFDZixJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxXQUFXLEVBQUUsRUFBRSxPQUFPLEVBQUUsS0FBSyxNQUFNLENBQUMsQ0FBQztRQUVwRyxNQUFNLHFCQUFxQixHQUFHLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRWhHLElBQUksUUFBUSxJQUFJLE9BQU8sS0FBSyxlQUFlLENBQUMsaUJBQWlCLEVBQUU7WUFDN0QsSUFDRSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQztnQkFDbEQsQ0FBQyxRQUFRLENBQUMsY0FBYyxFQUFHLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDO2dCQUUvRCxNQUFNLElBQUksS0FBSyxDQUFDLHVDQUF1QyxDQUFDLENBQUM7WUFFM0QsSUFBSSxDQUFDLFFBQVEsQ0FDWCxRQUFRLEVBQ1IsV0FBWSxRQUFRLENBQUMsY0FBYyxFQUF3QixDQUFDLGNBQWMsRUFBRSxJQUFJLHFCQUFxQixDQUFDLElBQUksQ0FDeEcsR0FBRyxDQUNKLElBQUksbUJBQW1CLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQzlDLENBQUM7WUFDRixJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSw0QkFBNEIsQ0FBQyxDQUFDO1NBQ3ZEO2FBQU0sSUFBSSxVQUFVLEVBQUU7WUFDckIsSUFBSSxDQUFDLFFBQVEsQ0FDWCxJQUFJLEVBQ0osV0FBVyxVQUFVLElBQUkscUJBQXFCO2lCQUMzQyxJQUFJLENBQUMsR0FBRyxDQUFDO2dCQUNWLHVFQUF1RTtpQkFDdEUsT0FBTyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsSUFBSSxtQkFBbUIsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FDcEUsQ0FBQztZQUNGLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLDRCQUE0QixDQUFDLENBQUM7U0FDbkQ7UUFFRCxNQUFNLENBQUMsYUFBYSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDbkMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQztnQkFBRSxNQUFNLEtBQUssRUFBRSxDQUFDO1lBQy9ELE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxXQUFXLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQztZQUN2QyxNQUFNLElBQUksR0FBRyxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7WUFFaEMsSUFBSSxHQUFHLEtBQUssU0FBUztnQkFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixDQUFDLENBQUM7WUFFOUQsSUFBSSxHQUFHLEtBQUssWUFBWTtnQkFBRSxPQUFPO1lBRWpDLElBQUksR0FBRyxLQUFLLE1BQU0sSUFBSSxPQUFPLEtBQUssZUFBZSxDQUFDLGlCQUFpQixFQUFFO2dCQUNuRSxPQUFPO2FBQ1I7WUFFRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQy9CLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFckIsSUFDRSxDQUFDLEdBQUcsS0FBSyxpQkFBaUIsSUFBSSxHQUFHLEtBQUssbUJBQW1CLENBQUM7Z0JBQzFELElBQUksRUFBRSxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxzQkFBc0IsQ0FBQyxFQUNsRDtnQkFDQSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7b0JBQy9CLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ3BCLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLGNBQWMsbUJBQW1CLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUNsRSxDQUFDLENBQUMsQ0FBQzthQUNKO2lCQUFNLElBQUksR0FBRyxLQUFLLGNBQWMsRUFBRTtnQkFDakMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDLEVBQUU7b0JBQ3hHLE1BQU0sSUFBSSxLQUFLLENBQUMsNEJBQTRCLENBQUMsQ0FBQztpQkFDL0M7Z0JBRUQsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sRUFBZ0IsQ0FBQztnQkFDdEQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsY0FBYyxFQUFHLEVBQUUsT0FBTyxZQUFZLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7Z0JBQy9FLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLHlCQUF5QixDQUFDLENBQUM7YUFDN0M7aUJBQU0sSUFBSSxHQUFHLEtBQUssWUFBWSxFQUFFO2dCQUMvQixJQUFJLFlBQVksR0FBRyxDQUFDLENBQUM7Z0JBQ3JCLElBQUksUUFBUSxHQUFHLENBQUMsQ0FBQztnQkFDakIsSUFBSSxVQUFVLEdBQUcsQ0FBQyxDQUFDO2dCQUVuQixJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsc0JBQXNCLENBQUMsRUFBRTtvQkFDdEcsTUFBTSxJQUFJLEtBQUssQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO2lCQUNoRDtnQkFDRCxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQVMsRUFBRSxFQUFFO29CQUMxQyxJQUFJLGNBQWMsQ0FBQyxDQUFDLENBQUMsS0FBSyxTQUFTLEVBQUU7d0JBQ25DLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQ3BCLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLHFCQUFxQixDQUFDLENBQUM7d0JBQ3hDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLE9BQU8sWUFBWSxFQUFFLENBQUMsQ0FBQzt3QkFDeEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7d0JBQ3pCLFlBQVksSUFBSSxDQUFDLENBQUM7cUJBQ25CO3lCQUFNLElBQUksY0FBYyxDQUFDLENBQUMsQ0FBQyxLQUFLLE9BQU8sRUFBRTt3QkFDeEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFDcEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsbUJBQW1CLENBQUMsQ0FBQzt3QkFDdEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsT0FBTyxVQUFVLEVBQUUsQ0FBQyxDQUFDO3dCQUN0QyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQzt3QkFDekIsVUFBVSxJQUFJLENBQUMsQ0FBQzt3QkFDaEIsd0NBQXdDO3FCQUN6Qzt5QkFBTSxJQUFJLGNBQWMsQ0FBQyxDQUFDLENBQUMsS0FBSyxNQUFNLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsdUJBQXVCLENBQUMsRUFBRTt3QkFDM0YsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFDcEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUseUJBQXlCLENBQUMsQ0FBQzt3QkFDNUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsT0FBTyxRQUFRLEVBQUUsQ0FBQyxDQUFDO3dCQUNwQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQzt3QkFDekIsUUFBUSxJQUFJLENBQUMsQ0FBQztxQkFDZjt5QkFBTSxJQUFJLGNBQWMsQ0FBQyxDQUFDLENBQUMsS0FBSyxRQUFRLEVBQUU7d0JBQ3pDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQ3BCLGNBQWMsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUMzQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztxQkFDMUI7eUJBQU0sSUFDTCxTQUFTLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFDckMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUM3RDt3QkFDQSxPQUFPO3FCQUNSO3lCQUFNO3dCQUNMLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7d0JBQ25DLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUM1QixJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUNwQixJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFDbkMsSUFBSSxDQUFDLFFBQVEsR0FBRyxZQUFZLENBQUM7cUJBQzlCO29CQUNELElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLDRCQUE0QixDQUFDLENBQUM7Z0JBQ2pELENBQUMsQ0FBQyxDQUFDO2FBQ0o7aUJBQU0sSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsa0JBQWtCLENBQUMsSUFBSSxJQUFJLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsc0JBQXNCLENBQUMsRUFBRTtnQkFDM0csSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO29CQUMvQixJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUNwQixJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxjQUFjLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztnQkFDN0QsQ0FBQyxDQUFDLENBQUM7YUFDSjtpQkFBTSxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFO2dCQUNyRCxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxjQUFjLEVBQUcsQ0FBQyxDQUFDO2dCQUN0QyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxjQUFjLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQzthQUM1RDtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFDRSxDQUFDLE1BQU07YUFDSixhQUFhLEVBQUU7YUFDZixHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxXQUFXLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQzthQUNwRixRQUFRLENBQUMsS0FBSyxDQUFDLEVBQ2xCO1lBQ0EsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsdUNBQXVDLEVBQUUsT0FBTyxFQUFFLGdCQUFnQixDQUFDLENBQUM7U0FDMUY7UUFFRCxJQUFJLElBQUksRUFBRTtZQUNSLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLDZCQUE2QixFQUFFLGFBQWEsQ0FBQyxDQUFDO1lBRW5FLElBQUksSUFBSSxLQUFLLGdCQUFnQixJQUFJLG1CQUFtQixDQUFDLFVBQVUsQ0FBQyxLQUFLLE1BQU0sRUFBRTtnQkFDM0UsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsY0FBYyxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsYUFBYSxFQUFFLGFBQWEsQ0FBQyxDQUFDO2dCQUNqRixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQztnQkFDckMsSUFBSSxDQUFDLFFBQVEsR0FBRyxVQUFVLENBQUM7YUFDNUI7aUJBQU0sSUFBSSxJQUFJLEtBQUssbUJBQW1CLEVBQUU7Z0JBQ3ZDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLHFCQUFxQixFQUFFLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUMzRDtTQUNGO0lBQ0gsQ0FBQztJQUVEOzs7TUFHRTtJQUNNLHNCQUFzQixDQUM1QixJQUFhLEVBQ2IsVUFBb0IsRUFDcEIsSUFBWSxFQUNaLFlBQXFCLEtBQUssRUFDMUIsVUFBbUIsS0FBSztRQUV4QixNQUFNLElBQUksR0FBRyxVQUFVLENBQUM7UUFFeEIsSUFBSSxPQUFPLEdBQUcsbUJBQW1CLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFeEMsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sRUFBRTtZQUN4QixJQUFJLENBQUMsU0FBUyxFQUFFLGdCQUFnQixDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7Z0JBQUUsT0FBTyxHQUFHLE9BQU8sQ0FBQztZQUN6RSxJQUFJLENBQUMsT0FBTyxFQUFFLGNBQWMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO2dCQUFFLE9BQU8sR0FBRyxhQUFhLENBQUM7WUFDM0UsSUFBSSxDQUFDLFNBQVMsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO2dCQUFFLE9BQU8sR0FBRyxTQUFTLENBQUM7U0FDOUU7UUFFRCxJQUFJLFNBQVMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDM0MsT0FBTyxHQUFHLE9BQU8sQ0FBQztTQUNuQjtRQUVELElBQUksT0FBTyxLQUFLLFNBQVMsRUFBRTtZQUN6QixJQUFJLElBQUksS0FBSyxnQkFBZ0IsRUFBRTtnQkFDN0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsY0FBYyxDQUFDLENBQUM7Z0JBQ3JDLElBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQztnQkFDL0MsT0FBTzthQUNSO1NBQ0Y7UUFFRCxJQUFJLENBQUMsQ0FBQyxZQUFZLEVBQUUsa0JBQWtCLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDdEQsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxLQUFLLFNBQVMsRUFBRTtnQkFDekMsTUFBTSxLQUFLLENBQUMsa0NBQWtDLElBQUksQ0FBQyxPQUFPLEVBQUUsYUFBYSxPQUFPLEVBQUUsQ0FBQyxDQUFDO2FBQ3JGO1lBRUQsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtnQkFDbEQsSUFBSSxTQUFTLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUM7Z0JBRWhFLElBQUksQ0FBQyxPQUFPLEVBQUUsYUFBYSxFQUFFLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksSUFBSSxDQUFDLGNBQWMsS0FBSyxNQUFNLEVBQUU7b0JBQ25HLE1BQU0sS0FBSyxDQUFDLGlCQUFpQixtQkFBbUIsQ0FBQyxPQUFPLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztpQkFDNUY7Z0JBRUQsSUFBSSxPQUFPLEtBQUssYUFBYTtvQkFBRSxTQUFTLEdBQUcsU0FBUyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUM7Z0JBQ3pFLElBQUksT0FBTyxLQUFLLE9BQU87b0JBQUUsU0FBUyxHQUFHLFNBQVMsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dCQUNyRSxPQUFPLFNBQVMsS0FBSyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNqRCxDQUFDLENBQUMsQ0FBQztZQUVILElBQUksT0FBTyxLQUFLLFNBQVMsSUFBSSxJQUFJLEtBQUssY0FBYyxFQUFFO2dCQUNwRCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSwrQkFBK0IsRUFBRSxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ25FLE9BQU87YUFDUjtZQUVELElBQUksT0FBTyxLQUFLLFNBQVMsSUFBSSxJQUFJLEtBQUssd0JBQXdCLEVBQUU7Z0JBQzlELElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLHlDQUF5QyxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDN0UsT0FBTzthQUNSO1lBRUQsSUFBSSxDQUFDLFFBQVE7Z0JBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQ0FBa0MsSUFBSSxDQUFDLE9BQU8sRUFBRSxRQUFRLE9BQU8sRUFBRSxDQUFDLENBQUM7WUFFbEcsSUFBSSxDQUFDLFNBQVMsSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRTtnQkFDckMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNuQjtZQUNELE9BQU87U0FDUjtRQUVELFFBQVEsSUFBSSxFQUFFO1lBQ1osS0FBSyxZQUFZO2dCQUNmLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLDZCQUE2QixDQUFDLENBQUM7Z0JBQ3hELE9BQU87WUFDVCxLQUFLLGtCQUFrQjtnQkFDckIsSUFBSSxDQUFDLFNBQVMsRUFBRTtvQkFDZCxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxnQ0FBZ0MsQ0FBQyxDQUFDO2lCQUM1RDtnQkFDRCxPQUFPO1lBQ1Q7Z0JBQ0UsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsSUFBSSxJQUFJLElBQUksRUFBRSxDQUFDLENBQUM7U0FDdEQ7SUFDSCxDQUFDO0lBRUQsS0FBSyxDQUFDLFlBQVk7UUFDaEIsSUFBSSxJQUFJLENBQUMsY0FBYyxLQUFLLE1BQU0sRUFBRTtZQUNsQyxNQUFNLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUN2QyxPQUFPO1NBQ1I7UUFFRCxNQUFNLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUMzQyxNQUFNLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRUQsS0FBSyxDQUFDLG1CQUFtQixDQUFDLE9BQXNDO1FBQzlELElBQUksc0JBQXNCLEdBQUcsS0FBSyxDQUFDO1FBQ25DLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDO2FBQzVCLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQzthQUNsQixHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtZQUNULDZCQUE2QjtZQUM3QixJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsRUFBRTtnQkFDM0QsTUFBTSxPQUFPLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtvQkFDdkMsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLEdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7b0JBRWhHLElBQUksSUFBSSxLQUFLLFNBQVM7d0JBQUUsT0FBTyxHQUFHLENBQUM7b0JBRW5DLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRTt3QkFDekQsSUFBSSxPQUFPLEtBQUssTUFBTSxJQUFJLENBQUMsT0FBTyxLQUFLLFVBQVUsSUFBSSxDQUFDLHNCQUFzQixDQUFDLEVBQUU7NEJBQzdFLHNDQUFzQzs0QkFDdEMsT0FBTyxDQUFDLElBQUksQ0FDVixzREFBc0QsSUFBSSxDQUFDLElBQUksS0FBSyxtQkFBbUIsQ0FDckYsSUFBSSxDQUFDLElBQUksQ0FDVixnVUFBZ1UsQ0FDbFUsQ0FBQzs0QkFFRixJQUFJLENBQUMscUJBQXFCLEdBQUcsSUFBSSxDQUFDOzRCQUNsQyxzQkFBc0IsR0FBRyxJQUFJLENBQUM7eUJBQy9CO3dCQUVELE9BQU8sU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7cUJBQzFDO29CQUVELE9BQU8sS0FBSyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQztnQkFDM0QsQ0FBQyxDQUFDLENBQUM7Z0JBRUgsT0FBTyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQzFCO1lBRUQsK0RBQStEO1lBQy9ELElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDdEIsT0FBTyxFQUFFLENBQUM7YUFDWDtZQUVELE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ2xCLENBQUMsQ0FBQzthQUNELElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVkLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBQSxvQkFBSyxFQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUMsU0FBUyxpQ0FBaUMsRUFBRTtZQUNuRyxNQUFNLEVBQUUsTUFBTTtZQUNkLE9BQU8sRUFBRTtnQkFDUCxjQUFjLEVBQUUsWUFBWTtnQkFDNUIsa0JBQWtCLEVBQUUsSUFBSSxDQUFDLFVBQVU7YUFDcEM7WUFDRCxJQUFJO1NBQ0wsQ0FBQyxDQUFDO1FBRUgsTUFBTSxJQUFJLEdBQUcsTUFBTSxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7UUFFbkMsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLEdBQUcsRUFBRTtZQUMzQixJQUFLLElBQUksQ0FBQyxPQUFrQixDQUFDLFFBQVEsQ0FBQyx3QkFBd0IsQ0FBQyxFQUFFO2dCQUMvRCxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQ3ZGLHNDQUFzQztnQkFDdEMsT0FBTyxDQUFDLElBQUksQ0FDVix3QkFBd0IsSUFBSSxDQUFDLElBQUksTUFBTSxPQUFPLHlFQUF5RSxDQUN4SCxDQUFDO2dCQUVGLG1GQUFtRjtnQkFDbkYsMkNBQTJDO2dCQUMzQyxPQUFPLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxDQUFDO2FBQ2hEO1lBQ0Qsc0NBQXNDO1lBQ3RDLE9BQU8sQ0FBQyxLQUFLLENBQ1gsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUM7aUJBQ2YsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO2lCQUNsQixHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7aUJBQy9CLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FDZCxDQUFDO1lBRUYsTUFBTSxJQUFJLEtBQUssQ0FBQyxHQUFHLFFBQVEsQ0FBQyxVQUFVLEtBQUssSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7U0FDNUQ7UUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRTtZQUN0QixNQUFNLGVBQWUsR0FBRyxNQUFNLElBQUEsb0JBQUssRUFBQyxHQUFHLElBQUksQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDLFNBQVMsV0FBVyxFQUFFO2dCQUNwRixNQUFNLEVBQUUsS0FBSztnQkFDYixPQUFPLEVBQUU7b0JBQ1Asa0JBQWtCLEVBQUUsSUFBSSxDQUFDLFVBQVU7aUJBQ3BDO2FBQ0YsQ0FBQyxDQUFDO1lBRUgsTUFBTSxXQUFXLEdBQUcsTUFBTSxlQUFlLENBQUMsSUFBSSxFQUFFLENBQUM7WUFFakQsSUFBSSxDQUFDLFlBQVksR0FBRztnQkFDbEIsS0FBSyxFQUFFLFdBQVcsQ0FBQyxLQUFLLENBQUMsS0FBSztnQkFDOUIsS0FBSyxFQUFFLFdBQVcsQ0FBQyxLQUFLLENBQUMsS0FBSztnQkFDOUIsS0FBSyxFQUFFLFdBQVcsQ0FBQyxLQUFLLENBQUMsWUFBWTtnQkFDckMsVUFBVSxFQUFFLFdBQVcsQ0FBQyxLQUFLLENBQUMsV0FBVzthQUMxQyxDQUFDO1NBQ0g7UUFFRCxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDL0MsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7U0FDOUM7UUFFRCxJQUFJLENBQUMsb0JBQW9CLENBQUMsT0FBTyxDQUFDLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDLFVBQVUsQ0FBQztRQUVuRixJQUFJLE9BQU8sS0FBSyxPQUFPO1lBQUUsT0FBTyxJQUFJLENBQUM7UUFFckMsTUFBTSxPQUFPLEdBQUcsTUFBTSxZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUU1RCxJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUM7UUFDakMsSUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDO1FBRWpDLElBQUksT0FBTyxLQUFLLE1BQU0sRUFBRTtZQUN0QixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssMkNBQTJDLENBQUUsQ0FBQztZQUM1RyxRQUFRLENBQUMsSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1NBQ2xDO1FBRUQsSUFBSSxZQUFZLEdBQUcsQ0FBQyxDQUFDO1FBQ3JCLElBQUksY0FBYyxHQUFHLENBQUMsQ0FBQztRQUV2QixJQUFJLElBQUksQ0FBQyxxQkFBcUIsRUFBRTtZQUM5QixNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztZQUNuRyxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztZQUNqRyxjQUFjLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFjLEVBQUUsYUFBYSxDQUFDLENBQUM7WUFFekQsWUFBWSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFFLENBQUM7U0FDdEQ7UUFDRCxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFO1lBQzdCLElBQUksSUFBSSxDQUFDLHFCQUFxQixFQUFFO2dCQUM5QixJQUFJLEVBQUUsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLGNBQWM7b0JBQUUsT0FBTztnQkFDMUMsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO2dCQUV2QywwREFBMEQ7Z0JBQzFELElBQUksR0FBRyxLQUFLLFNBQVM7b0JBQUUsT0FBTztnQkFFOUIsNkNBQTZDO2dCQUM3QyxFQUFFLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxZQUFZLENBQUMsQ0FBQztnQkFDbEUsT0FBTzthQUNSO1lBQ0QsNkNBQTZDO1lBQzdDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3JDLENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRU8sZ0JBQWdCLENBQUMsSUFBYSxFQUFFLEtBQWUsRUFBRSxPQUFnQjtRQUN2RSxJQUNFLENBQUMsS0FBSztZQUNOLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxJQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxDQUFDO1lBQ2pELElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxJQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxDQUFDLEVBQy9DO1lBQ0EsT0FBTztTQUNSO1FBRUQsTUFBTSxRQUFRLEdBQUcsY0FBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO1FBQzdFLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLE1BQU0sUUFBUSxJQUFJLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUVuRSxNQUFNLEtBQUssR0FBRyxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDNUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxLQUFLLENBQUMsQ0FBQztRQUUvQixJQUFJLENBQUMsc0JBQXNCLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7SUFDakUsQ0FBQztJQUVELGdCQUFnQjtRQUNkLE1BQU0sb0JBQW9CLEdBQUcsQ0FBQyxRQUF1QyxFQUFFLEVBQUU7WUFDdkUsTUFBTSxNQUFNLEdBQWtCLEVBQUUsQ0FBQztZQUVqQyxnREFBZ0Q7WUFDaEQsS0FBSyxNQUFNLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxFQUFFO2dCQUMvRCxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO29CQUMxQixNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsb0JBQW9CLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2lCQUNoRTtxQkFBTTtvQkFDTCxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsbUJBQW1CLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2lCQUMvRDthQUNGO1lBRUQsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQyxDQUFDO1FBRUYsTUFBTSxLQUFLLEdBQTJCO1lBQ3BDLE1BQU0sRUFBRTtnQkFDTixNQUFNLEVBQUU7b0JBQ04sS0FBSyxFQUFFLENBQUM7b0JBQ1IsSUFBSSxFQUFFLENBQUM7aUJBQ1I7Z0JBQ0QsS0FBSyxFQUFFO29CQUNMLEtBQUssRUFBRSxDQUFDO29CQUNSLElBQUksRUFBRSxDQUFDO2lCQUNSO2FBQ0Y7WUFDRCxJQUFJLEVBQUU7Z0JBQ0osTUFBTSxFQUFFLEVBQUU7Z0JBQ1YsS0FBSyxFQUFFLEVBQUU7Z0JBQ1QsR0FBRyxFQUFFLEVBQUU7YUFDUjtZQUNELElBQUksRUFBRTtnQkFDSixNQUFNLEVBQUUsRUFBRTtnQkFDVixLQUFLLEVBQUUsRUFBRTtnQkFDVCxHQUFHLEVBQUUsRUFBRTthQUNSO1NBQ0YsQ0FBQztRQUVGLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDO1FBRXJFLE1BQU0sS0FBSyxHQUFrQjtZQUMzQixHQUFHLElBQUksQ0FBQyxlQUFlLEVBQUU7WUFDekIsSUFBSSxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUNiLE9BQU8sRUFBRSxFQUFFO1lBQ1gsS0FBSztZQUNMLFdBQVcsRUFBRSxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRTtZQUNyQyw2QkFBNkI7WUFDN0IsVUFBVSxFQUFFO2dCQUNWLFFBQVEsRUFBRTtvQkFDUix3REFBd0Q7b0JBQ3hELFVBQVU7b0JBQ1YsY0FBYyxFQUFFLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxNQUFNO2lCQUNoRTtnQkFDRCxLQUFLLEVBQUUsRUFBRSxVQUFVLEVBQUUsRUFBRSxFQUFFLGNBQWMsRUFBRSxNQUFNLEVBQUU7YUFDbEQ7WUFDRCxNQUFNLEVBQUU7Z0JBQ04sUUFBUSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQztnQkFDMUYsS0FBSyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQzthQUNyRjtTQUNGLENBQUM7UUFFRixNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRTtZQUM5QyxJQUFJLEVBQUUsQ0FBQyxHQUFHLEVBQUU7Z0JBQ1YsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHO29CQUM3QixHQUFHLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQztvQkFDM0MsT0FBTyxFQUFFLFVBQVU7b0JBQ25CLFNBQVMsRUFBRSxVQUFVLENBQUMsRUFBRSxDQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsbUJBQW1CLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQztpQkFDdEcsQ0FBQzthQUNIO2lCQUFNO2dCQUNMLElBQUksT0FBTyxHQUFHLFVBQVUsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQ3JHLElBQUksU0FBUyxHQUFHLFVBQVUsQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBRTNHLE1BQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztnQkFFaEQsSUFBSSxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksS0FBSyxRQUFRLEVBQUU7b0JBQ2xDLFNBQVMsR0FBRyxRQUFRLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztvQkFDL0MsS0FBSyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxvQkFBb0IsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUM7aUJBQy9EO2dCQUVELElBQUksRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO29CQUNoQyxPQUFPLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO29CQUNoQyxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLG9CQUFvQixDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQztpQkFDM0Q7Z0JBRUQsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHO29CQUM3QixPQUFPO29CQUNQLFNBQVM7b0JBQ1QsTUFBTSxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUztpQkFDMUUsQ0FBQzthQUNIO1lBRUQsSUFBSSxFQUFFLENBQUMsSUFBSSxLQUFLLFFBQVEsSUFBSSxFQUFFLENBQUMsSUFBSSxLQUFLLE9BQU8sRUFBRTtnQkFDL0MsSUFBSSxTQUFTLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFO29CQUMzQixLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUM7aUJBQy9DO3FCQUFNO29CQUNMLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssSUFBSSxFQUFFLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQztpQkFDaEQ7YUFDRjtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtZQUMxQixNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFFLENBQUM7WUFDcEUsTUFBTSxPQUFPLEdBQUcsVUFBVSxDQUFDLE1BQU0sQ0FBQztZQUVsQyw2Q0FBNkM7WUFDN0MsQ0FBQyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7WUFFcEIsSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGlCQUFpQixDQUFDLEVBQUU7Z0JBQzNELE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDO2dCQUV6RSxJQUFJLGNBQWMsQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO29CQUNwQyxNQUFNLGNBQWMsR0FDbEIsVUFBVSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztvQkFDekcsTUFBTSxVQUFVLEdBQUcsY0FBYyxFQUFFLE9BQU8sRUFBRSxDQUFDO29CQUU3Qyw2Q0FBNkM7b0JBQzdDLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLFVBQVUsQ0FBQztvQkFDOUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEVBQUU7d0JBQzlCLEtBQUssQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEdBQUcsb0JBQW9CLENBQUMsY0FBYyxDQUFDLENBQUM7cUJBQ2xFO2lCQUNGO2dCQUVELFVBQVUsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7b0JBQzVDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBRSxDQUFDO29CQUV4RCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO29CQUUvQyxJQUFJLFFBQVEsQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO3dCQUM5QixNQUFNLFVBQVUsR0FBRyxDQUFDLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7d0JBQ3BHLEdBQUcsQ0FBQyxNQUFNLEdBQUcsVUFBVSxDQUFDO3dCQUN4QixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsRUFBRTs0QkFDOUIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsR0FBRyxvQkFBb0IsQ0FBQyxRQUFRLENBQUMsQ0FBQzt5QkFDNUQ7cUJBQ0Y7Z0JBQ0gsQ0FBQyxDQUFDLENBQUM7YUFDSjtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDM0MsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFFM0MsSUFBSSxJQUFJLEdBQUcsbUJBQW1CLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDekMsSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBRTtnQkFDOUIsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFDakYsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEVBQUU7b0JBQzlCLEtBQUssQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEdBQUcsb0JBQW9CLENBQUMsUUFBUSxDQUFDLENBQUM7aUJBQzVEO2dCQUNELElBQUksR0FBRyxVQUFVLENBQUM7YUFDbkI7WUFFRCxLQUFLLENBQUMsaUJBQWlCLEtBQXZCLEtBQUssQ0FBQyxpQkFBaUIsR0FBSyxFQUFFLEVBQUM7WUFDL0IsS0FBSyxDQUFDLGlCQUFrQixDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLENBQUM7UUFDekMsQ0FBQyxDQUFDLENBQUM7UUFFSCxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtZQUN0QyxNQUFNLEVBQUUsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNqQyxJQUFJLElBQUksS0FBSyxTQUFTO2dCQUFFLE9BQU87WUFFL0IsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFFdEMsSUFBSSxJQUFJLEdBQUcsbUJBQW1CLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDekMsSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBRTtnQkFDOUIsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFDNUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEVBQUU7b0JBQzlCLEtBQUssQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEdBQUcsb0JBQW9CLENBQUMsUUFBUSxDQUFDLENBQUM7aUJBQzVEO2dCQUNELElBQUksR0FBRyxVQUFVLENBQUM7YUFDbkI7WUFFRCxLQUFLLENBQUMsZ0JBQWdCLEtBQXRCLEtBQUssQ0FBQyxnQkFBZ0IsR0FBSyxFQUFFLEVBQUM7WUFDOUIsS0FBSyxDQUFDLGdCQUFpQixDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDO1FBQzlDLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUU7WUFDakUsS0FBSyxDQUFDLFFBQVEsR0FBRztnQkFDZixRQUFRLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVE7Z0JBQ3hDLEtBQUssRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSzthQUNuQyxDQUFDO1NBQ0g7UUFFRCxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDckIsS0FBSyxDQUFDLFlBQVksR0FBRztnQkFDbkIsUUFBUSxFQUFFLE9BQU87Z0JBQ2pCLGVBQWUsRUFBRSxJQUFJLENBQUMsWUFBWTthQUNuQyxDQUFDO1NBQ0g7UUFFRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRCw4REFBOEQ7SUFDOUQsZ0JBQWdCO1FBQ2QsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDbEcsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDNUYsTUFBTSxjQUFjLEdBQTJCLEVBQUUsQ0FBQztRQUNsRCxNQUFNLGFBQWEsR0FBMkIsRUFBRSxDQUFDO1FBRWpELE1BQU0sS0FBSyxHQUFHO1lBQ1osTUFBTSxFQUFFO2dCQUNOLGVBQWUsRUFBRSxDQUFDO2dCQUNsQixTQUFTLEVBQUUsQ0FBQzthQUNiO1lBQ0QsS0FBSyxFQUFFO2dCQUNMLGVBQWUsRUFBRSxDQUFDO2dCQUNsQixTQUFTLEVBQUUsQ0FBQzthQUNiO1NBQ0YsQ0FBQztRQUNGLGdEQUFnRDtRQUNoRCxLQUFLLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUU7WUFDdEQsUUFBUSxDQUFDLENBQUMsSUFBSSxFQUFFO2dCQUNkLEtBQUssUUFBUTtvQkFDWCxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEVBQUU7d0JBQzFCLEtBQUssQ0FBQyxNQUFNLENBQUMsU0FBUyxJQUFJLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDO3dCQUN6QyxJQUFJLENBQUMsQ0FBQyxHQUFHOzRCQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztxQkFDL0Q7eUJBQU07d0JBQ0wsSUFBSSxDQUFDLENBQUMsR0FBRzs0QkFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7d0JBQzdELEtBQUssQ0FBQyxNQUFNLENBQUMsZUFBZSxJQUFJLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDO3FCQUNoRDtvQkFFRCxNQUFNO2dCQUNSLEtBQUssT0FBTztvQkFDVixJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEVBQUU7d0JBQzFCLEtBQUssQ0FBQyxLQUFLLENBQUMsU0FBUyxJQUFJLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDO3dCQUN4QyxJQUFJLENBQUMsQ0FBQyxHQUFHOzRCQUFFLGFBQWEsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztxQkFDOUQ7eUJBQU07d0JBQ0wsS0FBSyxDQUFDLEtBQUssQ0FBQyxlQUFlLElBQUksQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUM7d0JBQzlDLElBQUksQ0FBQyxDQUFDLEdBQUc7NEJBQUUsYUFBYSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO3FCQUM3RDtvQkFDRCxNQUFNO2dCQUNSO29CQUNFLE1BQU07YUFDVDtTQUNGO1FBRUQsSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLGVBQWUsR0FBRyxFQUFFLEVBQUU7WUFDOUQsTUFBTSxJQUFJLEtBQUssQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO1NBQ2hEO1FBRUQsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLGVBQWUsR0FBRyxFQUFFLEVBQUU7WUFDNUQsTUFBTSxJQUFJLEtBQUssQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO1NBQy9DO1FBRUQsTUFBTSxLQUFLLEdBQTJFLEVBQUUsQ0FBQztRQUV6RixNQUFNLEtBQUssR0FBRztZQUNaLEtBQUs7WUFDTCxnQkFBZ0IsRUFBRTtnQkFDaEIsS0FBSyxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLE1BQU0sSUFBSSxPQUFPO2dCQUNsRCxNQUFNLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsTUFBTSxJQUFJLE9BQU87Z0JBQ3BELFNBQVMsRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsRUFBRSxNQUFNLElBQUksT0FBTztnQkFDMUQsa0JBQWtCLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxpQkFBaUIsRUFBRSxNQUFNLElBQUksT0FBTztnQkFDNUUsa0JBQWtCLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxpQkFBaUIsRUFBRSxNQUFNLElBQUksT0FBTzthQUM3RTtZQUNELE1BQU0sRUFBRTtnQkFDTixLQUFLLEVBQUUsRUFBRSxRQUFRLEVBQUUsYUFBYSxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUU7Z0JBQ2hELE1BQU0sRUFBRSxFQUFFLFFBQVEsRUFBRSxjQUFjLEVBQUUsUUFBUSxFQUFFLEVBQUUsRUFBRTthQUNuRDtZQUNELEtBQUs7WUFDTCxNQUFNLEVBQUUsRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFO1lBQzNCLFFBQVEsRUFBRSxJQUFJLENBQUMsZUFBZSxFQUFFO1NBQ2pDLENBQUM7UUFFRixJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtZQUM3QixNQUFNLFNBQVMsR0FBRyxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxtQkFBbUIsQ0FDNUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQ2Y7aUJBQ0UsT0FBTyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUM7aUJBQzNCLE9BQU8sQ0FBQyxjQUFjLEVBQUUsUUFBUSxDQUFDO2lCQUNqQyxPQUFPLENBQUMsVUFBVSxFQUFFLFNBQVMsQ0FBQyxFQUFFLENBQUM7WUFFcEMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxHQUFHO2dCQUNqQixXQUFXLEVBQUUsRUFBRTthQUNoQixDQUFDO1lBRUYsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBRSxDQUFDO1lBRXBFLFVBQVUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFO2dCQUN0QyxNQUFNLE9BQU8sR0FBRyxFQUFFO3FCQUNmLEtBQUssQ0FBQyxjQUFjLENBQUM7cUJBQ3JCLElBQUksQ0FBQyxHQUFHLENBQUM7cUJBQ1QsV0FBVyxFQUFFLENBQUM7Z0JBQ2pCLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLEdBQUcsUUFBUSxDQUFDO1lBQ25ELENBQUMsQ0FBQyxDQUFDO1lBRUgsVUFBVSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUU7Z0JBQ3BDLElBQUksRUFBRSxLQUFLLFlBQVk7b0JBQUUsT0FBTztnQkFDaEMsTUFBTSxPQUFPLEdBQUcsRUFBRTtxQkFDZixLQUFLLENBQUMsY0FBYyxDQUFDO3FCQUNyQixJQUFJLENBQUMsR0FBRyxDQUFDO3FCQUNULFdBQVcsRUFBRSxDQUFDO2dCQUNqQixLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxHQUFHLE1BQU0sQ0FBQztZQUNqRCxDQUFDLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQsVUFBVSxDQUFDLElBQWdCO1FBQ3pCLE1BQU0sTUFBTSxHQUFlLEVBQUUsQ0FBQztRQUM5QixJQUFJLFFBQVEsR0FBYSxFQUFFLENBQUM7UUFFNUIsSUFBSSxhQUFhLEdBQUcsS0FBSyxDQUFDO1FBQzFCLElBQUksV0FBVyxHQUFZLEtBQUssQ0FBQztRQUVqQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3BCLE1BQU0sUUFBUSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFDeEIsSUFBSSxRQUFRLEtBQUssOENBQThDO2dCQUFFLE9BQU87WUFDeEUsSUFBSSxRQUFRLEtBQUsseUJBQXlCLEVBQUU7Z0JBQzFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQztnQkFDdEQsT0FBTzthQUNSO1lBRUQsSUFBSSxRQUFRLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUM3QixJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUUsQ0FBQyxJQUFJLEtBQUssRUFBRSxJQUFJLENBQUMsV0FBVztvQkFDckUsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dCQUNsRCxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUN4QixPQUFPO2FBQ1I7WUFFRCxNQUFNLE9BQU8sR0FBRyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7WUFFdkYsSUFBSSxPQUFPLElBQUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBRSxDQUFDLElBQUksS0FBSyxFQUFFO2dCQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUUzRixhQUFhLEdBQUcsYUFBYSxJQUFJLE9BQU8sQ0FBQztZQUV6QyxJQUFJLE9BQU8sSUFBSSxRQUFRLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFO2dCQUN6RCxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDaEUsUUFBUSxHQUFHLEVBQUUsQ0FBQztnQkFDZCxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUM7Z0JBQzlDLFdBQVcsR0FBRyxPQUFPLENBQUM7YUFDdkI7aUJBQU07Z0JBQ0wsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQzlGLFFBQVEsR0FBRyxFQUFFLENBQUM7Z0JBQ2QsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxLQUFLLFFBQVEsRUFBRSxFQUFFLFlBQVksRUFBRSxDQUFDLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQztnQkFDbkYsV0FBVyxHQUFHLEtBQUssQ0FBQzthQUNyQjtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQzs7QUF0ME9ILDJCQWk0T0M7QUE5M09RLGlCQUFRLEdBQWEsQ0FBQyxFQUFFLENBQUMsQ0FBQyJ9