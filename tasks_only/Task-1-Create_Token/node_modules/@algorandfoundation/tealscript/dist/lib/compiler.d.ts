import { Project } from 'ts-morph';
import * as ts from 'ts-morph';
import { type ARC56Contract } from '../types/arc56.d';
export type CompilerOptions = {
    /** The path in the ts-morph Project that contains the source file to compile */
    srcPath: string;
    /** The name of the contract class to use as an entry point */
    className: string;
    /** The ts-morph Project containing all of the source files and TEALScript */
    project: Project;
    /**
     * The path to use as a current working directory.
     * This is used when writing source locations in the TEAL and when generating error messages.
     */
    cwd: string;
    /** TEALScript will console.warn compiler warnings unless this is set to true */
    disableWarnings?: boolean;
    /** The algod server to use when compiling and getting the source map */
    algodServer?: string;
    /** The algod token to use when compiling and getting the source map */
    algodToken?: string;
    /** The port to use when compiling and getting the source map */
    algodPort?: number;
    /** Disables overflow checks for numeric operations. This is NOT safe but does save some opcodes */
    disableOverflowChecks?: boolean;
    /**
     * Disables the type checker. This is NOT safe but does save some compile time.
     * Generally this should NEVER be used and instead the developer should use ts-expect-error
     */
    disableTypeScript?: boolean;
    /**
     * The path in the ts-morph Project that contains the TEALScript lib directory.
     * This should only need to be provided when used in a browser.
     */
    tealscriptLibDir?: string;
    /**
     * The path in the ts-morph Project that contains the TEALScript types directory.
     * This should only need to be provided when used in a browser.
     */
    tealscriptTypesDir?: string;
    /**
     * Skip algod compilation. This results in no source mapping and no algod assebmler error checking.
     */
    skipAlgod?: boolean;
};
export type SourceInfo = {
    filename: string;
    start: ts.ts.LineAndCharacter;
    end: ts.ts.LineAndCharacter;
};
type TypeInfo = {
    kind: 'tuple';
    elements: TypeInfo[];
} | {
    kind: 'object';
    properties: {
        [key: string]: TypeInfo;
    };
} | {
    kind: 'base';
    type: string;
} | {
    kind: 'dynamicArray';
    base: TypeInfo;
} | {
    kind: 'staticArray';
    base: TypeInfo;
    length: number;
} | {
    kind: 'method';
    args: TypeInfo[];
    returns: TypeInfo;
    name?: string;
};
interface ABIMethod {
    name: string;
    readonly?: boolean;
    desc: string;
    args: {
        name: string;
        type: TypeInfo;
        desc: string;
    }[];
    returns: {
        type: TypeInfo;
        desc: string;
    };
    events: string[];
}
export type TEALInfo = {
    node: ts.Node;
    teal: string;
    errorMessage?: string;
};
/** @internal */
export default class Compiler {
    private pendingSubroutines;
    static diagsRan: string[];
    private scratch;
    private currentProgram;
    teal: {
        approval: TEALInfo[];
        clear: TEALInfo[];
        lsig: TEALInfo[];
    };
    generatedTeal: string;
    generatedClearTeal: string;
    private frameInfo;
    private lastNode;
    private mapKeyTypes;
    private classNode;
    sourceInfo: {
        source: string;
        teal: number;
        pc?: number[];
        errorMessage?: string;
    }[];
    private frameIndex;
    private frameSize;
    private subroutines;
    private clearStateCompiled;
    private ifCount;
    private ternaryCount;
    private whileCount;
    private doWhileCount;
    private forCount;
    srcPath: string;
    private processErrorNodes;
    private localVariables;
    private currentSubroutine;
    private bareCallConfig;
    abi: {
        name: string;
        desc: string;
        methods: ABIMethod[];
    };
    private storageProps;
    private lastType;
    name: string;
    pcToLine: {
        [key: number]: number;
    };
    lineToPc: {
        [key: number]: number[];
    };
    private lastSourceCommentRange;
    private comments;
    private typeHint?;
    private readonly OP_PARAMS;
    programVersion: number;
    templateVars: Record<string, {
        name: string;
        type: TypeInfo;
        initNode: ts.CallExpression;
    }>;
    project: Project;
    skipAlgod: boolean;
    currentForEachLabel?: string;
    forEachCount: number;
    forOfCount: number;
    currentLoop?: string;
    innerTxnHasBegun: boolean;
    compiledPrograms: {
        [program in 'clear' | 'approval' | 'lsig']?: string;
    };
    algodVersion?: {
        major: number;
        minor: number;
        patch: number;
        commitHash: string;
    };
    hasDynamicTemplateVar: boolean;
    /**
     * The estimated size of the program in bytes
     * This is an estimation because future versions of algod or differen template variable value may change the size
     */
    estimatedProgramSize: {
        [program in 'clear' | 'approval' | 'lsig']?: number;
    };
    /** Verifies ABI types are properly decoded for runtime usage */
    private checkDecoding;
    private processNewValue;
    /** Handle any action related to boxes or local/global state */
    private handleStorageAction;
    private andCount;
    private orCount;
    private sourceFile;
    private nodeDepth;
    /**
       The current top level node being processed within a method
  
      This is used to determine if a function call should return a value or not. For example,
  
      ```ts
      class Foo {
        bar(arr: number[]) {
          const x = arr.pop(); // "arr.pop()" is NOT top-level node
          arr.pop(); // "arr.pop()" is top-level node
        }
      }
      ```
     */
    private topLevelNode;
    private getTypeInfo;
    private getAliasedTypeNode;
    private multiplyWideRatioFactors;
    private customProperties;
    arc4Description(): {
        name: string;
        desc: string;
        methods: any[];
        events: {
            name: string;
            args: {
                name: string;
                type: string;
                desc: string | undefined;
            }[];
            desc: string;
        }[] | undefined;
    };
    private verifyTxn;
    private forIterator;
    private opcodeImplementations;
    private customMethods;
    private disableWarnings;
    private algodServer;
    private algodPort;
    private algodToken;
    private disableOverflowChecks;
    private disableTypeScript;
    private events;
    private libDir;
    private typesDir;
    private cwd;
    constructor(options: CompilerOptions);
    static compileAll(options: Omit<CompilerOptions, 'className'>): Promise<Compiler>[];
    getOpParamObjects(op: string): {
        name: string;
        args: number;
        fn: (node: ts.Node) => void;
    }[];
    private isDynamicType;
    private getTypeLength;
    private getClassInfo;
    private postProcessTeal;
    private getTypeScriptDiagnostics;
    /**
     * Process the signatures of all of the subroutines so that they can be called in any order
     *
     * @param methods The methods to process
     */
    preProcessMethods(methods: (ts.MethodDeclaration | ts.FunctionDeclaration)[]): void;
    /**
     * Gets the class child nodes for a superclass
     */
    getSuperClassNodes(superClassNode: ts.Node, methodNodes: ts.MethodDeclaration[], propertyNodes: ts.PropertyDeclaration[]): void;
    /**
     * Get the child nodes of the contract class
     */
    getClassChildren(): {
        methodNodes: ts.MethodDeclaration[];
        propertyNodes: ts.PropertyDeclaration[];
    };
    private initializeTEAL;
    compile(): Promise<void>;
    private push;
    private pushVoid;
    private getSignature;
    private pushMethod;
    private routeAbiMethods;
    private assertMaybeValue;
    private popMaybeValue;
    private hasMaybeValue;
    private pushComments;
    private processThrowStatement;
    private processDoStatement;
    private processWhileStatement;
    private processForStatement;
    private processForOfStatement;
    /**
     * Every node in the AST is passed through this function.
     */
    private processNode;
    private processObjectLiteralExpression;
    private processConditionalExpression;
    private pushLines;
    private getarrayElementTypes;
    private processBools;
    private processTuple;
    private checkEncoding;
    private getTupleElement;
    private processArrayElements;
    private processArrayLiteralExpression;
    /**
     *
     * @param node The top level node to process
     * @param chain The existing expression chain to add to
     * @returns The base expression and reversed expression chain `this.txn.sender` ->
     * `{ chain: [this.txn, this.txn.sender], base: [this] }`
     */
    private getExpressionChain;
    private getAccessChain;
    /**
     * Given a variable name, this function will return the value that we ultimately need to get from the frame
     *
     * For example:
     *
     * ```ts
     * const x = a[1][2]
     * const y = x[3][4]
     * ```
     *
     * Given `y`, return that we are ultimately accessing `a[1][2][3][4]`
     *
     * @param node The node of the variable that we're accessing
     * @param inputName The name of the variable that we're accessing
     * @param load Whether or not to load the value and put it on the stack. If false, it will just return information about the frame object
     * @returns
     */
    private processFrame;
    private updateValue;
    private compilerSubroutines;
    private getElementHead;
    private processLiteralStaticTupleAccess;
    private processParentArrayAccess;
    private processMethodDefinition;
    private processBlockStatement;
    private processReturnStatement;
    private fixBitWidth;
    private getStackTypeAfterFunction;
    private getStackTypeFromNode;
    private isBinaryExpression;
    mathType: string;
    private usingValue;
    private processBinaryExpression;
    private processLogicalExpression;
    private processIdentifier;
    private processNewExpression;
    private fixByteWidth;
    private processTypeCast;
    private processVariableDeclaration;
    /**
     * Saves information about storage access such as the key (and account if local storage) to the frame
     *
     * @param node The node that is saving storage access in a variable
     * @param name The name of the new variable
     * @param storageExpression The expression for accessing the storage property
     * @param type The value type
     * @param accessors If accessing an array, save the accessors used (ie. if `this.myArrays('foo').value[0][1]` then save [0, 1])
     */
    private initializeStorageFrame;
    private processVariableDeclarator;
    private processExpressionStatement;
    private isDynamicArrayOfStaticType;
    private processConditional;
    private processIfStatement;
    private processUnaryExpression;
    private processPropertyDefinition;
    private getNumericLiteralValueString;
    private processNumericLiteralWithType;
    private processLiteral;
    /**
     * Method for handling an expression chain that starts with `this`
     *
     * Note this method will delete elements from the chain as they are processed
     *
     * @param chain Expression chain to process
     * @param newValue New value to assign to the chain expression
     */
    private processThisBase;
    private processCallExpression;
    private methodTypeArgsToTypes;
    /**
     * Walks an expression chain and processes each node
     * @param node The node to process
     * @param newValue If we are setting the value of an array, the new value will be passed here
     */
    private processExpressionChain;
    private processSubroutine;
    private processClearState;
    private overflowCheck;
    private processRoutableMethod;
    private opcodeAliases;
    private processOpcode;
    private initialFrameBury;
    private frameBury;
    private frameDig;
    private processTransaction;
    private processOpcodeImmediate;
    algodCompile(): Promise<void>;
    algodCompileProgram(program: 'approval' | 'clear' | 'lsig'): Promise<{
        result: string;
        hash: string;
    }>;
    private addSourceComment;
    arc56Description(): ARC56Contract;
    arc32Description(): any;
    prettyTeal(teal: TEALInfo[]): TEALInfo[];
}
export {};
